<!DOCTYPE html>
<html>
<head>
<style>
canvas {
width: 1280px;
image-rendering: pixelated;
background-color: #000;
}
</style>
<egg-rom style="display:none">
r74(7k0FCXRpdGxlTGlnaHRzIE9uCAF0aXRsZVN0cjIGDmF1dGhvckFLIFNvbW1lcnZpbGxlCQp0aW1lc3RhbXAyMDI0LTA1LTEyCwdm
cmFtZWJ1ZmZlcjMyMHgxODAJAWljb25JbWFnZTEIAmxhbmd1YWdlZW4)t0r10d1d(AGFzbQEAAAAB2AEdYAJ/fwF/YAF/AGACf38AYAJ/fABgBn9/
f39/fwBgBH9/f38Bf2AHf39/f39/fwF/YAABf2AEf39/fwBgBX9/f39/AX9gAAF8YAN/f38AYAl/f39/f39/f38AYAt/f39/f39/
f39/fwBgAX8Bf2ADf39/AX9gAXwAYAAAYAZ/f39/f38Bf2AKf39/f39/f39/fwF/YAl/f39/f39/f38Bf2AIf39/f39/f38Bf2AF
f39/f38AYAF8AXxgAnx8AXxgAnx/AXxgAXwBf2ACf38BfGADf398AX8CgQclA2VudhRlZ2dfaW1hZ2VfZ2V0X2hlYWRlcgAEA2Vu
dhBlZ2dfaW1hZ2VfZGVjb2RlAAUDZW52EmVnZ190ZXh0dXJlX3VwbG9hZAAGA2Vudg9lZ2dfdGV4dHVyZV9uZXcABwNlbnYPZWdn
X3RleHR1cmVfZGVsAAEDZW52FmVnZ190ZXh0dXJlX2dldF9oZWFkZXIACANlbnYPZWdnX3JlbmRlcl90aW50AAEDZW52EGVnZ19y
ZW5kZXJfYWxwaGEAAQNlbnYNZWdnX2RyYXdfdGlsZQAIA2VudhBlZ2dfcmVzX2Zvcl9lYWNoAAADZW52FmVnZ19nZXRfdXNlcl9s
YW5ndWFnZXMAAANlbnYLZWdnX3Jlc19nZXQACQNlbnYHZWdnX2xvZwACA2Vudg1lZ2dfdGltZV9yZWFsAAoDZW52DWVnZ19kcmF3
X3JlY3QABANlbnYNZWdnX2RyYXdfbGluZQALA2Vudg1lZ2dfZHJhd190cmlnAAsDZW52DmVnZ19kcmF3X2RlY2FsAAwDZW52FGVn
Z19kcmF3X2RlY2FsX21vZGU3AA0DZW52G2VnZ19qb3lzdGlja19kZXZpZF9ieV9pbmRleAAOA2VudhRlZ2dfYXVkaW9fcGxheV9z
b3VuZAAIA2VudhBlZ2dfZXZlbnRfZW5hYmxlAAADZW52FGVnZ19qb3lzdGlja19nZXRfaWRzAAgDZW52HGVnZ19qb3lzdGlja19m
b3JfZWFjaF9idXR0b24ADwNlbnYVZWdnX2pveXN0aWNrX2dldF9uYW1lAA8DZW52D2VnZ19sb2NrX2N1cnNvcgAOA2Vudg5lZ2df
dGltZV9sb2NhbAACA2VudhZlZ2dfdGV4dHVyZV9sb2FkX2ltYWdlAA8DZW52DWVnZ19zdG9yZV9nZXQABQNlbnYNZWdnX3N0b3Jl
X3NldAAFA2VudhZlZ2dfc3RvcmVfa2V5X2J5X2luZGV4AA8DZW52D2VnZ19hdWRpb19ldmVudAAIA2VudhZlZ2dfYXVkaW9fZ2V0
X3BsYXloZWFkAAoDZW52E2VnZ19hdWRpb19wbGF5X3NvbmcACANlbnYWZWdnX2F1ZGlvX3NldF9wbGF5aGVhZAAQA2VudhdlZ2df
cmVxdWVzdF90ZXJtaW5hdGlvbgARA2Vudg1lZ2dfZXZlbnRfZ2V0AAADsAGuAREBDg8ODg4SEg8TCQAUFBUIARYWDw8HCQUAAAcB
Dw8PDw4PFxcXGBkYGBcXGRkXFxoRDgEAAAcBEQ4BAwILDgEDAgEOAQEAAgMBDwILAQMBBQAbBQ8cDgEDAgEJAQ4BAwIBAgcBDgED
AgESCw4BDgEDAgEOARwOAQMCAQ4BAwIBDgEBDgEDAQgOAQEDDgEDAgEJCQ4BDgEDAgEOAgEBAgEJDgEDAgEOAREBBxEQEQQFAXAB
SEgFBAEAwQIGCQF/AUGwpYAKCwd2BgZtZW1vcnkCABlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQAPZWdnX2NsaWVudF9xdWl0
AM0BD2VnZ19jbGllbnRfaW5pdADPARFlZ2dfY2xpZW50X3VwZGF0ZQDRARFlZ2dfY2xpZW50X3JlbmRlcgDSAQmEAQEAQQELRzxf
YGFkZWZnaXx9fn+AAYMBhAGFAYYBiQF0c3CLAYwBjQGOAY8BkgGUAZUBlgGXAZkBnAGdAZ4BnwGhAaIBowGkAaYBpwGpAaoBqwGu
Aa8BsAGyAbMBtAG1AbYBtwG5AbsBvAG9Ab4BwAHBAcIBwwHEAcUBxwHIAckBygHMAQqJ4AOuAQIAC6QBAQN/AkAgAEUNAAJAIAAo
AggiAUUNACAAIAAoAgwiAkF/aiIDNgIMAkAgAkEBSA0AA0ACQCABIANBHGxqIgEoAhQiA0UNACADENiAgIAACwJAIAEoAhgiAUUN
ACABENiAgIAACyAAIAAoAgwiAUF/aiIDNgIMAkAgAUEBSA0AIAAoAgghAQwBCwsgACgCCCEBCyABENiAgIAACyAAENiAgIAACws4
AQJ/QQAhAQJAIABBAUgNAEEBQRQQ2oCAgAAiAkUNACACIAA2AgAgAiAAQQF2NgIEIAIhAQsgAQu8CQEafyOAgICAAEEQayIDJICA
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
IA9BigFBARC3gICAACAAKAIMIBsgCSAMakEQdEEQdSILQYYBQQAQt4CAgAAgACgCDCAVIAtBhgFBABC3gICAACAAKAIMIBMgAUH+
/wNqIgFqQRB0QRB1IhMgGCAMakEQdEEQdSIMQYQBQQQQt4CAgAAgACgCDCATIA9BhAFBBRC3gICAACAAKAIMIBggAWpBEHRBEHUi
GCAUQYQBQQAQt4CAgAAgACgCDCAaIAFqQRB0QRB1IhogFEGEAUEBELeAgIAAIAAoAgwgDSAMQYYBQQAQt4CAgAAgACgCDBC2gICA
ACADIAZBA3RqIgEoAgRFDQAgAUEEaiEJIAAoAgwgACgCEEH/gXxB/wEQtYCAgABBASEBA0ACQCAJKAIAIAFxRQ0AAkACQAJAAkAC
QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUH/H0oNAAJAIAFB/wBKDQAgAUF/ag5AAgMUBBQUFAUUFBQUFBQUBhQUFBQU
FBQUFBQUFBQUFAcUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUCBQLAkAgAUH/A0oNACABQYABRg0JIAFBgAJHDRQgAigC
ACANIA9BiwFBABC3gICAAAwUCyABQYAERg0JIAFBgAhGDQogAUGAEEcNEyACKAIAIBUgC0GJAUEAELeAgIAADBMLAkAgAUH//w9K
DQACQCABQf//AUoNACABQYAgRg0MIAFBgMAARg0NIAFBgIABRw0UIAIoAgAgGCAUQYUBQQAQt4CAgAAMFAsgAUGAgAJGDQ0gAUGA
gARGDQ4gAUGAgAhHDRMgAigCACAbIAtBiAFBABC3gICAAAwTCwJAIAFB////AEoNACABQYCAEEYNDyABQYCAIEYNECABQYCAwABH
DRMgAigCACAbIAtBiAFBBRC3gICAAAwTCwJAIAFB////A0oNACABQYCAgAFGDREgAUGAgIACRw0TIAIoAgAgFSALQYgBQQEQt4CA
gAAMEwsgAUGAgIAERg0RIAFBgICACEcNEiACKAIAIBUgC0GIAUEFELeAgIAADBILIAIoAgAgDiAQQYcBQQAQt4CAgAAMEQsgAigC
ACASIBRBhwFBABC3gICAAAwQCyACKAIAIBYgFEGHAUEAELeAgIAADA8LIAIoAgAgDiAXQYcBQQAQt4CAgAAMDgsgAigCACAZIApB
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
ELaAgIAACyABQRBqJICAgIAAC+EBAQN/QQAhBAJAIANBAEgNACACKAIsIANMDQAgAigCKCADQQJ0aigCACEFQQAhBANAIAUgBGoh
AiAEQQFqIgMhBCACLQAADQALAkADQAJAIANBAUcNAEEAIQQMAgsgBSADaiEEIANBf2oiAiEDIARBfmotAABBIUkNAAsgBSACaiED
QQAhBANAAkAgA0F/aiIGLQAAQSFPDQAgAyEFDAILIAYhAyACIARBAWoiBEcNAAsgAiEECyAEIAFKDQAgACAFIAQQwoCAgAAaCwJA
IAQgAU4NACAAIARqQQA6AAALIAQLtAQBBn8jgICAgABBEGsiAiSAgICAAEEAIQMCQAJAAkACQCABQQBIDQBBACEDIAAoAiwgAUwN
ACAAKAIoIAFBAnRqKAIAIQBBACEDA0AgACADaiEBIANBAWoiBCEDIAEtAAANAAsgBEF/aiEDA0ACQCADDQBBACEDDAILIAAgA2oh
ASADQX9qIgQhAyABQX9qLQAAQSFJDQALIAAgBGoiA0EBaiEFAkACQCADLQAAQSFPDQBBACEDDAELIARBAWohBkEAIQMgBSEBA0AC
QCAEIANHDQAgBiEDIAAhBQwCCyADQQFqIQMgAUF+aiEHIAFBf2oiBSEBIActAABBIEsNAAsLIANBEEoNASACIAUgAxDCgICAACEB
IANBEEcNAEEQIQMgAS0AACEADAILIAIgA2pBADoAAAtBACEBIANBb2pBcEkNASACKAIAIQACQCADQQRHDQBBASEBIABB9OTVqwZG
DQILIANBBUcNAEEFIQNBACEBIAJB+4uAgABBBRDEgICAAEUNAQsCQAJAIABB/wFxQS1GDQBBACEBIAIhAANAIANFDQMgA0F/aiED
IAFBCmwgACwAACIEakFQaiEBIABBAWohACAEQUZqQf8BcUH1AUsNAAwCCwsgA0F/aiEDIAJBAXIhAEEAIQEDQCADRQ0CIANBf2oh
AyABQQpsIAAsAAAiBGtBMGohASAAQQFqIQAgBEFGakH/AXFB9gFPDQALC0EAIQELIAJBEGokgICAgAAgAQubBQQGfwF8AX8BfCOA
gICAAEEQayICJICAgIAAQQAhAwJAAkACQAJAIAFBAEgNAEEAIQMgACgCLCABTA0AIAAoAiggAUECdGooAgAhBEEAIQEDQCAEIAFq
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
AiAAIAE2AlAMAQsgASgCCEUNAQJAAkACQAJAIAEoAgRBsf9jag4EAAECAwULIABByABqKAIAIABB1ABqKAIAIgFrIgIgAEHQAGoo
AgAiAyABaiIBIAEgAkobIgFBACABQQBKGyIBIANGDQQgACABNgJQDAMLIABByABqKAIAIABB1ABqKAIAIgFrIgIgAEHQAGooAgAi
AyABayIBIAEgAkobIgFBACABQQBKGyIBIANGDQMgACABNgJQDAILIABByABqKAIAIABB1ABqKAIAayIBIABB0ABqKAIAIgJBAWoi
AyADIAFKGyIBQQAgAUEAShsiASACRg0CIAAgATYCUAwBCyAAQcgAaigCACAAQdQAaigCAGsiASAAQdAAaigCACICQX9qIgMgAyAB
ShsiAUEAIAFBAEobIgEgAkYNASAAIAE2AlALIAAQgYGAgAALCzIBAX8CQCAAKAJEIgFFDQAgARDYgICAAAsCQCAAQdgAaigCACIA
RQ0AIAAQ2ICAgAALC5kBAQN/AkACQAJAIAQoAkgiBSAEKAJMIgZODQAgBCgCRCEGDAELQX8hBSAGQYACaiIHQf///z9LDQEgBCgC
RCAHQQR0ENmAgIAAIgZFDQEgBCAHNgJMIAQgBjYCRCAEKAJIIQULIAQgBUEBajYCSCAGIAVBBHRqIgQgAzYCDCAEIAI2AgggBCAB
NgIEIAQgADYCAEEAIQULIAULuhcBEX8jgICAgABBIGsiASSAgICAACAAQdwAaiICQQA2AgACQCAAQdQAaigCACIDIABByABqKAIA
IABB0ABqKAIAIgRrIgUgBSADShsiBkEBSA0AIABB2ABqIQcgAEHgAGohAyAAKAJEIARBBHRqIQhBBiEJA0AgBiEKAkACQAJAAkAg
CCgCACILQX9qIgBBBUsNACAAQQJ0QaCYgIAAaigCACIALQAAIgUNAUEMIQwMAwtBASEEAkAgC0EKSQ0AQQohAEEAIQUCQANAIAVB
AWohBSAAQZmz5swBSw0BIABBCmwiACALTQ0ACwtBICEEIAVBHksNACAFQQFqIQQLAkACQCAEQQFxDQAgBCEFIAshAAwBCyABIARB
f2oiBWogCyALQQpuIgBBCmxrQTByOgAACyAEQQFGDQEgBUEBaiEFA0AgASAFaiILQX1qIABBCm4iDUEKcEEwcjoAACALQX5qIAAg
DUEKbGtBMHI6AAAgAEHkAG4hACAFQX5qIgVBAUsNAAwCCwsgAEEBaiENQQAhAANAIAEgAGogBToAACAAQQFqIQQgDSAAai0AACIF
RQ0BIABBH0khCyAEIQAgCw0ACwsgBEEDdCEMQQAhBSABIQADQCAALQAAIQsCQAJAAkAgAigCACIEIAMoAgAiDU4NACAHKAIAIQ0M
AQsgDUGAAWoiBEHVqtWqAUsNASAHKAIAIARBBmwQ2YCAgAAiDUUNASADIAQ2AgAgByANNgIAIAIoAgAhBAsgAiAEQQFqNgIAIA0g
BEEGbGoiBEEAOgAFIAQgCzoABCAEIAk7AQIgBCAFQQxqOwEACyAAQQFqIQAgDCAFQQhqIgVHDQALIAVBDGohDAsCQAJAAkAgAigC
ACIAIAMoAgAiBU4NACAHKAIAIQUMAQsgBUGAAWoiAEHVqtWqAUsNASAHKAIAIABBBmwQ2YCAgAAiBUUNASADIAA2AgAgByAFNgIA
IAIoAgAhAAsgAiAAQQFqNgIAIAUgAEEGbGoiAEE6OwEEIAAgCTsBAiAAIAw7AQALAkACQCAIKAIEIgVBgAhIDQBBCiEEQQAhC0ED
IQ0CQANAIA0hACALQQFqIQsgBEGZs+bMAUsNASAAQQFqIQ0gBEEKbCIEIAVNDQALCyALQQFqIQ0DQCABIABqQX5qIAUgBUEKbiIE
QQpsa0EwcjoAACAEIQUgAEF/aiIAQQFLDQAMAgsLAkACQCAFDQAgAUGt2gA7AQAMAQsgASAFQR9xQYCIgIAAai0AADoAASABIAVB
BXVBgIiAgABqLQAAOgAAC0ECIQ0LIApBf2ohBiAMQSBqIQsgDEEQaiEEIAEhBQNAIAshACAFLQAAIQwCQAJAAkAgAigCACILIAMo
AgAiDk4NACAHKAIAIQ4MAQsgDkGAAWoiC0HVqtWqAUsNASAHKAIAIAtBBmwQ2YCAgAAiDkUNASADIAs2AgAgByAONgIAIAIoAgAh
CwsgAiALQQFqNgIAIA4gC0EGbGoiC0EAOgAFIAsgDDoABCALIAk7AQIgCyAEQXhqOwEACyAAQQhqIQsgBUEBaiEFIARBCGohBCAN
QX9qIg0NAAsCQAJAAkAgAigCACIFIAMoAgAiC04NACAHKAIAIQsMAQsgC0GAAWoiBUHVqtWqAUsNASAHKAIAIAVBBmwQ2YCAgAAi
C0UNASADIAU2AgAgByALNgIAIAIoAgAhBQsgAiAFQQFqNgIAIAsgBUEGbGoiBUE6OwEEIAUgCTsBAiAFIARBeGo7AQALQQEhCwJA
IAgoAggiDUEKSQ0AQQohBUEAIQQCQANAIARBAWohBCAFQZmz5swBSw0BIAVBCmwiBSANTQ0ACwtBICELIARBHksNACAEQQFqIQsL
AkACQCALQQFxDQAgCyEEIA0hBQwBCyABIAtBf2oiBGogDSANQQpuIgVBCmxrQTByOgAACwJAIAtBAUYNACAEQQFqIQQDQCABIARq
Ig1BfWogBUEKbiIMQQpwQTByOgAAIA1BfmogBSAMQQpsa0EwcjoAACAFQeQAbiEFIARBfmoiBEEBSw0ACwsgASEFA0AgBS0AACEN
AkACQAJAIAIoAgAiBCADKAIAIgxODQAgBygCACEMDAELIAxBgAFqIgRB1arVqgFLDQEgBygCACAEQQZsENmAgIAAIgxFDQEgAyAE
NgIAIAcgDDYCACACKAIAIQQLIAIgBEEBajYCACAMIARBBmxqIgRBADoABSAEIA06AAQgBCAJOwECIAQgAEF4ajsBAAsgAEEIaiEA
IAVBAWohBSALQX9qIgsNAAsgAEFwakHxAEshBAJAAkACQCAIKAIMIgVBACAFQQBKGyIFQYGAgIAESQ0AIAFBIDoAAEEBIQVBxwAh
CwwBCwJAAkAgBUGBgMAASQ0AIAVBFHYhDUHNACELDAELIAVBCnYgBSAFQYAISyILGyENQesAQSAgCxshCwtB5wchBQJAAkACQCAN
QeYHSw0AIA1B5ABJDQEgDSEFCyABIAVB//8DcUHkAG5B/wFxQQpwQTByIg86AAAMAQsgAUEgOgAAAkAgDUEKTw0AIA0hBQwCC0Eg
IQ8gDSEFCyABIAVB//8DcUEKbkH/AXFBCnBBMHIiDjoAAQwBC0EgIQ4gAUEgOgABQSAhDwsgAEGCASAEGyEEIAFBwgA6AAUgASAL
OgAEIAFBIDoAAyABIAVB//8DcUEKcEEwciIMOgACAkACQAJAIAIoAgAiACADKAIAIgVODQAgBygCACEQIAAhDQwBCyAFQYABaiIR
QdWq1aoBSw0BAkAgBygCACARQQZsENmAgIAAIhANACADKAIAIQUgAigCACEADAILIAMgETYCACAHIBA2AgAgAigCACENIBEhBQsg
AiANQQFqIgA2AgAgECANQQZsaiINQQA6AAUgDSAPOgAEIA0gCTsBAiANIAQ7AQALAkACQAJAIAAgBUgNACAFQYABaiIQQdWq1aoB
Sw0CAkAgBygCACAQQQZsENmAgIAAIg8NACADKAIAIQUgAigCACEADAMLIAMgEDYCACAHIA82AgAgAigCACENIBAhBQwBCyAHKAIA
IQ8gACENCyACIA1BAWoiADYCACAPIA1BBmxqIg1BADoABSANIA46AAQgDSAJOwECIA0gBEEIajsBAAsCQAJAAkAgACAFSA0AIAVB
gAFqIg9B1arVqgFLDQICQCAHKAIAIA9BBmwQ2YCAgAAiDg0AIAMoAgAhBSACKAIAIQAMAwsgAyAPNgIAIAcgDjYCACACKAIAIQ0g
DyEFDAELIAcoAgAhDiAAIQ0LIAIgDUEBaiIANgIAIA4gDUEGbGoiDUEAOgAFIA0gDDoABCANIAk7AQIgDSAEQRBqOwEACwJAAkAC
QCAAIAVIDQAgBUGAAWoiDkHVqtWqAUsNAgJAIAcoAgAgDkEGbBDZgICAACIMDQAgAygCACEFIAIoAgAhAAwDCyADIA42AgAgByAM
NgIAIAIoAgAhDSAOIQUMAQsgBygCACEMIAAhDQsgAiANQQFqIgA2AgAgDCANQQZsaiINQSA7AQQgDSAJOwECIA0gBEEYajsBAAsC
QAJAAkAgACAFSA0AIAVBgAFqIg5B1arVqgFLDQICQCAHKAIAIA5BBmwQ2YCAgAAiDA0AIAMoAgAhBSACKAIAIQAMAwsgAyAONgIA
IAcgDDYCACACKAIAIQ0gDiEFDAELIAcoAgAhDCAAIQ0LIAIgDUEBaiIANgIAIAwgDUEGbGoiDUEAOgAFIA0gCzoABCANIAk7AQIg
DSAEQSBqOwEACwJAAkACQCAAIAVIDQAgBUGAAWoiAEHVqtWqAUsNAiAHKAIAIABBBmwQ2YCAgAAiBUUNAiADIAA2AgAgByAFNgIA
IAIoAgAhAAwBCyAHKAIAIQULIAIgAEEBajYCACAFIABBBmxqIgBBwgA7AQQgACAJOwECIAAgBEEoajsBAAsgCUEIaiEJIAhBEGoh
CCAKQQFKDQALCyABQSBqJICAgIAAC1MAAkBB2AAgABDrgICAACIARQ0AIABBj4CAgAA2AiQgAEGQgICAADYCICAAQZGAgIAANgIc
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
QQBKDQILQX8hAgsgACAHIAJBAWoiAmsiBTYCSCAJIAkgAmogBRDDgICAABogACgCSCEHCwJAAkACQCAHIARqIgIgAEHMAGooAgBO
DQAgACgCRCECDAELIAJB//8BSg0BIAAoAkQgAkGBCGpBgHhxIgUQ2YCAgAAiAkUNASAAIAU2AkwgACACNgJEIAAoAkghBwsgAiAH
aiADIAQQwoCAgAAaIAAgACgCSCICIARqQQFqNgJIIAIgACgCRGogBGpBCjoAACAAQdwAakEBNgIACyADQZACaiSAgICAAAt2AAJA
QcQAIAAQ64CAgAAiAEUNACAAQZyAgIAANgI8IABBlICAgAA2AiQgAEGVgICAADYCICAAQZaAgIAANgIcIABB0ImAgABBDhDvgICA
ABogAEHKjICAAEETEO+AgIAAGiAAQeSMgIAAQQsQ74CAgAAaCyAACzYAAkACQAJAAkAgACgCNA4DAAECAwsgABD7gICAABoPCyAA
ELGBgIAAGg8LIAAQpYGAgAAaCwtjAAJAQcwAIAAQ64CAgAAiAEUNACAAQZ2AgIAANgIkIABBnoCAgAA2AiAgAEGfgICAADYCHCAA
QaCAgIAANgIYQd+JgIAAQe2UgIAAQQEQmYCAgABBAEobQQAQjICAgAALIAAL5gIBB38jgICAgABBwABrIgEkgICAgAAgACgCREHQ
AG8hAgJAIABByABqKAIAQdAAbyIDQbB/aiADIANBAEobIgQgACgCCCIDTg0AIAJBsH9qIAIgAkEAShsiBSAAKAIEIgZODQADQAJA
IAUgBk4NACAEQShqIQIgBEHQAGohByAFIQMDQCABQQA2AjQgASAEOwEyIAEgAzsBMCABQf///4d8NgIsIAEgAjsBKiABQQA2AiQg
ASAEOwEiIAFBADYCHCABIAc7ARogAUH///+HfDYCFCABIAI7ARIgAUEANgIMIAEgBzsBCiABIAM7AQggAUEANgIEIAEgBDsBAiAB
IAM7AQAgASADQShqIgY7ASggASADQdAAaiIDOwEgIAEgAzsBGCABIAY7ARBBASABQQcQkICAgAAgAyAAKAIEIgZIDQALIAAoAggh
AwsgBEHQAGoiBCADSA0ACwsgAUHAAGokgICAgAALAgALVwACQAJAAkAgASgCAEF8ag4CAAECCyAAIAAoAkQgASgCBGs2AkQgAEHI
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
ACgCACAFIANB////BxCvgICAABogBCAAKAIAEKmAgIAAIAQoAghqNgIIC0EAIQYLIAVBgAJqJICAgIAAIAYLhwEAAkBBxAAgABDr
gICAACIARQ0AIABBuICAgAA2AjwgAEGUgICAADYCJCAAQZWAgIAANgIgIABBloCAgAA2AhwgAEG0iYCAAEF/EO+AgIAAGiAAQamJ
gIAAQX8Q74CAgAAaIABBv4mAgABBfxDvgICAABogAEGMioCAAEF/EO+AgIAAGgsgAAtEAAJAAkACQAJAAkAgACgCNA4EAAECAwQL
IAAQ3oCAgAAaDwsgABDogICAABoPCyAAEIKBgIAAGg8LIAAQqIGAgAAaCwtDAAJAQfAAIAAQ64CAgAAiAEUNACAAQbmAgIAANgIk
IABBuoCAgAA2AiAgAEG7gICAADYCHCAAQbyAgIAANgIYCyAAC8ENAQR/I4CAgIAAQYABayIBJICAgIAAAkAgACgCDCICRQ0AIAIg
ACgCEEF/Qf8BELWAgIAAIAFBIDoAAiABQdj0ADsBAEEDIQICQCAAKAJEIgNBf0oNACABQS06AANBACADayEDQQQhAgtBPyEEAkAg
A0GPzgBLDQACQAJAAkACQAJAIANB6AdJDQAgASACciADQf//A3FB6AduQQpwQTByOgAAIAJBAWohAgwBCyADQeQASQ0BCyABIAJy
IANB//8DcUHkAG5B/wFxQQpwQTByOgAAIAJBAWohAgwBCyADQQpJDQELIAEgAmogA0H//wNxQQpuQQpwQTByOgAAIAJBAWohAgsg
A0H//wNxQQpwQTByIQQLIAEgAmogBDoAACAAKAIMQShBKCABIAJBAWoQuICAgAAgAUEgOgACIAFB2fQAOwEAQQMhAgJAIABByABq
KAIAIgNBf0oNACABQS06AANBACADayEDQQQhAgtBPyEEAkAgA0GPzgBLDQACQAJAAkACQAJAIANB6AdJDQAgASACciADQf//A3FB
6AduQQpwQTByOgAAIAJBAWohAgwBCyADQeQASQ0BCyABIAJyIANB//8DcUHkAG5B/wFxQQpwQTByOgAAIAJBAWohAgwBCyADQQpJ
DQELIAEgAmogA0H//wNxQQpuQQpwQTByOgAAIAJBAWohAgsgA0H//wNxQQpwQTByIQQLIAEgAmogBDoAACAAKAIMQShBMCABIAJB
AWoQuICAgAAgAUEgOgACIAFB+PQAOwEAQQMhAgJAIABBzABqKAIAIgNBf0oNACABQS06AANBACADayEDQQQhAgtBPyEEAkAgA0GP
zgBLDQACQAJAAkACQAJAIANB6AdJDQAgASACciADQf//A3FB6AduQQpwQTByOgAAIAJBAWohAgwBCyADQeQASQ0BCyABIAJyIANB
//8DcUHkAG5B/wFxQQpwQTByOgAAIAJBAWohAgwBCyADQQpJDQELIAEgAmogA0H//wNxQQpuQQpwQTByOgAAIAJBAWohAgsgA0H/
/wNxQQpwQTByIQQLIAEgAmogBDoAACAAKAIMQShBOCABIAJBAWoQuICAgAAgAUEgOgACIAFB+fQAOwEAQQMhAgJAIABB0ABqKAIA
IgNBf0oNACABQS06AANBACADayEDQQQhAgtBPyEEAkAgA0GPzgBLDQACQAJAAkACQAJAIANB6AdJDQAgASACciADQf//A3FB6Adu
QQpwQTByOgAAIAJBAWohAgwBCyADQeQASQ0BCyABIAJyIANB//8DcUHkAG5B/wFxQQpwQTByOgAAIAJBAWohAgwBCyADQQpJDQEL
IAEgAmogA0H//wNxQQpuQQpwQTByOgAAIAJBAWohAgsgA0H//wNxQQpwQTByIQQLIAEgAmogBDoAACAAKAIMQShBwAAgASACQQFq
ELiAgIAAAkAgAEHoAGotAAAiA0UNAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADQQFxRQ0AIAFB0gA6AAQgAUHPqKGq
BDYCAEEFIQIgA0ECcUUNAiABQSw6AAVBBiECDAELQQAhAiADQQJxDQBBACECIANBBHENAkEAIQIgA0EIcQ0EQQAhAiADQRBxDQZB
ACECIANBIHENCEEAIQIgA0HAAHENCkEAIQIgA0GAAXENDAwNCyACIAFyIgRBzAA6AAAgBEEBckHlADoAACAEQQJqQeboATsBACAC
QQRqIQILIANBBHFFDQEgASACckEsOgAAIAJBAWohAgsgASACaiIEQdLSncMGNgAAIARBBGpB9AA6AAAgAkEFaiECCyADQQhxRQ0B
AkAgAg0AQQAhAgwBCyABIAJqQSw6AAAgAkEBaiECCyABIAJqIgRBzdKRowY2AAAgBEEEakHsygE7AAAgAkEGaiECCyADQRBxRQ0B
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
AAsLwBABAEGACAu4EDAxMjM0NWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6ADAxMjM0NWFiY2RlZmdoaWprbG1ub3BxcnN0dXd4
eXoALi4uZW1wdHkAICBOZXcgZGV2aWNlICVkOiAleDoleDoleABJbnB1dAAuLi5lbmQgb2YgbGlzdABMaXN0ACEhISB0b3VjaGlk
ICVkIGFscmVhZHkgZXhpc3RzACAgJWQgYnV0dG9ucwBUcmFuc2Zvcm1zAFByaW1pdGl2ZXMAVG9vIE1hbnkgU3ByaXRlcwBMaXN0
IFJlc291cmNlcwBsb2NrZWQgY3Vyc29yAE5vIGFjY2VsZXJvbWV0ZXIAQWNjZWxlcm9tZXRlcgBJbnRlcm1lZGlhdGUgRnJhbWVi
dWZmZXIAcmVncmVzc2lvbl8yMDI0MDYwOV9sb2dfcGN0X3AAQXVkaW8AVmlkZW8AUmVncmVzc2lvbgB3YXNtACEhISBVbmFibGUg
dG8gcmVjb3JkIGtleWJvYXJkIGV2ZW50ICV4PSVkLCBidWZmZXIgZnVsbABEZWNhbABNb3VzZSBMb2NrAFJhdyBKb3lzdGljawBU
b3VjaABzb25nAHN0cmluZwAwMTIzNDU2Nzg5YWJjZGVmACAgUmVwZWF0OiB0cnVlAFdyaXRlAE1vdXNlACAgRm9yY2U6IGZhbHNl
AFN0b3JlAFJlYWwgdGltZQBHYW1lIHRpbWUAVGlsZQBFR0dfRVZFTlRfVE9VQ0ggZmFpbGVkIHRvIGVuYWJsZQBsYW5ndWFnZQBT
dHJpbmdzIGJ5IExhbmd1YWdlAGltYWdlAFBlcnNpc3RlbmNlAFJlZmVyZW5jZQBUT0RPOiBtZW51X2tleWJvYXJkAEtleWJvYXJk
AHNvdW5kAFJlYWQALi4udG9vIGJpZyEgJWQ+JWQAZGV2aWQ9JWQgYnRuaWQ9JVggdmFsdWU9JWQAbWFsbG9jOiBsaW1pdD0lZCB3
YXRlcmxpbmU9JWQgYWxsb2NhdGVkPSVkACVkICVwICVkACEhISBJbnZhbGlkIHRvdWNoIHN0YXJ0IGV2ZW50IGZvciB0b3VjaGlk
ICVkACEhISBVbmV4cGVjdGVkIHRvdWNoIGZpbmlzaCBldmVudCBmb3IgdG91Y2hpZCAlZAAhISEgVW5leHBlY3RlZCB0b3VjaCBt
b3ZlIGV2ZW50IGZvciB0b3VjaGlkICVkACEhISBVbmV4cGVjdGVkIHN0YXRlICVkIGZvciBldmVudCBvbiB0b3VjaGlkICVkACVk
ICVkICVwICVkICVkAE1pc2MAbWV0YWRhdGEAbXlTdG9yZWREYXRhAEpPWQBLRVkAVEVYVABNQlVUVE9OAE1NT1RJT04ATVdIRUVM
AFRPVUNIAElkZW50aWNhbD8AVGludDoATGFuZ3M6AEFscGhhOgBUaGlzIG11c3QgcHJpbnQgJzEyMyAoKHNvbWUgYWRkcmVzcykp
IDQ1Nic6AFRoaXMgbXVzdCBwcmludCAnMTIzIDQ1NiAoKHNvbWUgYWRkcmVzcykpIDc4OSAxMTEnOgAgIFRyaW06IDk5ACEhISBG
YWlsZWQgdG8gbG9hZCBpbWFnZTowOjgATW9kZTcARm9yY2UgUGxheWhlYWQgdG8gMS4wAFBsYXkgU29uZyAwAFBsYXkgU291bmQg
MAAgIFBhbjogMABGYWlsZWQgdG8gZW5hYmxlICVzIGV2ZW50cy4AV2F0Y2ggbG9nIGZvciByZXN1bHRzLgAhISEgRmFpbGVkIHRv
IGFkZCB0b3VjaCAlZC4gRXhwZWN0IGZ1cnRoZXIgZXJyb3JzLgBKb3kgb3IgUS4uUCB0byBwbGF5IG5vdGVzLgBFc2MsIG1vdXNl
LCBvciAxMCBzIGlkbGUgdG8gcmV0dXJuLgBtZW51X3JhdyBjbG9zaW5nIGR1ZSB0byAlZiBzIGlkbGUuAEwvUiB0byBjaGFuZ2Uu
AExpc3Rpbmcgc3RvcmFnZSBrZXlzLi4uAFJlYWRpbmcgJ215U3RvcmVkRGF0YScgZnJvbSBzdG9yYWdlLi4uAC4uLiclLipzJwBX
cml0aW5nIHN0b3JhZ2UgJ215U3RvcmVkRGF0YScgPSAnJS4qcycAICAnJS4qcycAICAiJXMiAFRvbyBtYW55IQAuLi5zdWNjZXNz
IQBOb25lIQBlZ2dfbG9ja19jdXJzb3IgZmFpbGVkIQBJbml0aWFsaXplIHRleHR1cmUgZmFpbGVkIQAuLi5GQUlMVVJFIQAhISEg
bWVudV9yYXcgcmVxdWlyZXMgYSBmb250IG9yIHRpbGVzaGVldCAhISEAAAAAAAAAAAAAAAAAAABmcy04UsHgPxgtRFT7Ifk/ZnMt
OFLB8D8AAAAAAAAAAAAAAAAAAACAAAAAAIAAAAD/AAAAgAAA//8AAP+A/wAA//8AAID/////////AAAAAAAAAAAAAAAAAAAAAEAA
AACAAAAAwAAAAP8AAAAAAAAAAAAAAAAAAAAyAAoA/////1oACgD/////RgAUAAAAAP9aAB4A/wAA/0YAKAD/AAAAAAAAAAAAAABk
AAoA/////8gACgD/AAD/eAAoAAD/AP/IACgAAAD/AGQAPAAUAAAAAAAAAAAAAAAUAC0AFgAoAC0AFwA8AC0AGABQAC0AGQBkAC0A
GgB4AC0AGwCMAC0AHACgAC0AHQAUAEsAFgAoAEsAFgE8AEsAFgJQAEsAFgNkAEsAFgR4AEsAFgWMAEsAFgagAEsAFgfUBwAAWgUA
AL8FAABeBgAAugUAAJcGAAAA3xwEbmFtZQG3HNMBABRlZ2dfaW1hZ2VfZ2V0X2hlYWRlcgEQZWdnX2ltYWdlX2RlY29kZQISZWdn
X3RleHR1cmVfdXBsb2FkAw9lZ2dfdGV4dHVyZV9uZXcED2VnZ190ZXh0dXJlX2RlbAUWZWdnX3RleHR1cmVfZ2V0X2hlYWRlcgYP
ZWdnX3JlbmRlcl90aW50BxBlZ2dfcmVuZGVyX2FscGhhCA1lZ2dfZHJhd190aWxlCRBlZ2dfcmVzX2Zvcl9lYWNoChZlZ2dfZ2V0
X3VzZXJfbGFuZ3VhZ2VzCwtlZ2dfcmVzX2dldAwHZWdnX2xvZw0NZWdnX3RpbWVfcmVhbA4NZWdnX2RyYXdfcmVjdA8NZWdnX2Ry
YXdfbGluZRANZWdnX2RyYXdfdHJpZxEOZWdnX2RyYXdfZGVjYWwSFGVnZ19kcmF3X2RlY2FsX21vZGU3ExtlZ2dfam95c3RpY2tf
ZGV2aWRfYnlfaW5kZXgUFGVnZ19hdWRpb19wbGF5X3NvdW5kFRBlZ2dfZXZlbnRfZW5hYmxlFhRlZ2dfam95c3RpY2tfZ2V0X2lk
cxccZWdnX2pveXN0aWNrX2Zvcl9lYWNoX2J1dHRvbhgVZWdnX2pveXN0aWNrX2dldF9uYW1lGQ9lZ2dfbG9ja19jdXJzb3IaDmVn
Z190aW1lX2xvY2FsGxZlZ2dfdGV4dHVyZV9sb2FkX2ltYWdlHA1lZ2dfc3RvcmVfZ2V0HQ1lZ2dfc3RvcmVfc2V0HhZlZ2dfc3Rv
cmVfa2V5X2J5X2luZGV4Hw9lZ2dfYXVkaW9fZXZlbnQgFmVnZ19hdWRpb19nZXRfcGxheWhlYWQhE2VnZ19hdWRpb19wbGF5X3Nv
bmciFmVnZ19hdWRpb19zZXRfcGxheWhlYWQjF2VnZ19yZXF1ZXN0X3Rlcm1pbmF0aW9uJA1lZ2dfZXZlbnRfZ2V0JRFfX3dhc21f
Y2FsbF9jdG9ycyYIZm9udF9kZWwnCGZvbnRfbmV3KA1mb250X2FkZF9wYWdlKQ1mb250X2dldF9yb3doKhFmb250X2NvdW50X2ds
eXBocysQZm9udF9jb3VudF9wYWdlcywWZm9udF9yZW5kZXJfdG9fdGV4dHVyZS0QZm9udF9icmVha19saW5lcy4MZm9udF9tZWFz
dXJlLxdmb250X3JlbmRlcl9zdHJpbmdfcmdiYTAXZm9udF9yZW5kZXJfbmV3X3RleHR1cmUxEmZvbnRfbWVhc3VyZV9nbHlwaDIV
Zm9udF9yZW5kZXJfc3RyaW5nX2ExMxVmb250X3JlbmRlcl9jaGFyX3JnYmE0E2ZvbnRfcmVuZGVyX2NoYXJfYTE1E3RpbGVfcmVu
ZGVyZXJfYmVnaW42EXRpbGVfcmVuZGVyZXJfZW5kNxJ0aWxlX3JlbmRlcmVyX3RpbGU4FHRpbGVfcmVuZGVyZXJfc3RyaW5nORB0
ZXh0X3V0ZjhfZGVjb2RlOhB0ZXh0X3V0ZjhfZW5jb2RlOwl0ZXh0X2luaXQ8D3RleHRfY2JfZm9yX3Jlcz0RdGV4dF9nZXRfbWV0
YWRhdGE+D3RleHRfZ2V0X3N0cmluZz8WdGV4dF9mb3JfZWFjaF9sYW5ndWFnZUARdGV4dF9nZXRfbGFuZ3VhZ2VBEXRleHRfc2V0
X2xhbmd1YWdlQgZtZW1jcHlDB21lbW1vdmVEBm1lbWNtcEUHc3RybmNtcEYGc3RyZHVwRwZtZW1zZXRIBGZhYnNJA3NpbkoDY29z
SwVhdGFuMkwFZnJleHBNBHBvd2ZOBGZtb2RPA2xvZ1ADZXhwUQRtb2RmUgVsZGV4cFMFbG9nMTBUBHNxcnRVCmZwY2xhc3NpZnlW
EG1hbGxvY19sb2dfc3RhdHNXBm1hbGxvY1gEZnJlZVkHcmVhbGxvY1oGY2FsbG9jWwRyYW5kXAVzcmFuZF0Kc3JhbmRfYXV0b14T
bWVudV9uZXdfcHJpbWl0aXZlc18SX3ByaW1pdGl2ZXNfcmVuZGVyYBJfcHJpbWl0aXZlc191cGRhdGVhEV9wcmltaXRpdmVzX2V2
ZW50YhFwcmltaXRpdmVzX21vdGlvbmMRbWVudV9uZXdfam95c3RpY2tkEF9qb3lzdGlja19yZW5kZXJlEF9qb3lzdGlja191cGRh
dGVmD19qb3lzdGlja19ldmVudGcNX2pveXN0aWNrX2RlbGgTbWVudV9uZXdfdHJhbnNmb3Jtc2kSX3RyYW5zZm9ybXNfcmVuZGVy
aghtZW51X2RlbGsIbWVudV9uZXdsCm1lbnVfZXZlbnRtC21lbnVfdXBkYXRlbgttZW51X3JlbmRlcm8PbWVudV9vcHRpb25fYWRk
cBFtZW51X29wdGlvbl9ldmVudHESbWVudV9vcHRpb25fbW90aW9uchRtZW51X29wdGlvbl9hY3RpdmF0ZXMSbWVudV9vcHRpb25f
dXBkYXRldBJtZW51X29wdGlvbl9yZW5kZXJ1HG1lbnVfb3B0aW9uX3JlYWRfdGFpbF9zdHJpbmd2GW1lbnVfb3B0aW9uX3JlYWRf
dGFpbF9pbnR3HG1lbnVfb3B0aW9uX3JlYWRfdGFpbF9kb3VibGV4H21lbnVfb3B0aW9uX3Jld3JpdGVfdGFpbF9zdHJpbmd5HG1l
bnVfb3B0aW9uX3Jld3JpdGVfdGFpbF9pbnR6H21lbnVfb3B0aW9uX3Jld3JpdGVfdGFpbF9kb3VibGV7EG1lbnVfbmV3X2xpc3Ry
ZXN8D19saXN0cmVzX3JlbmRlcn0PX2xpc3RyZXNfdXBkYXRlfg5fbGlzdHJlc19ldmVudH8MX2xpc3RyZXNfZGVsgAEPbGlzdHJl
c19hZGRfcmVzgQEVbGlzdHJlc19yZWJ1aWxkX3RpbGVzggEQbWVudV9uZXdfc3ByaXRlc4MBD19zcHJpdGVzX3JlbmRlcoQBD19z
cHJpdGVzX3VwZGF0ZYUBDl9zcHJpdGVzX2V2ZW50hgEMX3Nwcml0ZXNfZGVshwERc3ByaXRlc19zZXRfY291bnSIAQ1tZW51X25l
d19tYWluiQEMX21haW5fb3B0aW9uigEMbWVudV9uZXdfcmF3iwELX3Jhd19yZW5kZXKMAQtfcmF3X3VwZGF0ZY0BCl9yYXdfZXZl
bnSOAQhfcmF3X2RlbI8BFHJhd19jYl9jb3VudF9idXR0b25zkAEKcmF3X2FwcGVuZJEBDm1lbnVfbmV3X3N0b3JlkgENX3N0b3Jl
X29wdGlvbpMBEm1lbnVfbmV3X21vdXNlbG9ja5QBEV9tb3VzZWxvY2tfcmVuZGVylQERX21vdXNlbG9ja191cGRhdGWWARBfbW91
c2Vsb2NrX2V2ZW50lwEOX21vdXNlbG9ja19kZWyYAQ1tZW51X25ld19taXNjmQEMX21pc2NfcmVuZGVymgEObWlzY19yZXByX3Rp
bWWbARFtZW51X25ld19rZXlib2FyZJwBEF9rZXlib2FyZF9yZW5kZXKdARBfa2V5Ym9hcmRfdXBkYXRlngEPX2tleWJvYXJkX2V2
ZW50nwENX2tleWJvYXJkX2RlbKABDm1lbnVfbmV3X3RvdWNooQENX3RvdWNoX3JlbmRlcqIBDV90b3VjaF91cGRhdGWjAQxfdG91
Y2hfZXZlbnSkAQpfdG91Y2hfZGVspQEUbWVudV9uZXdfcGVyc2lzdGVuY2WmARNfcGVyc2lzdGVuY2Vfb3B0aW9upwETX3BlcnNp
c3RlbmNlX3JlbmRlcqgBFG1lbnVfbmV3X2ZyYW1lYnVmZmVyqQETX2ZyYW1lYnVmZmVyX3JlbmRlcqoBE19mcmFtZWJ1ZmZlcl91
cGRhdGWrARBfZnJhbWVidWZmZXJfZGVsrAEWZnJhbWVidWZmZXJfZHJhd19zY2VuZa0BE21lbnVfbmV3X3JlZ3Jlc3Npb26uARJf
cmVncmVzc2lvbl9vcHRpb26vARJfcmVncmVzc2lvbl9yZW5kZXKwARJfcmVncmVzc2lvbl91cGRhdGWxARBtZW51X25ld19zdHJp
bmdzsgEPX3N0cmluZ3NfcmVuZGVyswEPX3N0cmluZ3NfdXBkYXRltAEOX3N0cmluZ3NfZXZlbnS1AQxfc3RyaW5nc19kZWy2AQ5z
dHJpbmdzX2NiX3Jlc7cBD3N0cmluZ3NfY2JfZHJhd7gBDm1lbnVfbmV3X3ZpZGVvuQENX3ZpZGVvX29wdGlvbroBDm1lbnVfbmV3
X21vdXNluwENX21vdXNlX3JlbmRlcrwBDV9tb3VzZV91cGRhdGW9AQxfbW91c2VfZXZlbnS+AQpfbW91c2VfZGVsvwEObWVudV9u
ZXdfYXVkaW/AAQ1fYXVkaW9fYWRqdXN0wQENX2F1ZGlvX29wdGlvbsIBDV9hdWRpb19yZW5kZXLDAQxfYXVkaW9fZXZlbnTEAQpf
YXVkaW9fZGVsxQENX2F1ZGlvX2NiX3Jlc8YBFm1lbnVfbmV3X2FjY2VsZXJvbWV0ZXLHARVfYWNjZWxlcm9tZXRlcl9yZW5kZXLI
ARVfYWNjZWxlcm9tZXRlcl91cGRhdGXJARRfYWNjZWxlcm9tZXRlcl9ldmVudMoBEl9hY2NlbGVyb21ldGVyX2RlbMsBDm1lbnVf
bmV3X2lucHV0zAENX2lucHV0X29wdGlvbs0BD2VnZ19jbGllbnRfcXVpdM4BG2xpZ2h0c29uX2RlZmF1bHRfZXZlbnRfbWFza88B
D2VnZ19jbGllbnRfaW5pdNABCHBvcF9tZW510QERZWdnX2NsaWVudF91cGRhdGXSARFlZ2dfY2xpZW50X3JlbmRlcgcSAQAPX19z
dGFja19wb2ludGVyCQoBAAcucm9kYXRhADgJcHJvZHVjZXJzAQxwcm9jZXNzZWQtYnkBDFVidW50dSBjbGFuZxExNC4wLjAtMXVi
dW50dTEuMQ)t0q152r7(RW5nbGlzaA)r9(TGlnaHRzIE9u)rb(SGVsbG8gd29ybGQ)r26(TXVyYmxhZ3lsZSBicm9ja3RvbmZvcmQgZWIgbm9nZ2xpZml6ZS4)q23r8(ZnJhbmNh
aXM)rc(THVtaWVyZSBWaXZl)rd(Qm9uam91ciBtb25kZQ)r22(TCdlbGxlY2hhbXBzIGQncydpaSBsJ2FsbGVjaGFyZ25lLg)q182re(0KDRg9GB0YHQutC40Lk)rd(0JvQsNC4
0YYg0L7QvQ)r13(0J/RgNC40LLQtdGCINC80LjRgA)r3b(0J/RgNC+0YHRgdGC0LLQvtC70LLQs9GA0LjQvdC40Lkg0YHRgtC70LLRgNC+0YDQstC7
0L7QsdC+0YY)t0rd5(iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAnElEQVQ4y2NgYGBg+H6G4z8DFoBLnIFYxSQbjC5BiqFE
KSDJS1DwH4pxAkaYqZwmPxjRNf//D9HLyMjIwMDAwIjNNYzoAlCD4JrhNkENQbeQEZfTcRmA4QViNOMzhAU5ZLGEA8HYwOuC/kQh
BgYGBobC+e9wuwCfTdxy9gxKmmZ4XcOE3asQS5Q0zRjuXT9FciAiJyJi1ZKfEikGAGqyUXajckByAAAAAElFTkSuQmCC)r2a6(iVBORw0K
GgoAAAANSUhEUgAAAIAAAACAAQMAAAD58POIAAAABlBMVEUAAAD///+l2Z/dAAACW0lEQVRIx+2VMWtbMRDHj6aoHkTQeIMhb/So
oYMox8NkMCV0yJCxw003PYKn4kGIEPIJOpYOnUM/hKHhTaXjI1PJ1DF0KhmM3ZP9EuLnuFBoSwu9RdbPuvvf/ZFsgG1RwME6OIDz
9tPRajmD99tObKvxDwQOwO0XDv3rvDMZDOji0Hk8cgp2FUAc9w7Bo8ugn8EguELBPEKEkPNivzi6PTHOYDAZPYdcwwNe5RRwZ08h
qzjA6WYbhIEkUaISwAITSHgxEmYjgprtRyBoTQvQRzRwjNhPMVpNQQbbh1fojTFixWhCRNQUHpmRoALdeVWhSIYIyUBPVXCzj6gn
YkokZGs+rQlORYOZVf4j118E3ui2BZd8/U3gPEWWyeQ4of3K87nA29UJbbS65OazwMmqRgZa45NAkqzCpVCoU60qD/VRJqnrWlKY
BrU1V0AFlRh/heEONEGsH2OlKVoUpZo7Qh+wBuBqYhRcB/S+n2fl40pBqCtkv7sEzyQiudMaUzAB5pt9eGC9FNkrO13ahZQBKoaL
JbAmUqmWRjUIZ1FnKXV8IZ3W3mCTJLfKqlNmx7CRFjCa7McKlKsagqG2jdCWq9oueqfWgHdY6PjlSyI1SCQpGGeRpAZdNySWnW2W
jmWDGhTUE/2cwtmPOZVeQU/9MEyWnHqcVipsbu/nj97QrPv1SdwnD8MOwHctebJYrIObTspOt+jjrmTvIbA3uwfyUywe7c2oC4Z0
H6iJd6Bo16HvAuiAuxj+DnDyZ8DOh8V6H7bbmOv+SXTn35vC//glsfHA+OcBbfnF+HviO+IR1/C4hII0AAAAAElFTkSuQmCC)r20d(iVBO
Rw0KGgoAAAANSUhEUgAAAFQAAAA2AQMAAABjmSzTAAAABlBMVEUAAAD///+l2Z/dAAABwklEQVQoz33RzUsbQRQA8Jc4kjVIGxcP
QXKYTLOwu4deBMHbugQ1OTXW3npQvHhsUBAPwuQLNn5AWEZUiEu67KL+AYKFCq2kB6FY8D/Q1ksPQegxF9+uH7UFfTDw4/F4b+YN
HMUaDQEACTyf8prq7vPQld+yyj5woOjSBEmw7sW1ge65rOtBnqMjpu2xfR5BAn+ZHhqE/l54CAL/R3H0dNmZ4xBDrxHNjApuWNho
J3TLMdAHyR8L1bkavMKaU5qOZxstx0TX0ZMNHpTAwvHXojWzDtFnZsHZsPNHORGs+gWWtfybaqYsRr5RqGlmYE+/onDYMd9ffS63
9UMKx0Hesz19l0IpqPdswTYorLwedir+9y0X+zwVP1NL56uq2x2zAIRdktFxQ9zZZzJ1AX41Z+UpN8US+ICqPSBP+ZIpoWvot/NW
maAr5xf9TLW6vfz6yVncIFESkUKPG4QQ5dbpYvNsKdK3l0TH8kpG+LlpD92XV9rCr9+b3OdjxWZ70Vemt+/6Jh6tcEb6Z6/6I+fC
9x51RCH7IhfMEj4RBY1ZHt5ftNri3UAm1xPkWxl7U1Nv6z+ezMaznbAPDz4QqPTX4V5vAIcAlO/GwEFbAAAAAElFTkSuQmCC)r220(iVBO
Rw0KGgoAAAANSUhEUgAAAFUAAAA2AQMAAACMW0ftAAAABlBMVEUAAAD///+l2Z/dAAAB1UlEQVQoz2PoaFCa62/AwPi8gYFBlmPR
ggkdDEwCDAwMmuwyO4RmLGC6AGSvbOVQEVnpXzUBxGaXmSO0q5EJxJ6r0dEi0OgAVt95gGMHP8MCxgcMuIHDOQU5JgelbiUge4mb
gwnTAqVOBSDbL6/BhMlLZbITkM3CwCBygJVDoQ2sg1PkANO0wgwgiw/IZmBVm5TRABLnF2HgUpqlDlbD0cCBZIcElBaRWCXwuUNR
lGUKA4OSqoOmi4tTQ6cDA0OyxDFDF7nve+/eYWCYslTTK0WgRaGjg4Hh+9731UdknluA2CBxlwCIOIhdPA+iHgQYkexihtKFHsoi
C/gmuGl4GDB4tbis4JjI0cnQ58HgwZMscVSpgcFL04PhVdCUpUoqQMM0Axi8gWxVjaWanic9GLwuTVmqMVFV0wOovsgnWeKAnsQx
g44InGGoBPQXg0JLiCfQL46qDhoMglxMUyBSgu6GPQkgRvGc51YrvIImdTRA3H+ieM4jGLvDSaAJxAaqsXxu2JPU0QDRzIRkBxuU
5gT5i0GhJxDIlgL6i4lXUIhJYQEDOLyFgBgYedY9yRLnl3oFTdmpwAAklypogkkwW0kIIm4E8peOYU/yAqTUsUABKRwPAAD+UJDf
5v2M2AAAAABJRU5ErkJggg)r232(iVBORw0KGgoAAAANSUhEUgAAAF8AAAA2AQMAAACbedckAAAABlBMVEUAAAD///+l2Z/dAAAB50lEQVQo
z2Nw2qHYt+KckIwgpxIDg4KAU8AELyEOhTYg5/uELwIgjpcCkNMi084zwXt+X1DGIgaG50ItTJO8gjyTloJkhJqcQJxgJTugnimN
cyZOntzppcPBgAekWz6u8pzo5e+qVsHAMEWV1ckr2MgzV9MDzHEMCGbqDAVxvltyFjyY6s0Z+hIks5TTMSAyCiIzZSm/k1dklqcr
iDPdkhNkWqCrmgc+Sx/bNSlpqob6CS7s7GOY0uFSBOR4CSzyCmKYwqGx0lM11ElggVYQwxMOgRWdsqHOcza882No4VBY6cka6hS0
QsuNoaXDoUgTxFnl5cXQzNGgpN/6/fHcjZ2TYDYoYFrK2AAiHCAcJjDZAOGkWB5LjenSlNI0PsDAIK7KNblpVpZ2phdQaclOroc8
q9ZorQdxpiwVam46raWlCeIUW8qB9HhpGjkwkAUe1woKBoWGHFk8WQZotKBwF5DjsiBkCZAjsNQl8GpI2sY7a0AcV6+A0JDwFSFT
gHoEmydWxNelbZ6sAnI8I9wjMJ9AgNMEsPcbBUGUgoUDYwAD4yEOoN8YkgWY5zBaTGhpYAH5Z84XRQWNCU9VRRxACaldUlHnxzSd
JQ6ghNTCqqg1ZaqJO1BTskjzTlWfGVOWNjIghx0aAADsI5thJcwqQAAAAABJRU5ErkJggg)r85(iVBORw0KGgoAAAANSUhEUgAAADcAAAAJ
AQMAAACsZSbYAAAABlBMVEUAAAD///+l2Z/dAAAAOklEQVQI12NgAAH5HwwThBjYHyiwMHiorOpQUJnCoOLBILRQawmD0AQGRf1V
R+B8DxUGDpA8TD1UPwA0+Q+Fiuq8wwAAAABJRU5ErkJggg)rf5(iVBORw0KGgoAAAANSUhEUgAAADAAAAAQCAYAAABQrvyxAAAAvElEQVRI
x82V0RHEIAhEV0q5JlLM1ZdibCKtmB9vJmPg1FVMmMknPFhwA9wj5W9GzKylhpTAI+444g4SfG1Yq5W8BxhSuzJ8GhBmyQB/Izdf
buudAyjNum1Dem66Agyf7TtjQIup8qUG+ilV3LeXsySLafFDeZMN6wcAZLWDcRpMDYovDNjB72m+dD6+2tpZ9Wm+LHYftz9xs4OM
uI9HDWoDyvq7GjAMgMqXiUo+kh96HaFBvaX5MuocT+efVe6L32f2dpAAAAAASUVORK5CYII)rbc4(iVBORw0KGgoAAAANSUhEUgAAAQAAAAEA
CAYAAABccqhmAAALi0lEQVR42u3dTWhUVxsA4DOhi6BkOZt2USIEpBtRBBeVj+5EF4VIQQRDV5YWlHTTjXRZuukmoUJLXZUIIhQD
XSjuSokLQRQ3RQgYuvDbZBmUrLzfJme+M2fuvXPnJ84kPg8MSZw5956ZnPc9P/ee2Aq9vg4h/BLKfRNC+DXUG7X8QIoQinCAtUJo
LbZXOu9hffvbVvr82bnlnve3sbPaKjtWk9dWnausbJ38uKOWH5fF9kqRf4bTYhrr1ioL3KV2u/TFa9vbdYHcKf/x3x+Wlv/3P/8d
eyI4DAmgLDij7d2tMEoCaM/O97yuqhE2DeJBzt+v/LiCIp67PTvf+cz2K8kMWvdJ1K2pmTR4l9rtyuCPiWHv+V/2ynQF/8d/f1gZ
/DEx7D2fl2cvMPMG1Z6d7wnis3PLRRps+c9V5cqOXxfYa3/90fX83QfHwt0HxyrrX/Z8foxxNvyy9xzdePso3D96uuhXftCRy6BJ
7/7R08WNt49qE/I0jACKusCvGQ10ytcFfs1oYOTGcJhGAGmjCSGEW0euVJbb3t3qBNPZueWirmFdfXM7hBDChddPaj/vVxurxaXz
L0ufS49flUTSEUzZyCUmiY/OLveMevJj3j96usjru9heKW6ut8JHZ5dbdaOd/P3GY8Vz3Vxvhfx9buystl5trBbXFovGdUnf590H
x8K1xaLz+aRl8t9n+tlMeiQwM2JP/PUYylMS/LGhxsfVN7e7Gk57dj4stleKxfZKV/Bv726Fq29ud5UtO3aZa4tFV6DH3nuYXiuW
SUcA7dn5TpBUJZP7R08XdQF36fzL2l43fkYnHi51HatsepX35DEp5K+98PpJKx6ryVRqsb1SpGVOPFyqTYqTHgEM3PvnawKD9v5N
RwEnz5z8LYQQnj1+9tX7MgKIDfbVxmpx5s+fw+PPr4f49fm5tRBCCD/OfNrVe8SAiEPNEw+XQl72o7PLrbLAKmu8eUNt0vs3GQW0
Z+dLy8cyac+d1rWsTlVJ5+qb2yEGXJrY+q2rlB0r1jXWJe/J17e/7RqJ5IkyTb4hhPD83Fq4deTK1I0AptLJMyd/u/P7nXDn9zud
RPA+9P5pQ8vFhp3OKdM5b/qaQY+dBnhsyHFOHxtyHNrW1T8Gzc31VteaQFXwV01FTjxcCq82VotXG6uNgz9Nfmf+/Lk0EJv2wtu7
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)t0s2rf88(vu7uUAHCACoA
KiNYgAAaLIAAUXiAAAxogAATQIAAVFKAAIASgAAAAAAAiQ3Dhk/Hg8qCi8kCPz8/NIpPh4PKgT8/PyOMD4KKT0WDyoGLygI/Pz8h
jA+CiE6xi8oBPz8/I4wMhIvJAoPKgT8/PyKDyoE/Pz8jjQ+Ej5JLj5GLg8qCi8oCPz8/JIPKgT8/PyKODcODyoGLyQI/Pz8ij5JI
j5GHg8qBPz8/I4oPgoPKgYvKAT8/PyGMD4SLygKDyoE/Pz80jQyEj5KLj5DLi8kCg8qBPz8/I4PKgT8/PyOND4SDyoGLygI/Pz8j
jpDFj5KFg8qBPz8/I48NxI9txoPKgYvJAj8/PyKPcMWDyoE/Pz8jjA+Cj23Ei8oCg8qBPz8/IokPhI5uRIvKAoPKgT8/PyKLDIWP
cUaDyoGLyQI/Pz8ij25Eg8qBPz8/IowPhY9ug4PKgYvKAj8/PzSPcYWDyoE/Pz8jjQ3Fj26Fi8kCg8qBPz8/Io9vB4PKgT8/PyOP
DYOOcgaLygKDyoE/Pz8ijm8Gi8oCg8qBPz8/Io8NRY9vRYvJAoPKgT8/PyKIckWDyoE/Pz8jjw0Gj2+Fg8qBi8oCPz8/IYhyhILK
gT8/PyOPDMWPT8mLyQODyoE/Pz8jjU+Hg8qBPz8/NI8OgopOhYvKAoPKgT8/PyKMDoKPTaODyoGLygI/Pz8ijQzDg8qBi8kCPz8/
IoPKgT8/PyOPDoSDyoKLygI/Pz8ig8qBPz8/I44NRYpNSI9tRoPKgYvJAj8/PyGMbgeTKj8/PyKMDwOPbsiDyoGLygE/Pz8ijA8E
jW+Ji8oCg8qBPz8/NI8NQoxwRovJAoPKgT8/PyKOcQeDyoE/Pz8jjA8FjXHFi8oCg8qBPz8/IYhyhYPKgT8/PyOODAiIctuPkM6P
ks6LyQKDyoE/Pz8jjA3Gkyo/Pz8ijA8Fg8qBi8oBPz8/IowMCIySFo+P1ovKAoPKgT8/PyOKDceLyQKDyoE/Pz8jig8Gg8qBPz8/
IowMCYvKAoPKgj8/PzSMDceDyoE/Pz8jjA8Gj4/Oj5DNi8kCg8qBPz8/IZMqEo4MBz8/PxGMDciLygKDyoE/Pz8ijA8Gj4/Yj48X
iskFg8qBPz8/Io4MB4PKgYvKAj8/PyOODceDyoGLyQI/Pz8iig8Gi8oCg8qBPz8/IYwMCIvJAoPKgT8/PyOODIWPL4OPLkKPLIOP
T8OPr8aLyQODyoI/Pz8yiS+BjyyBjC5BjU+CiK+Fg8qBPzCHLIKMLkGPL4E/L48OQo8vgo8uQo8sgo9PQouvRovKAoPKgT8/PyGL
DkKLLkKPL4KPLIKPT4KJr4aLygKDyoE/Pz8hiwyEjC+Ciy5CjyyCj0/DiK/Fi8kCg8qBPz8/II4uQo8sgo8vgo1Pg4qvhoPKgT8/
Ao8uQY8vgY8sgT8vjw5FjyyCjy5Cjy+Cj09Diq9Gg8qBi8oCPz8/IYcuRI8vhI8sg45Pg4uvhoPKgT8/PyKNDISPLIKPLkKPL4KP
T8SPr8aDyoGLyQI/Pz8hjy+Bji5BjyyBjE+DiK+GgcqBPzCPL4GLLkGPLIE/MI0OQo8sgo8uQY8vgY9PRIivRoPKgovKAj8/PzKL
DkKNL4SDLkOPLIKPT4KJr4aLygKDyoE/Pz8gjg6GjyyWjy5Ujy+Sj1CYj7Cdi8kCg8qBPz8/IowOR5MqPz8/I44OBoPKgYvKAj8/
PyKMDkWDyoE/Pz8ijw3Fjy3Djy+DjzDCj0/Cj6/Gi8kCg8qBPz8/II8vgY8wwo8twY1PgYqvhoPKgT8/A48vgYgtwY0wwT8viw+C
jy3EjzDCjy+Bj09CiK9Gi8oBg8qBPz8/IIsPg48vgo8wwo8twotPgoivhovKAoPKgT8/PyCJDcSPMMKPLcKPL4KPT8OLr8aLyQOD
yoE/Pz8ijy3BjjDBjy+Bj0+Ch6+Gg8qBPy+NMMGPL4GPLcE/MY8PhY8vgo8two8wwY9PQ4evR4vKA4PKgT8/PzKPL4KPLcKPMMKN
T4OIr4c/Pz8jjA3Ejy3BjzDBjy+Bj0/Eiq/Gi8kCg8qBPz8/IY8wwY8vgY8twY5Pg4ivhoPKgT8wjzDBjy3Bjy+BPzCPD4KPLcKP
MMKPL4KPT0SJr0aDyoGLygI/Pz8hjQ+Djy+Bjy3BjzDBjU+Cia+Gi8oCg8qBPz8/IY4Px48w1o8t1Y8vlo9RlI+xlIvJA4PKgT8/
PyOMD4eDyoE/Pz8jjg9Gi8oCg8qBPz8/M44Ph4PKgT8/PyKPDIWPLkGPL4KPLIKPT8SPslKDyoKLyQI/Pz8gjy+BjC5BjyyBjU+C
g8qBPy+PL4GILIGPLkE/MI8OQo0sgYssgY8uQY8vgY1PQ4PKgovKAj8/PyCKDkSPLkGPLIKPL4KOT4SPspaLygKTKj8/PzOJDIWP
LIGPLkGPL4GPT8SDyoKLyQI/Pz8gjyyBjy+Bjy5BjE+Dg8qBPzCILkGIL4GILIE/MY4ORI8vgY0uQY8sgo8vgY8uQY9PQ4PKgYvK
Aj8/PyGPLkKPL4KPLIKMT4OMskGDyoE/HIyygT8KjbJBN4wMho8sgo8uQY8vgY9PxI+xhoPKgovJAj8/PzOPLIGOLkGPL4GNT4KH
sUU/L40uQYgsgY8vgT8wjQ5CnLKPL4GPLkGcso9PQ4aww4PKgYvKAj8/Px+LDkWPL4KPLkGPLIGNT4OKsIGLygKDyoE/HIqwwTaL
sIE/CowOho8vlI8slY8uV49PxI+vxovJAoPKgT8/PyGJDkgSiU+Ch6+Fg8qBPz8/IowOBYtPQoOvB4vKAoPKgT8/Pw2Gr4YSig5G
jk+Dg8qBPz8/IY8NxY8vgo8wwo8two9Oto+v1YPKgovJAj8/PyKPLcGLMMGPL4GDyoE/MI8wwYgtwY8vgT8wjA+Ejy3Bjy+CjzDC
jy3Bg8qCi8oCPz8/M40PhI4wwY8two8vgo+unovKAoPKgT8/PyCMDcWPL4GOMMKPLcGLyQKDyoE/Pz8ijy3BijDBji+BgMqBPzCI
MMGIL4GILcE/MY0PhI4wwY8vg5y3nLePMMGDyoGLygI/Pz8gjzDBjy3Cjy+BgMqBPz8/IY8Nx48vg48tw48wwY9N4Y+uVIvJAoPK
gT8/PzSMMMGPLcGOL4E/MIgtwYswwY0vgT8xjQ2Gji3CjzDCjy+Ci8oCPz8/Io8wwY8two8vgY+uiovKAj8/PyOPDUiPL5CPLdCP
MNCLygI/Pz8ji8oBPz8/Io0NBovKAj8/PyOLygI/Pz8kjwyGjyyCjS+Cjy5Cj0/Cj6/Gg8qBi8kCPz8/IYgsgYguQYgvgY5Pgoav
hoPKgT8wji+Biy5BjyyBPzGPDkKPLkKPL4KPLISPT0OHr0aDyoGLygI/Pz8hjA5Djy5Cjy+CjyyCj0+Eia+Hi8oCg8qBPz8/M44M
hI8sgo8uQY8vgY9PxIyvxovJAoPKgT8/PyKPL4KOLkKPLIGNT4OIr4aDyoE/LogsgY8uQY8vgT8xjw5Ejy+Bjy5BjyyBjk9Ehq9G
i8oCg8qBPz8/IY8vgo8uQY8sgo9Pg4evhoPKgT8/PyCIDIaPLkGPLIGPL4GPT8SLr8eDyoGLyQM/Pz8zjy+BjyyBjy5BjU+Dh6+G
gMqBPzCOLkGPL4GPLIE/MI0OQ48uQY8vgY8sgYxPQ4ivRoPKgYvKAj8/PyGLDkOPL4GPLIKPLkGOT4KJr4aLygKDyoE/Pz8gjQ6H
jyyQjy+Qjy5Qj1CVj7CXi8kDg8qBPz8/I4sORoLKgT8/PyKPDgaDyoGLygI/Pz8hjA5FgcqBPz8/M48NxY8two8wwo8vgo9PxI+v
xoPKgYvJAj8/PyGKMMKML4GPLcGMT4OIr4aDyoE/L4gtwY4wwY8vgT8wjA+Cjy3FjzDCjy+Cj09DiK9Gg8qBi8oBPz8/IYsPgo8t
wo8wwo8vgo9Pg4qvhovKApMqPz8/IYoNxI8wwY8two8vgY9Pw4uvxoPKgYvJAj8/PyGPLcGPMMGPL4GMT4SLr4eCyoE/PwSOMMGI
LcGPL4E/MY8PhJy3jzDCjy+Cj09DiK9Gg8qCi8oCPz8/IogwwY8two8vgo5PgoivhoPKgT8/PyGMDcSPMMGPLcGPL4GPT8SMr8aD
yoGLyQI/Pz8ijy3BjTDBjy+Bi0+Diq+GPzCILcGIL4GIMME/MY8Pgo4wwY8two8vgY1PQ4ivRoPKgYvKAj8/PyCND4SPL4KPMMKP
LcKNT4KLr4aLygKDyoE/Pz8hjw/GjjDLjy+Mjy3Lj1GTj7GUi8kCg8qBPz8/NIsPhj8/PyKJD0aDyoGLygI/Pz8hjQ+Fg8qBPz8/
I4wOgoUMwo8vwo8ugo8swo9RgoKM6oKN6oKOqY6xhYPKhIvJBInMQz8/PyGNDMGLDoGPL8KPLoKPLMKNUUKNsUSDyoI/Pz8hiw6C
jAzCjyzCjy/Cjy6Bj1CCh7CCi8oCg8qCPz8/IosOgooMwY8swY8ugY4vwY9RgoixhIPKgovKAj8/PyGNDoKMDMGPLMKPLoKPL8GO
UUSPsUaLyQSDyoI/Pz8yjA6BjwzBjy6Bjy/BjyzBjlCCirCCPz8/IY0OgY8MwY8ugo8swo4vwY9Rg4uxhovKA4PKgj8/PyCPDMGJ
DoGPLMKPL8GPLoKOUUKIsUKAyoE/Pz8hjQwCjw3Cjy8CjywCjy3Bj1GCgY8ogo3ngYzoj7GFg8qCicxCi8kCPz8/IYoNwosMAo8s
Ao0twogvAo1RRIqxRj8/PzSKDcKODAKNLAKLLcKLLwKMUMKHsMKDyoGLygKDyoE/Pz8iiw3BiwwCjiwCjS8BjC3Bj1GDiLGFi8oC
g8qBPz8/IYsMAogNwY4sAowtwo8vAo1RRI+xRovJAoPKgT8/PyGMDAKLDcGPLAKMLcKPLwKLUMKNsMI/Pz8hjQwCjg3CjywCjy8C
jC3Bj1GDiLGFi8oCg8qBPz8/IYwNwo0MAowtwY4vAY0sAo9RQoaxQ4LKgT8/PzKPDLOPDnWPLLePLnaPL7aPUYOCjLeCjnaCjbaP
sYWLyQODyoKJzEI/Pz8jjVFDirFGg8qCPz8/Io5Qg4+wh4PKgYvKAj8/PyKPUUKOsUaLygKDyoE/Pz8gj1CCj7CFi8oCg8qCPz8/
Io9Pg4mvh4HKgT8/PyOJUIKDyoKLygISirCFPz8/D4tPg4qviD8/PzOPDIWPLkKPL4GPLIKPToKProSLygKDyoE/Pz8gjE+Eiq+H
Pz8/I48NBY5Og42uhYvKAj8/PyGLTcSNrceLygE/Pz8jjQ1Hj05Mj65bi8oCPz8/Pz8/PwaPDYeLygE/Pz8/Pz8/Bw)s6r4a4(vu7uUAITACoA
KgAAAAASZIAAJkyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiDCJiDGIiEnJPz8/PyOHSoo/Pz8/DYgwiIgxiIhLiD8/Pz8NiEzJPz8/
Pw2IMIiIMYeIS4s/Pz8/DYdKhj8/Pz8MiDDpiDGqiErLPz8/Pw2HS4o/Pz8/DIZMiD8/Pz8Nh03SPz8/Pz8/Pz8/Pz8/J4gwh4cx
hodJyT8/Pz8NhkqKPz8/Pw2HMIiHMYaGS4Y/Pz8/DIhMyj8/Pz8NhzCHiDGIh0uIPz8/PwyHSoY/Pz8/DYkw1YgyFohKyj8/Pz8N
h0uGPz8/PwyGTIg/Pz8/DIkw0YgxkYlNzD8/Pz8Nh0yIPz8/PwyHS4U/Pz8/DIgwiIgxiIhJyj8/Pz8Nh0qJPz8/Pw2IMImHMYiG
S4o/Pz8/DYdMyj8/Pz8NiDCIiDGIh0uLPz8/PyKHSoc/Pz8/DIkw0YkxkohKyz8/Pz8Nh0uPPz8/PwyHTIg/Pz8/DIgvjYgwz4hN
yz8/Pz8Nh06IPz8/PwyHT4Y/Pz8/DIcvyogwS4dLij8/Pz8Nh0xGPz8/PwyIL0eIMEiHTUg/Pz8/DYdOiT8/Pz8NiC9IiDBIh01I
Pz8/Pw2HTEc/Pz8/DYgv6okwaIhMDD8/Pz8NhkzLPz8/PwyHTcg/Pz8/DIdPCD8/Pz8NhE3IPz8/Pw2GTMY/Pz8/DYgvyYgwSYdL
iz8/Pz8NhkxOPz8/PwyHL0iIMEiGTUg/Pz8/DYdOij8/Pz8NiC9IiDBIhk1KPz8/PyKHTEg/Pz8/DYgwYIcxoYhLiD8/Pz8NhkxK
Pz8/Pw2FTUg/Pz8/DYdOlD8/Pz8/Pz8/Pz8/PyeIM5GHTMk/Pz8/DYVNiD8/Pz8NiDNRhk6IPz8/Pw2HT8g/Pz8/DYcy0YZOiD8/
Pz8Nhk2IPz8/Pw2HMbKITcc/Pz8/DYVOij8/Pz8Nh0+IPz8/Pw2GUMg/Pz8/DYVPiD8/Pz8NhU6IPz8/Pw2IM5CHTMs/Pz8/DYZN
iT8/Pz8MiTNThk6IPz8/Pw2IT8g/Pz8/DYcyz4ZOjz8/Pz8MhU2FPz8/H4YyQyyHMpmHTcg/Pz8/DYZOij8/Pz8Nhk+HPz8/PwyI
MZqHUMc/Pz8/DYZPij8/Pz8NhU6FPz8/PwyHM5CHTMs/Pz8/DYVNiz8/Pz8iiTNRh06IPz8/Pw2HT8k/Pz8/DYcy0IZOiT8/Pz8N
hk2HPz8/Pw2IM1KGTAk/Pz8/DYZMyD8/Pz8NhzLShU3KPz8/Pw2HTws/Pz8/DYYyDoZNxj8/Pz8MhkzHPz8/Pw2IM5GGTIw/Pz8/
DYZNiT8/Pz8MhzLQh05IPz8/Pw2IT4k/Pz8/DYkykIdOST8/Pz8Nh02IPz8/Pw2JNFiITMg/Pz8/DYZNiD8/Pz8Nhk6IPz8/Pw2I
NJQWhk/IPz8/NoZOiD8/Pz8Nhk2GPz8/H4Y0QiyINI6HTIw/Pz8/DYdNij8/Pz8MhzRShk5LPz8/Pw2HT4c/Pz8/DIVOSxaIM5A/
Pz82hk2HPz8/PwyIMqiHTIg/Pz8/DYdNhz8/Pz8Nhk5HPz8/Pw2HT48/Pz8/Pz8/Pz8/Pz89)s1r11fb(vu7uUAIsACoAKgh+gAAEUIAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAhxCJiCrHPz8/PxqHEMiHLcg/Pz8/GogSmocuiD8/Pz8aiC3HPz8/PxqILIk/Pz8/GYcQioct
yD8/Pz8aiBDKhiuIPz8/PxqIElGILcg/Pz8/GogqyD8/Pz8ahxCLhy3JPz8/PxmIEMiGLog/Pz8/GogSE4ctyD8/Pz8ahyyIPz8/
PxqIEcmHLcg/Pz8/GYgRiIYriD8/Pz8aiBFJhy3IPz8/PxqIEIqIKsg/Pz8/GokQyYctyT8/Pz8aiRKghy6IPz8/PxmGLcg/Pz8/
GocsiD8/Pz8ahy3JPz8/PxqHK4g/Pz8/GYcUgYgtyD8/Pz8aiRS2iSrIPz8/PxqHLck/Pz8/GocuiD8/Pz8ahi3IPz8/PxmHK4g/
Pz8/GoctyD8/Pz8ahywIPz8/PxqHLcg/Pz8/GYcRCYgsSz8/Pz8ahhCIhi4JPz8/PxqHEmOGL0g/Pz8/GoYvyD8/Pz8ahzAIPz8/
PxmHL8k/Pz8/GoYvSj8/Pz8ahxQDhS4IPz8/PxqHFBuHLEk/Pz8/GYYuCT8/Pz8ahi9IPz8/PxqHL8k/Pz8/GocUgocwBz8ZhhTD
PyiFFIM/GIYUCIYvyD8/Pz8ZhxOJhy9JPz8/PxqHEwqFLgg/Pz8/GocSyIYsST8/Pz8aiBJJhi4JPz8/PxmHESuGL0g/Pz8/GoUv
yD8/Pz8ahjAIPz8/PxqHL8w/Pz8/GoUvSj8/Pz8ZiBCJhi4HPz8/PxqIETOHLEg/Pz8/GoUuCD8/Pz8ahi9IPz8/PxmFLgk/Pz8/
GocsSj8/Pz8/Pz8/Pz8/Pz8/Pz8/KIgQiYcqyD8/Pz8aiBDIhy3IPz8/PxqIEpqHLog/Pz8/GoctyD8/Pz8ghSyHPz8/PxKIEIkH
hy3FPz8/PxmIEM0BhiuHPz8/PwiGLckQiBJQPz8/PxmIKso/Pz8/GYgQiQmILco/Pz8/DokQyQyJLoc/Pz8/FokSDwOHLcc/Pz8/
GocsiD8/Pz8TiRHJB4ktyT8/Pz8TiBGKB4crij8/Pz8RhxFHCYYtyj8/Pz8OhxCKiCrJPz8/PxqIEMuGLck/Pz8/GYkSooguiD8/
Pz8aiC3IPz8/PxqHLIk/Pz8/GoYtyD8/Pz8ZhiuIPz8/PxqHFIGHLcc/Pz8/GokUsYgqyD8/Pz8ahi3JPz8/PxqGLog/Pz8/GYYt
yD8/Pz8ahyuIPz8/PxqHLcg/Pz8/GoYsCD8/Pz8Zhy3IPz8/PxqHEQiHLEk/Pz8/GocQiYYuCT8/Pz8ahxJihy9IPz8/PxqGL8g/
Pz8/GYcwCT8/Pz8ahi/JPz8/PxqHL0k/Pz8/GocUAoYuCD8/Pz8ZiBQahyxIPz8/PxqGLgk/Pz8/GoYvSD8/Pz8ahy/JPz8/PxqG
FIKHMAc/HIcUwz8whhSDPwyGFAeHL8g/Pz8/GocTiYcvST8/Pz8ahxMJhi4IPz8/PxqIEsiHLEg/Pz8/GYcSSYYuCT8/Pz8ahxEs
hi9IPz8/PxqGL8c/Pz8/GoYwCD8/Pz8ahi/JPz8/PxmHL0g/Pz8/GocQiYYuCD8/Pz8ahxE0hixIPz8/PxqGLgk/Pz8/GYYvRz8/
Pz8ahS4IPz8/PxqGLE8/Pz8/Pz8/Pz8/Pz8/Pz8/PyiHEYmGLMs/Pz8/GocRSYUuiT8/Pz8ahhCKhi/IPz8/PxmHEYqGLok/Pz8/
GogRSYYsyT8/Pz8ahxCJhi6JPz8/PxqIEYiHL8g/Pz8/GogRSYYuiD8/Pz8ZiBGKhyyHPz8/PxqHEUmGLkg/Pz8/GocQiYcviD8/
Pz8aiBFchy5IPz8/PxmHLIk/Pz8/GoYuST8/Pz8ahy+JPz8/PxqGEUmHLkc/Pz8/GocRCoYsSj8/Pz8ZhhCIhi4IPz8/PxqHEEmH
L0g/Pz8/GocRCYUuCT8/Pz8ahxCIhixJPz8/PxmHEEiGLgo/Pz8/GocRCYcvRz8/Pz8ahxBIhS4HPz8/PxqHEUqHLAo/Pz8/GocQ
iYctiD8/Pz8ZiA/Dhy8KPz8/PxqHEgmGLYk/Pz8/GocRSYcsCT8/Pz8ahxCJhy2IPz8/PxmIEsiHLwk/Pz8/GogSB4ctiD8/Pz8a
iBFJhywJPz8/PxqIE4qHLYg/Pz8/GogSx4cvCj8/Pz8ZhxIJhy2HPz8/PxqIFEmHLAk/Pz8/GocTiYctiD8/Pz8ahxRIhy8HPz8/
PxmIFQmHLYk/Pz8/GocV/Ycrij8/Pz8ahi1IPz8/PxqGLoc/Pz8/GoYtRz8/Pz8ZhiuLPz8/PxqGLUk/Pz8/GoYuiT8/Pz8ahxWC
hi1IPz8/PxmKFauHK4k/Pz8/GoUtSD8/Pz8ahS6HPz8/PxqFLUg/Pz8/GocrjT8/Pz8/Pz8/Pz8/Pz8/Pz8/KIgPSIcrkD8/Pz8Z
iA+IPz8/PxqIEEmHLUOHLoM/Pz8/GogPSYgtRocuhT8/Pz8ahw+IiCuQPz8/PxqIEYk/Pz8/GYkPSYctQogugz8/Pz8ahw+JPz8/
PxqJEMiHK5A/Pz8/GocPSj8/Pz8ZiA+Ihy1EiC6DPz8/PxqJEFOHLUOHLoM/Pz8/Gocrjz8/Pz8aiA/JPz8/PxqID4mHLUSILoQ/
Pz8/GYcPCT8/Pz8aiA+MhirRPz8/PxqHD8g/Pz8/GokQyYgsg4ktwj8/Pz8Zhw+KhyyBiS3BPz8/PxqJD8mIKtE/Pz8/GogRiD8/
Pz8aiA+JiCyBiC3BPz8/PxqHD8k/Pz8/GYkSSIkq0D8/Pz8ahw+JPz8/PxqJD8iILIGILcE/Pz8/GocSk4csgoctwT8/Pz8ZiSrQ
Pz8/PxqIEkg/Pz8/GokSB4gshIctxD8/Pz8ahxGJPz8/PxqHD0qIK5E/Pz8/GYYPiD8/Pz8aiRBLhy1Bhy6DPz8/PxqID0iHLUGH
LoM/Pz8/GogPiogrkD8/Pz8ZhxGKPz8/PxqJD0iHLUSILoM/Pz8/GogPiD8/Pz8aiRDIhyuQPz8/PxqHD0k/Pz8/GYgPiYctQYcu
gj8/Pz8aiRBUhy1Bhy6DPz8/PxqHK48/Pz8/GoYPyD8/Pz8ZiA+IiC1DiC6DPz8/PxqGDwk/Pz8/GogPmogqzz8/Pz8/Pz8/NIgs
gogtwT8/Pz8ZiA6bhyyBiC3BPz8/PxqGKtA/Pz8/Pz8/PzSHLIGILcI/Pz8/GYgOiD8/Pz8ahw5biCrSPz8/Pz8/Pz80iCyBiC3B
Pz8/PxqIDp6ILIGILcI/Pz8/GYgq0D8/Pz8/Pz8/NIgsgoktwT8/Pz8/Pz8/M4gPSIcrkD8/Pz8ahw+IPz8/PxqIEEmILUGHLoI/
Pz8/GogPSYctQocugj8/Pz8aiA+JhyuNPz8/PxmHEYo/Pz8/GocPSIctQogugj8/Pz8ahg+IPz8/PxqJEMmIK5A/Pz8/GYcPST8/
Pz8aiA+Ihy1BiC6CPz8/PxqJEFOHLUGHLoE/Pz8/GogrkD8/Pz8ahw/IPz8/PxmID4iHLUGILoM/Pz8/GocPCD8/Pz8aiQ+LiCrQ
Pz8/PxqGD8g/Pz8/GYkQyIgsgoctwT8/Pz8aiA+KhyyBhy3BPz8/PxqID8iIKtE/Pz8/GocRiD8/Pz8aiA+JiCyBiC3BPz8/PxmH
D8g/Pz8/GogSSIgq0D8/Pz8ahw+JPz8/PxqHD8iHLIGILcE/Pz8/GYoSlIcsgYYtwT8/Pz8aiSrPPz8/PxqHEkg/Pz8/GogSCIcs
gogtwT8/Pz8ahhGIPz8/PxmID0mHK5E/Pz8/GogPiD8/Pz8aiBBJhy1BiC6DPz8/PxqID0iHLUKGLoE/Pz8/GYgPiogrjz8/Pz8a
hxGJPz8/PxqID0iILUOILoM/Pz8/GogPiT8/Pz8aiRDKhyuQPz8/PxmHD0k/Pz8/GogPiIctQogugz8/Pz8aiRBUhy1Bhi6DPz8/
PxqIK48/Pz8/GYYPyD8/Pz8aiA+Jhy1BiC6GPz8/PxqHDwk/Pz8/GokPmogq0T8/Pz8/Pz8/M4gsgogtwT8/Pz8ahw6biCyBhy3C
Pz8/PxqGKtA/Pz8/Pz8/PzOILIKJLcI/Pz8/GocOiT8/Pz8aiQ5aiCrRPz8/Pz8/Pz80hyyBiC3BPz8/PxmIDpOILIGILcE/Pz8/
Gocq0D8/Pz8/Pz8/NIgOkYcsg4ctxD8/Pz8/Pz8/M4gPG4gqUT8/Pz8ahiwIPz8/PxqHLUg/Pz8/GocOU4YsCD8/Pz8ZhipKPz8/
PxqGLAg/Pz8/GogOUYctRz8/Pz8ahSwHPz8/PxmJDcmHKf8/Pz8/GocOSj8/Pz8aiA6IPz8/PxKIDko/Pz8/GYgOiT8/Pz8ihw8J
Pz8/PxqHDok/Pz8/GocPCT8/Pz8ahw+IPz8/PxmGDwg/Pz8/GocPiT8/Pz8ahg/HPz8/PxqIEIg/Pz8/GocPwT8lhxCDPyGHD8M/
EogPhj8/Pz8aiA8JPz8/PxqID4qIKow/Pz8/GocOiYgshz8/Pz8Zhw5Jhy2IPz8/PxqHD8mHLIk/Pz8/GocOiYcqiz8/Pz8ahw5K
hiyIPz8/PxqID4mHLYg/Pz8/GYcOiYYsiT8/Pz8aiA5JiCqIPz8/PxqHD8mHLIk/Pz8/GogOiYctiT8/Pz8Zhw5KhyyIPz8/PxqI
D4mIKoo/Pz8/GocOiYYsiD8/Pz8aiA5Khy2JPz8/PxqHDomHLIc/Pz8/GYgPiYcqyj8/Pz8ahw6JhyyHPz8/PxqHDkqHLcc/Pz8/
GocOiYcsgYUsgT8/Pz8Zhw+JhyrMPz8/PxqHDomGLIg/Pz8/GocOSYctxz8/Pz8ahw6JhyyIPz8/PxqIDeKHKss/Pz8/GYcsiD8/
Pz8aiC3JPz8/PxqGLIg/Pz8/Gocqyz8/Pz8ZhiyIPz8/PxqHLcg/Pz8/Gocshz8/Pz8aiA+JhyqJPz8/PxqHDomHLIg/Pz8/GYgO
SYcthz8/Pz8aiA/JhyyIPz8/PxqHDomHKog/Pz8/GogOSYYsiD8/Pz8ZiBCJhy2JPz8/PxqHDomGLIg/Pz8/GocOSYcqiD8/Pz8a
iRDKhyyJPz8/PxqHDoaHLY8/Pz8/GYYOSYYsiD8/Pz8aiBGJiCqKPz8/PxqID4iHLIk/Pz8/GogRSYctij8/Pz8ZiA+JhyyIPz8/
PxqKEhyJKss/Pz8/GocsiD8/Pz8ahy3KPz8/PxqLEpyHLIg/Pz8/GYgqzz8/Pz8ahiyIPz8/PxqHLcoBihG2Pz8/PxmGLIg/Pz8/
GYgqzj8/Pz8ahSyJPz8/PxqILck/Pz8/GocsiD8/Pz8aiCpQPz8/PxmILAk/Pz8/GooOiIsRiYgtST8/Pz8ahiwJPz8/PxqKDxqL
EhuIKdE/Pz8/GYcriT8/Pz8aiCzJPz8/PxqJD5qJEpqHK4k/Pz8/Gogpyj8/Pz8ahyuJPz8/PxmKDfOKEPiILMo/Pz8/GocriD8/
Pz8ahynJPz8/PxqHK4g/Pz8/GYcsyD8/Pz8ahSuJPz8/PxqHKc0/Pz8/GoYriD8/Pz8aiRDLhyzJPz8/PxmGK4g/Pz8/GogRSIgq
TT8/Pz8ahxBFhiwJPz8NiBFEPz8NiRIIhy1KPz8/PxmIEUSHLAc/Pw2HEgQ/Pw2KE0gKiCpOPz8/PxCIEgSHLAg/Pw2JE0Q/Pw2K
FEgIiC1LPz8/PxKHE0SHLAg/PwyGFEQ/Pw2KFR2IKk4/Pz8/GoYsCD8/Pz8ahy1LPz8/PxqHLAk/Pz8/GYkVFYgqSz8/Pz8ahiwK
Pz8/PxqHLUk/Pz8/GoYsCT8/Pz8aiQ8SihITiSnQPz8/PxmHK4k/Pz8/GogsyT8/Pz8aig+SihKShyuJPz8/PxqIKcs/Pz8/GYcr
iT8/Pz8aiQ3wiRDyiCzJPz8/PxqHK4g/Pz8/GoYpyT8/Pz8ahiuJPz8/PxmGLMg/Pz8/GoQriD8/Pz8ahynLPz8/PxqFK4k/Pz8/
GYkQ0oYsyD8/Pz8ahiuIPz8/PxqJEGyHKk0/Pz8/GoUsCD8/Pz8ahi1IPz8/PxmGLAg/Pz8/GoYqUD8/Pz8ahSwIPz8/PxqIEE+H
LUk/Pz8/GYYsCD8/Pz8aiA8/iSpKPz8/PxqGLAk/Pz8/GoctST8/Pz8ahSwIPz8/PxmHKkg/Pz8/GoYsCD8/Pz8ahi1IPz8/PxqG
LAg/Pz8/GQ)t0s21r3b(6+sA1gBWHwQE+joUAwCZAwD//wAA3wIAFgAyANIAGQUBkADIAgMAAQAABAAH//8ADUjTACQdywCeAAA)r39(6+sApABpHAFM
AgCT3AIADv//AK+z3AAjBAAHAOwAGQBFABgALACDAE4BAAADAAv//wAlLlgAdAAA)r42(6+sAnQBXHwILCSJTgbYAQQASAAMCpgQA//8B
AOkAAABYAQAFA20BAAAEAAT//wALKe4AGg9yAHQAAAUHCAAyAhQA)r2f(6+sBRACLAQUBAAAEAAT//wAsMI0AMg09AOIAAAUCWAEsBQJY
AMgICPwIB9ACUAA)r6d(6+sBqgCAFwIJD2fCAC8ACQAXA7MEAABBAgAfALoAigBOAQAABAAP//8AEzlhABgWEQBQAAAIC7gIC7gCAgAEAEbM
M4CAAf//AgBC//8BaAAAAAEFAQAABAAE//8ACWaeABso0wCOAAAFA+gBLA)r24(6+sBdABpAQUBAAAEAAr/vgAiIjQAMA09ARgAAAUEsADI
AgcA)r31(6+sBBABEHACAAgD//wEAGWWEAC8CABQA5QAwACYBAAAEABP//wAnWnsATBywAH4AAA)r36(6+sAZwAmHgoY8TYgWBQHAAAAA8ADAP//
AAv4AAEAAAQAC///AAs2EQAmD3IAKwAACCMoAgUA)r31(6+sBBABEHACAAgD//wEAGWWEAC8CABMBUgAvADUBAAAEABP//wAnWnsATByw
AH4AAA)r46(6+sBCAAmHgoY8TYgWBQHAAAAA8AEAP//AAv4AAEAAAgABLhGAAj//wADncsACqRpAAfo0wALWEYAECe5AM0AAAgjKAIFAA)r2d(6+sA
1ACAAQUFAKoAKAUAqgAoAhQAAQAABQAIz3IAE///ABNnuQAzJYQAcwAA)r54(6+sCTwAzHgoY8TYgWBQHAAAAA8AHAP//ABEcAAEAAAMA
C///ABEsIwAcAAAEABKAgIDmBAAZs4CAzAH//wQAMf//ADOo0wF8RYQAbwAACCMoAgUA)r2d(6+sA1ACAAQUFAMgAKAUAyAAoAhQAAQAA
BQAIz3IAE///ABNnuQAzJYQAcwAA)r2d(6+sA1ACAAQUFAPoAKAUA/wAoAhQAAQAABQAIz3IAE///ABNnuQAzJYQAcwAA)r4c(6+sElgCqFgfX
AAAYAAAEAxkDAA5QAQLsD6YBAAAEAA///wBIO5YAUx3LAl4AAAQAObOAgMwEACtms4DMAf//AwHORYQBN0RpAZEAAA)r2d(6+sA1ACAAQUF
ASwAKAUBNgAoAhQAAQAABQAIz3IAE///ABNnuQAzJYQAcwAA)r39(6+sCuwAoPgcGF8ZAEQQDAcUCmaaeAgDRunsCTynuBdsABQAAFAEA
AAQAC///ADMnuQA2E9wCRwAA)r4b(6+sDpACAFgoYAFIAAIQAfkEPAwADAAAmAAEAAAUABaRpABP//wAgTCMANhlhAjsAAAQAKZlmgLME
ADWzZoCAAf//AgEj//8CgQAA)r32(6+sBUgA8Fgv2AD4AEQAAAAAAAAOzBAAIoAABAAAFAAngAAAL//8AI1T3ADUhGgDmAAA)r76(6+sCbQCAHQQC
JgQA//8BAG9PcgfjAAEAAAQACf//ACJGngAeEsIAjAAABAAogICAzAH//wIAuf//AX8AAAAWCCAAWgB4k0MNAuMCAAv4AAEAAAQA
B///AB43LAAxEsIA0AAABAA1gGaAswFQjQIA1VcsAZgAAA)r38(6+sBOwBcHwQJBqVwQBEEAwAIASYCAP//AAryAAEAAAQAC///ACQkaQAr
DlgA4QAABR9AAfQCCgA)r31(6+sAoQBDFgb7AC4ADQABTwEAA6MCAAoBiAAFBHsBAAAEAAf//wATOnsAGxPcAGwAAA)r5b(6+sDwwBDPwQM8SEIAgEA
AAAAAAAAA9kEAP//AAc3AQBYBa8PAAAyAQAAAgAP//8ANgAABAAbgOaA5gQAFbNmgMwIF3ACCgAB//8EAEP//wDBRGkBoT7lAR4A
AA)r35(6+sBkgBXPgv5AEIAIAAMAAIAAAFMAYD//wAAUQAEAAlgAQAABAAE//8AEVlhACcjTwFWAAA)r38(6+sCJACAHgovIzFIQiQAAAAAAwACAGjT
AgAP//8B99PcCbgAAQAABAAW//8AHy5YADkPcgG2AAA)r32(6+sA5gCAFgf8ABYAAAgDAuYBAAHjAgAHAHcA6ACGAQAABAAJ//8AEjGnABkN
PQCyAAA)r32(6+sA5gCAFgf8ABYAAAgDAuYBAAHjAgAJAFYA5gBzAQAABAAO//8ADyjTABcNPQCyAAA)r3b(6+sBOwCANgf7d0MoEggEAPUBAALIAgAW
AHoBgQBeCAAAMgUAggBkAQAABAAk//8AMjCNAC4RpwC3AAA)r36(6+sBmwCANgf7d0MoEggEAPUBAALIAgAWAHoBgQBeCAAAMgEAAAQAGf//
ADEkaQA3DCMBGgAA)r36(6+sBmwCANgf7d0MoEggEAPUBAALIAgAXAEUBfQAzCAAAMgEAAAQAGf//ADEkaQA3DCMBGgAA)r2e(6+sAgAAiFgc0
l+JiMhcBAWYCAAAuAQCZCW8BAAAEAAn//wAYSNMAHBYRAEMAAA)r2e(6+sAgAAiFgc0l+JiMhcBAWYCAAAgAQCaA6MBAAAEAAn//wAYSNMA
HBYRAEMAAA)r2d(6+sAuwCAFgocM1FdTC4dDwgBAsUBAAy0AAEAAAQAD///ABQz3AAzB7kAZQAA)r2d(6+sAuwCAFgocM1FdTC4dDwgBAsUBAAlv
AAEAAAQAD///ABQz3AAzB7kAZQAA)r30(6+sA0gCAAQUFG1gBkAEAAAcABv//AAsU9wAKFPcABnYRAA8gAAAZDCMAiQAAAgoA)r70(6+sCZABP
AQUBAAADABb//wA6TT0A1gAABABjgEyAmQQAb4BMgGYB//8CAUz//wDlAAAAFgUHNmc7BwSAAQAAQwIAGi8XAX4bjgEAAAQAEv//
AConuQAvCwgBEQAABAA/wECA5gH//wIBUf//ARMAAA)r2d(6+sBWgCAMgb4GQsABAEEewEBiwY3DAAAyAEAAAQAKv//AFVOWABBGWEAmgAA
)r2d(6+sCgQCAMgb4GQsABAEEewECoQaZCAAAyAEAAAQAWv//AFZAAABbEacBdgAA)r85(6+sBxgBcPgcJNFcjGAAHAMABAP//AQKmwAAA7AEB
0gEKEAAAyAEAABcADf//AAYAAAAaAAAAFf//AAsAAAAeAAAADf//AA4AAAAiAAAAFJGnABgAAAAZAAAAEEAAABAAAAAeAAAADi9y
AAkAAAAmAAAADRywAA4AAAAgAAAAEBLCABMAAA)ra9(6+sClgBcPgcJNFcjGAAHAMABAP//AQKmwAAA7AECvAE+EAAAyAEAACAADf//AAYA
AAAaAAAAFf//AAsAAAAgAAAAEv//AAkAAAAgAAAAFf//AAoAAAAhAAAAEv//AA4AAAAcAAAAF7lhAAcAAAAeAAAAF4nuAAoAAAAd
AAAAGE9yAAsAAAAgAAAAFCjTAA4AAAAhAAAADhp7AAwAAAAfAAAAFBCNACUAAA)r29(6+sAqQBXAQUFBLAAMgUEsAK8AhQAAQAABAAH//8A
DUAAABMblgCCAAA)r4d(6+sA9QCbPwIN3QAvslCBAAA9HggAAAQAAwBhGgEAC///BQwBAAsOvgoAADIBAAAEAA79ywAdVhEAMB3LAJoAAAUF
FAGQBQUUAGQCBwA)r4d(6+sA9QCbPwIN3QAvslCBAAA9HggAAAQAAwBhGgEAC///BQwBAAsOvgoAADIBAAAEAA79ywAdVhEAMB3LAJoAAAUD
IAGQBQMgAGQCBwA)r38(6+sAuwC9HAdUBAD//wEAkgAAAMADAAgBGwASAIIAxgEjAQAABAAR//8AGEjTADISwgBgAAAIArw)r3c(6+sBRwC9HAdUBADF
hAIAVPp7AJIAAADAAwAMANgADgCCATwA7AEAAAQAEf//ABhI0wBcFywAwgAACAK8)r4c(6+sAWwDKHg3sRWcWAE8ALxMEAAAAA2YCAK5Y
AgAM57kAQwAAAbgDAAUMtAAHBBkABgkoAQAABAAI//8AD1LCABwkaQAoAAAFE4gDIA)r42(6+sAgACpFg3sRWcWAE8ALxMEAAAAA2YCAAG4
AwAFDLQABwQZAAYJKAEAAAQACP//AA9SwgAiFywARwAACAu4CAnE)r47(6+sA6ADNPgz+bjgQBgAAAAAAAAAAgAEAIjQCAEf//wDwJp4B
rQEBRwEbCAAJYAEAAAQACv//ABs8sAAyEsIAkQAABQUUAyA)</egg-rom>
<script>
/* Webgl.js
 * Adapter that exposes GLES2 to the Wasm client, and implements in a WebGL context.
 */
 
class Webgl {
  constructor(egg, gl) {
    this.egg = egg;
    this.gl = gl;
    this.o = ["neverZero"]; // GL objects (mixed types), indexed by ID. Can be sparse.
    this.nextId = 1;
    this.glstrp = 0; // Storage for glGetString, set by Render.js.
    this.glstra = 0;
    this.locv = ["neverZero"]; // Uniform locations. TODO We never remove them. Will that be a problem?
  }
  
  generatePublicApi() {
    return {
      // Anything with no pointers or object names converts trivially.
      glActiveTexture: (a) => this.gl.activeTexture(a),
      glBlendColor: (a,b,c,d) => this.gl.blendColor(a,b,c,d),
      glBlendEquation: (a) => this.gl.blendEquation(a),
      glBlendEquationSeparate: (a,b) => this.gl.blendEquationSeparate(a,b),
      glBlendFunc: (a,b) => this.gl.blendFunc(a,b),
      glBlendFuncSeparate: (a,b,c,d) => this.gl.blendFuncSeparate(a,b,c,d),
      glCheckFramebufferStatus: (a) => this.gl.checkFramebufferStatus(a),
      glClear: (a) => this.gl.clear(a),
      glClearColor: (a,b,c,d) => this.gl.clearColor(a,b,c,d),
      glClearDepthf: (a) => this.gl.clearDepth(a),
      glClearStencil: (a) => this.gl.clearStencil(a),
      glColorMask: (a,b,c,d) => this.gl.colorMask(a,b,c,d),
      glCullFace: (a) => this.gl.cullFace(a),
      glDepthFunc: (a) => this.gl.depthFunc(a),
      glDepthMask: (a) => this.gl.depthMask(a),
      glDepthRangef: (a,b) => this.gl.depthRangef(a,b),
      glDisable: (a) => this.gl.disable(a),
      glDisableVertexAttribArray: (a) => this.gl.disableVertexAttribArray(a),
      glDrawArrays: (a,b,c) => this.gl.drawArrays(a,b,c),
      glDrawElements: (a,b,c,d) => this.gl.drawElements(a,b,c,d),
      glEnable: (a) => this.gl.enable(a),
      glEnableVertexAttribArray: (a) => this.gl.enableVertexAttribArray(a),
      glFinish: () => this.gl.finish(),
      glFlush: () => this.gl.flush(),
      glFrontFace: (a) => this.gl.frontFace(a),
      glGenerateMipmap: (a) => this.gl.generateMipmap(a),
      glGetError: () => this.gl.getError(),
      glHint: (a,b) => this.gl.hint(a,b),
      glIsEnabled: (a) => this.gl.isEnabled(a),
      glLineWidth: (a) => this.gl.lineWidth(a),
      glPixelStorei: (a,b) => this.gl.pixelStore(a,b),
      glPolygonOffset: (a,b) => this.gl.polygonOffset(a,b),
      glReleaseShaderCompiler: () => this.gl.releaseShaderCompiler(),
      glRenderbufferStorage: (a,b,c,d) => this.gl.renderbufferStorage(a,b,c,d),
      glSampleCoverage: (a,b) => this.gl.sampleCoverage(a,b),
      glScissor: (a,b,c,d) => this.gl.scissor(a,b,c,d),
      glStencilFunc: (a,b,c) => this.gl.stencilFunc(a,b,c),
      glStencilFuncSeparate: (a,b,c,d) => this.gl.stencilFuncSeparate(a,b,c,d),
      glStencilMask: (a) => this.gl.stencilMask(a),
      glStencilMaskSeparate: (a,b) => this.gl.stencilMaskSeparate(a,b),
      glStencilOp: (a,b,c) => this.gl.stencilOp(a,b,c),
      glStencilOpSeparate: (a,b,c,d) => this.gl.stencilOpSeparate(a,b,c,d),
      glTexParameterf: (a,b,c) => this.gl.texParameterf(a,b,c),
      glTexParameteri: (a,b,c) => this.gl.texParameteri(a,b,c),
      glUniform1f: (a,b) => this.gl.uniform1f(this.locv[a],b),
      glUniform1i: (a,b) => this.gl.uniform1i(this.locv[a],b),
      glUniform2f: (a,b,c) => this.gl.uniform2f(this.locv[a],b,c),
      glUniform2i: (a,b,c) => this.gl.uniform2i(this.locv[a],b,c),
      glUniform3f: (a,b,c,d) => this.gl.uniform3f(this.locv[a],b,c,d),
      glUniform3i: (a,b,c,d) => this.gl.uniform3i(this.locv[a],b,c,d),
      glUniform4f: (a,b,c,d,e) => this.gl.uniform4f(this.locv[a],b,c,d,e),
      glUniform4i: (a,b,c,d,e) => this.gl.uniform4i(this.locv[a],b,c,d,e),
      glVertexAttrib1f: (a,b) => this.gl.vertexAttrib1f(a,b),
      glVertexAttrib2f: (a,b,c) => this.gl.vertexAttrib2f(a,b,c),
      glVertexAttrib3f: (a,b,c,d) => this.gl.vertexAttrib3f(a,b,c,d),
      glVertexAttrib4f: (a,b,c,d,e) => this.gl.vertexAttrib4f(a,b,c,d,e),
      glViewport: (a,b,c,d) => this.gl.viewport(a,b,c,d),
      // All the rest are a little more interesting:
      glAttachShader: (a,b) => this.glAttachShader(a,b),
      glBindAttribLocation: (a,b,c) => this.glBindAttribLocation(a,b,c),
      glBindBuffer: (a,b) => this.glBindBuffer(a,b),
      glBindFramebuffer: (a,b) => this.glBindFramebuffer(a,b),
      glBindRenderbuffer: (a,b) => this.glBindRenderbuffer(a,b),
      glBindTexture: (a,b) => this.glBindTexture(a,b),
      glBufferData: (a,b,c,d) => this.glBufferData(a,b,c,d),
      glBufferSubData: (a,b,c,d) => this.glBufferSubData(a,b,c,d),
      glCompileShader: (a) => this.glCompileShader(a),
      glCompressedTexImage2D: (a,b,c,d,e,f,g,h) => this.glCompressedTexImage2D(a,b,c,d,e,f,g,h),
      glCompressedTexSubImage2D: (a,b,c,d,e,f,g,h,i) => this.glCompressedTexSubImage2D(a,b,c,d,e,f,g,h,i),
      glCopyTexImage2D: (a,b,c,d,e,f,g,h) => this.glCopyTexImage2D(a,b,c,d,e,f,g,h),
      glCopyTexSubImage2D: (a,b,c,d,e,f,g,h) => this.glCopyTexSubImage2D(a,b,c,d,e,f,g,h),
      glCreateProgram: () => this.glCreateProgram(),
      glCreateShader: (a) => this.glCreateShader(a),
      glDeleteBuffers: (a,b) => this.glDeleteBuffers(a,b),
      glDeleteFramebuffers: (a,b) => this.glDeleteFramebuffers(a,b),
      glDeleteProgram: (a) => this.glDeleteProgram(a),
      glDeleteRenderbuffers: (a,b) => this.glDeleteRenderbuffers(a,b),
      glDeleteShader: (a) => this.glDeleteShader(a),
      glDeleteTextures: (a,b) => this.glDeleteTextures(a,b),
      glDetachShader: (a,b) => this.glDetachShader(a,b),
      glFramebufferRenderbuffer: (a,b,c,d) => this.glFramebufferRenderbuffer(a,b,c,d),
      glFramebufferTexture2D: (a,b,c,d,e) => this.glFramebufferTexture2D(a,b,c,d,e),
      glGenBuffers: (a,b) => this.glGenBuffers(a,b),
      glGenFramebuffers: (a,b) => this.glGenFramebuffers(a,b),
      glGenRenderbuffers: (a,b) => this.glGenRenderbuffers(a,b),
      glGenTextures: (a,b) => this.glGenTextures(a,b),
      glGetActiveAttrib: (a,b,c,d,e,f,g) => this.glGetActiveAttrib(a,b,c,d,e,f,g),
      glGetActiveUniform: (a,b,c,d,e,f,g) => this.glGetActiveUniform(a,b,c,d,e,f,g),
      glGetAttachedShaders: (a,b,c,d) => this.glGetAttachedShaders(a,b,c,d),
      glGetAttribLocation: (a,b) => this.glGetAttribLocation(a,b),
      glGetBooleanv: (a,b) => this.glGetBooleanv(a,b),
      glGetBufferParameteriv: (a,b,c) => this.glGetBufferParameteriv(a,b,c),
      glGetFloatv: (a,b) => this.glGetFloatv(a,b),
      glGetFramebufferAttachmentParameteriv: (a,b,c,d) => this.glGetFramebufferAttachmentParameteriv(a,b,c,d),
      glGetIntegerv: (a,b) => this.glGetIntegerv(a,b),
      glGetProgramiv: (a,b,c) => this.glGetProgramiv(a,b,c),
      glGetProgramInfoLog: (a,b,c,d) => this.glGetProgramInfoLog(a,b,c,d),
      glGetRenderbufferParameteriv: (a,b,c) => this.glGetRenderbufferParameteriv(a,b,c),
      glGetShaderiv: (a,b,c) => this.glGetShaderiv(a,b,c),
      glGetShaderInfoLog: (a,b,c,d) => this.glGetShaderInfoLog(a,b,c,d),
      glGetShaderPrecisionFormat: (a,b,c,d) => this.glGetShaderPrecisionFormat(a,b,c,d),
      glGetShaderSource: (a,b,c,d) => this.glGetShaderSource(a,b,c,d),
      glGetString: (a) => this.glGetString(a),
      glGetTexParameterfv: (a,b,c) => this.glGetTexParameterfv(a,b,c),
      glGetTexParameteriv: (a,b,c) => this.glGetTexParameteriv(a,b,c),
      glGetUniformfv: (a,b,c) => this.glGetUniformfv(a,b,c),
      glGetUniformiv: (a,b,c) => this.glGetUniformiv(a,b,c),
      glGetUniformLocation: (a,b) => this.glGetUniformLocation(a,b),
      glGetVertexAttribfv: (a,b,c) => this.glGetVertexAttribfv(a,b,c),
      glGetVertexAttribiv: (a,b,c) => this.glGetVertexAttribiv(a,b,c),
      glGetVertexAttribPointerv: (a,b,c) => this.glGetVertexAttribPointerv(a,b,c),
      glIsBuffer: (a) => this.glIsBuffer(a),
      glIsFramebuffer: (a) => this.glIsFramebuffer(a),
      glIsProgram: (a) => this.glIsProgram(a),
      glIsRenderbuffer: (a) => this.glIsRenderbuffer(a),
      glIsShader: (a) => this.glIsShader(a),
      glIsTexture: (a) => this.glIsTexture(a),
      glLinkProgram: (a) => this.glLinkProgram(a),
      glReadPixels: (a,b,c,d,e,f,g) => this.glReadPixels(a,b,c,d,e,f,g),
      glShaderBinary: (a,b,c,d,e) => this.glShaderBinary(a,b,c,d,e),
      glShaderSource: (a,b,c,d) => this.glShaderSource(a,b,c,d),
      glTexImage2D: (a,b,c,d,e,f,g,h,i) => this.glTexImage2D(a,b,c,d,e,f,g,h,i),
      glTexParameterfv: (a,b,c) => this.glTexParameterfv(a,b,c),
      glTexParameteriv: (a,b,c) => this.glTexParameteriv(a,b,c),
      glTexSubImage2D: (a,b,c,d,e,f,g,h,i) => this.glTexSubImage2D(a,b,c,d,e,f,g,h,i),
      glUniform1fv: (a,b,c) => this.glUniform1fv(a,b,c),
      glUniform1iv: (a,b,c) => this.glUniform1iv(a,b,c),
      glUniform2fv: (a,b,c) => this.glUniform2fv(a,b,c),
      glUniform2iv: (a,b,c) => this.glUniform2iv(a,b,c),
      glUniform3fv: (a,b,c) => this.glUniform3fv(a,b,c),
      glUniform3iv: (a,b,c) => this.glUniform3iv(a,b,c),
      glUniform4fv: (a,b,c) => this.glUniform4fv(a,b,c),
      glUniform4iv: (a,b,c) => this.glUniform4iv(a,b,c),
      glUniformMatrix2fv: (a,b,c,d) => this.glUniformMatrix2fv(a,b,c,d),
      glUniformMatrix3fv: (a,b,c,d) => this.glUniformMatrix3fv(a,b,c,d),
      glUniformMatrix4fv: (a,b,c,d) => this.glUniformMatrix4fv(a,b,c,d),
      glUseProgram: (a) => this.glUseProgram(a),
      glValidateProgram: (a) => this.glValidateProgram(a),
      glVertexAttrib1fv: (a,b) => this.glVertexAttrib1fv(a,b),
      glVertexAttrib2fv: (a,b) => this.glVertexAttrib2fv(a,b),
      glVertexAttrib3fv: (a,b) => this.glVertexAttrib3fv(a,b),
      glVertexAttrib4fv: (a,b) => this.glVertexAttrib4fv(a,b),
      glVertexAttribPointer: (a,b,c,d,e,f) => this.glVertexAttribPointer(a,b,c,d,e,f),
    };
  }
  
  /* Create and delete objects.
   **********************************************************/
   
  objAlloc() {
    const p = this.o.indexOf(null);
    if (p >= 0) return p;
    return this.nextId++;
  }
  
  objDel(id) {
    if (id < 1) return;
    this.o[id] = null;
  }

  glCreateProgram() {
    const id = this.objAlloc();
    if (!(this.o[id] = this.gl.createProgram())) return 0;
    return id;
  }

  glCreateShader(a) {
    const id = this.objAlloc();
    if (!(this.o[id] = this.gl.createShader(a))) return 0;
    return id;
  }

  glGenBuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.objAlloc();
      this.o[id] = this.gl.createBuffer();
      this.egg.exec.mem32[p] = id;
    }
  }

  glGenFramebuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.objAlloc();
      this.o[id] = this.gl.createFramebuffer();
      this.egg.exec.mem32[p] = id;
    }
  }

  glGenRenderbuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.objAlloc();
      this.o[id] = this.gl.createRenderbuffer();
      this.egg.exec.mem32[p] = id;
    }
  }

  glGenTextures(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.objAlloc();
      this.o[id] = this.gl.createTexture();
      this.egg.exec.mem32[p] = id;
    }
  }

  glDeleteBuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.egg.exec.mem32[p];
      this.gl.deleteBuffer(this.o[id]);
      this.objDel(id);
    }
  }

  glDeleteFramebuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.egg.exec.mem32[p];
      this.gl.deleteFramebuffer(this.o[id]);
      this.objDel(id);
    }
  }

  glDeleteProgram(a) {
    this.gl.deleteProgram(this.o[a]);
    this.objDel(a);
  }

  glDeleteRenderbuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.egg.exec.mem32[p];
      this.gl.deleteRenderbuffer(this.o[id]);
      this.objDel(id);
    }
  }

  glDeleteShader(a) {
    this.gl.deleteShader(this.o[a]);
    this.objDel(a);
  }

  glDeleteTextures(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.egg.exec.mem32[p];
      this.gl.deleteTexture(this.o[id]);
      this.objDel(id);
    }
  }

  glIsBuffer(a) {
    return this.gl.isBuffer(this.o[a]);
  }

  glIsFramebuffer(a) {
    return this.gl.isFramebuffer(this.o[a]);
  }

  glIsProgram(a) {
    return this.gl.isProgram(this.o[a]);
  }

  glIsRenderbuffer(a) {
    return this.gl.isRenderbuffer(this.o[a]);
  }

  glIsShader(a) {
    return this.gl.isShader(this.o[a]);
  }

  glIsTexture(a) {
    return this.gl.isTexture(this.o[a]);
  }
   
  /* Miscellaneous.
   ***********************************************************/
  
  glAttachShader(pid, sid) {
    this.gl.attachShader(this.o[pid], this.o[sid]);
  }

  glBindAttribLocation(pid, index, namep) {
    const program = this.o[pid];
    const name = this.egg.exec.readCString(namep);
    this.gl.bindAttribLocation(program, index, name);
  }

  glBindBuffer(target, id) {
    const buffer = this.o[id];
    this.gl.bindBuffer(target, buffer);
  }

  glBindFramebuffer(target, id) {
    const fb = this.o[id];
    this.gl.bindFramebuffer(target, fb);
  }

  glBindRenderbuffer(target, id) {
    const rb = this.o[id];
    this.gl.bindRenderbuffer(target, rb);
  }

  glBindTexture(target, id) {
    const texture = this.o[id];
    this.gl.bindTexture(target, texture);
  }

  glBufferData(target, size, datap, usage) {
    if (datap) {
      const data = this.egg.exec.getView(datap, size);
      if (!data) return;
      this.gl.bufferData(target, data, usage);
    } else {
      this.gl.bufferData(target, size, usage);
    }
  }

  glBufferSubData(target, offset, size, datap) {
    const data = this.egg.exec.getView(datap, size);
    if (!data) return;
    this.gl.bufferSubData(target, offset, data);
  }

  glCompileShader(id) {
    const shader = this.o[id];
    this.gl.compileShader(shader);
  }

  glDetachShader(pid, sid) {
    const program = this.o[pid];
    const shader = this.o[sid];
    this.gl.detachShader(program, shader);
  }

  glFramebufferRenderbuffer(target, attachment, rbtarget, rbid) {
    const rb = this.o[rbid];
    this.gl.framebufferRenderbuffer(target, attachment, rbtarget, rb);
  }

  glFramebufferTexture2D(target, attachment, textarget, texid, level) {
    const texture = this.o[texid];
    this.gl.framebufferTexture2D(target, attachment, textarget, texture, level);
  }

  glGetActiveAttrib(pid, index, bufsize, lenp, sizep, typep, namep) {
    const program = this.o[pid];
    const attr = this.gl.getActiveAttrib(program, index);
    if (!attr) return;
    if (sizep) this.egg.exec.mem32[sizep >> 2] = attr.size;
    if (typep) this.egg.exec.mem32[typep >> 2] = attr.type;
    if (namep && (bufsize > 0)) {
      this.egg.exec.safeWrite(namep, bufsize, attr.name);
    }
  }

  glGetActiveUniform(pid, index, bufsize, lenp, sizep, typep, namep) {
    const program = this.o[pid];
    const attr = this.gl.getActiveUniform(program, index);
    if (!attr) return;
    if (sizep) this.egg.exec.mem32[sizep >> 2] = attr.size;
    if (typep) this.egg.exec.mem32[typep >> 2] = attr.type;
    if (namep && (bufsize > 0)) {
      this.egg.exec.safeWrite(namep, bufsize, attr.name);
    }
  }

  glGetAttachedShaders(pid, max, countp, dstp) {
    const program = this.o[pid];
    const shaders = this.gl.getAttachedShaders(program) || [];
    if (countp) this.egg.exec.mem32[countp >> 2] = shaders.length;
    const cpc = Math.min(shaders.length, max);
    for (let i=0; i<cpc; i++, dstp+=4) {
      let id = this.o.indexOf(shaders[i]);
      if (id < 0) id = 0;
      this.egg.exec.mem32[dstp >> 2] = id;
    }
  }

  glGetAttribLocation(pid, namep) {
    const program = this.o[pid];
    const name = this.egg.exec.readCString(namep);
    return this.gl.getAttribLocation(program, name);
  }

  glGetProgramInfoLog(pid, bufsize, lenp, dstp) {
    const program = this.o[pid];
    const src = this.gl.getProgramInfoLog(program) || "";
    this.egg.exec.mem32[lenp >> 2] = this.egg.exec.safeWrite(dstp, bufsize, src);
  }

  glGetShaderInfoLog(sid, bufsize, lenp, dstp) {
    const shader = this.o[sid];
    const src = this.gl.getShaderInfoLog(shader) || "";
    this.egg.exec.mem32[lenp >> 2] = this.egg.exec.safeWrite(dstp, bufsize, src);
  }

  glGetShaderPrecisionFormat(stype, ptype, rangep, precp) {
    const rsp = this.gl.getShaderPrecisionFormat(stype, ptype);
    if (!rsp) return;
    rangep >>= 2;
    this.egg.exec.mem32[rangep++] = rsp.rangeMin;
    this.egg.exec.mem32[rangep] = rsp.rangeMax;
    this.egg.exec.mem32[precp >> 2] = rsp.precision;
  }

  glGetShaderSource(sid, bufsize, lenp, dstp) {
    const shader = this.o[sid];
    const src = this.gl.getShaderSource(shader) || "";
    this.egg.exec.mem32[lenp >> 2] = this.egg.exec.safeWrite(dstp, bufsize, src);
  }

  glGetUniformLocation(pid, namep) {
    const program = this.o[pid];
    const name = this.egg.exec.readCString(namep);
    const loc = this.gl.getUniformLocation(program, name);
    if (!loc) return 0;
    const id = this.locv.length;
    this.locv.push(loc);
    return id;
  }

  glLinkProgram(pid) {
    const program = this.o[pid];
    this.gl.linkProgram(program);
  }

  glShaderBinary(count, dstp, bfmt, src, srcc) {
    // GL_APICALL void GL_APIENTRY glShaderBinary (GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length);
    // Evidently there is no such thing in WebGL.
  }

  glShaderSource(sid, count, stringsp, lensp) {
    const shader = this.o[sid];
    let glsl = "";
    stringsp >>= 2;
    lensp >>= 2;
    for (let i=0; i<count; i++, stringsp++, lensp++) {
      const srcp = this.egg.exec.mem32[stringsp];
      const srcc = this.egg.exec.mem32[lensp];
      const sub = this.egg.exec.readLimitedString(srcp, srcc);
      glsl += sub;
    }
    this.gl.shaderSource(shader, glsl);
  }

  glUseProgram(a) {
    this.gl.useProgram(this.o[a]);
  }

  glValidateProgram(a) {
    this.gl.validateProgram(this.o[a]);
  }
  
  /* Generic parameters.
   ******************************************************************************/
   
  paramAsInts(src) {
    if (!src) return [0];
    if (typeof(src) === "number") return [~~src];
    const p = this.o.indexOf(src);
    if (p > 0) return [p];
    if (src.length) return src.map(v => ~~v);
    return [0];
  }
  
  paramAsFloats(src) {
    if (!src) return [0];
    if (typeof(src) === "number") return [src];
    if (src.length) return src;
    return [0];
  }
  
  paramAsString(src) {
    if (!src) return "";
    if (typeof(src) === "string") return src;
    return "";
  }

  glGetBooleanv(pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getParameter(pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetIntegerv(pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getParameter(pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetFloatv(pname, dstp) {
    const rsp = this.paramAsFloats(this.gl.getParameter(pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.memf32[dstp] = rsp[i];
    }
  }
  
  glGetString(pname) {
    const rsp = this.paramAsString(this.gl.getParameter(pname));
    this.egg.exec.safeWrite(this.glstrp, this.glstra, rsp + "\0");
    return this.glstrp;
  }

  glGetBufferParameteriv(target, pname, dstp) {
    // Every defined field is a single int.
    const rsp = this.gl.getBufferParameter(target, pname);
    this.egg.exec.mem32[dstp >> 2] = rsp;
  }

  glGetFramebufferAttachmentParameteriv(target, attachment, pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getFramebufferAttachmentParameter(target, attachment, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetProgramiv(pid, pname, dstp) {
    // Every defined field is a single int.
    const program = this.o[pid];
    const rsp = this.gl.getProgramParameter(program, pname);
    this.egg.exec.mem32[dstp >> 2] = rsp;
  }

  glGetRenderbufferParameteriv(target, pname, dstp) {
    // Every defined field is a single int.
    const rsp = this.gl.getRenderbufferParameter(target, pname);
    this.egg.exec.mem32[dstp >> 2] = rsp;
  }

  glGetShaderiv(sid, pname, dstp) {
    // Every defined field is a single int.
    const shader = this.o[sid];
    const rsp = this.gl.getShaderParameter(shader, pname);
    this.egg.exec.mem32[dstp >> 2] = rsp;
  }

  glGetTexParameterfv(target, pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getTexParameter(target, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.memf32[dstp] = rsp[i];
    }
  }

  glGetTexParameteriv(target, pname, dstp) {
    const rsp = this.paramAsFloats(this.gl.getTexParameter(target, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetUniformfv(pid, id, dstp) {
    const program = this.o[pid];
    const rsp = this.paramAsFloats(this.gl.getUniform(program, this.locv[id]));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.memf32[dstp] = rsp[i];
    }
  }

  glGetUniformiv(pid, id, dstp) {
    const program = this.o[pid];
    const rsp = this.paramAsInts(this.gl.getUniform(program, this.locv[id]));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetVertexAttribfv(index, pname, dstp) {
    const rsp = this.paramAsFloats(this.gl.getVertexAttrib(index, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.memf32[dstp] = rsp[i];
    }
  }

  glGetVertexAttribiv(index, pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getVertexAttrib(index, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetVertexAttribPointerv(index, pname, dstp) {
    const offset = this.gl.getVertexAttribOffset(index, pname);
    this.egg.exec.mem32[dstp >> 2] = offset;
  }

  glTexParameterfv(target, pname, srcp) {
    // No defined texture field uses a vector.
    this.gl.texParameterf(target, pname, this.egg.exec.memf32[srcp >> 2]);
  }

  glTexParameteriv(target, pname, srcp) {
    // No defined texture field uses a vector.
    this.gl.texParameteri(target, pname, this.egg.exec.mem32[srcp >> 2]);
  }

  glUniform1fv(id, c, p) {
    this.gl.uniform1fv(this.locv[id], this.egg.exec.memf32.slice(p >> 2, c));
  }

  glUniform1iv(id, c, p) {
    this.gl.uniform1iv(this.locv[id], this.egg.exec.mem32.slice(p >> 2, c));
  }

  glUniform2fv(id, c, p) {
    this.gl.uniform2fv(this.locv[id], this.egg.exec.memf32.slice(p >> 2, c * 2)); 
  }

  glUniform2iv(id, c, p) {
    this.gl.uniform2iv(this.locv[id], this.egg.exec.mem32.slice(p >> 2, c * 2));
  }

  glUniform3fv(id, c, p) {
    this.gl.uniform3fv(this.locv[id], this.egg.exec.memf32.slice(p >> 2, c * 3)); 
  }

  glUniform3iv(id, c, p) {
    this.gl.uniform3iv(this.locv[id], this.egg.exec.mem32.slice(p >> 2, c * 3));
  }

  glUniform4fv(id, c, p) {
    this.gl.uniform4fv(this.locv[id], this.egg.exec.memf32.slice(p >> 2, c * 4)); 
  }

  glUniform4iv(id, c, p) {
    this.gl.uniform4iv(this.locv[id], this.egg.exec.mem32.slice(p >> 2, c * 4));
  }

  glUniformMatrix2fv(id, c, trans, p) {
    this.gl.uniformMatrix2fv(this.locv[id], trans, this.egg.exec.memf32.slice(p >> 2, c * 4));
  }

  glUniformMatrix3fv(id, c, trans, p) {
    this.gl.uniformMatrix3fv(this.locv[id], trans, this.egg.exec.memf32.slice(p >> 2, c * 9));
  }

  glUniformMatrix4fv(id, c, trans, p) {
    this.gl.uniformMatrix4fv(this.locv[id], trans, this.egg.exec.memf32.slice(p >> 2, c * 16));
  }

  glVertexAttrib1fv(index, p) {
    this.gl.vertexAttrib1fv(index, this.egg.exec.memf32.slice(p >> 2, 1));
  }

  glVertexAttrib2fv(index, p) {
    this.gl.vertexAttrib2fv(index, this.egg.exec.memf32.slice(p >> 2, 2));
  }

  glVertexAttrib3fv(index, p) {
    this.gl.vertexAttrib3fv(index, this.egg.exec.memf32.slice(p >> 2, 3));
  }

  glVertexAttrib4fv(index, p) {
    this.gl.vertexAttrib4fv(index, this.egg.exec.memf32.slice(p >> 2, 4));
  }

  glVertexAttribPointer(index, size, type, norm, stride, p) {
    //TODO WebGL (p) is an offset in the bound vbo. GLES2 it can be an absolute pointer in client memory.
    this.gl.vertexAttribPointer(index, size, type, norm, stride, p);
  }
  
  /* Image operations.
   ****************************************************************************/
   
  measureImage(w, h, fmt, type) {
    if ((w < 1) || (w > 4096)) return 0;
    if ((h < 1) || (h > 4096)) return 0;
    let chanc = 0;
    switch (fmt) {
      case this.gl.STENCIL_INDEX8:
      case this.gl.DEPTH_COMPONENT:
      case this.gl.LUMINANCE:
      case this.gl.ALPHA: chanc=1; break;
      case this.gl.LUMINANCE_ALPHA: chanc=2; break;
      case this.gl.RGB: chanc=3; break;
      case this.gl.RGBA: chanc=4; break;
    }
    if (chanc < 1) return 0;
    let wordlen = 0;
    switch (type) {
      case this.gl.UNSIGNED_BYTE:
      case this.gl.BYTE:
        wordlen=1;
        break;
      case this.gl.UNSIGNED_SHORT:
      case this.gl.SHORT:
      case this.gl.UNSIGNED_SHORT_5_6_5:
      case this.gl.UNSIGNED_SHORT_4_4_4_4:
      case this.gl.UNSIGNED_SHORT_5_5_5_1:
        wordlen=2;
        break;
      case this.gl.UNSIGNED_INT:
      case this.gl.INT:
      case this.gl.FLOAT:
        wordlen=4;
        break;
    }
    if (wordlen < 1) return 0;
    return wordlen * chanc * w * h;
  }

  glCompressedTexImage2D(target, level, ifmt, w, h, border, size, srcp) {
    const src = this.egg.exec.getView(srcp, size);
    if (!src) return;
    this.gl.compressedTexImage2D(target, level, ifmt, w, h, border, src);
  }

  glCompressedTexSubImage2D(target, level, xo, yo, w, h, fmt, size, srcp) {
    const src = this.egg.exec.getView(srcp, size);
    if (!src) return;
    this.gl.compressedTexImage2D(target, level, xo, yo, w, h, fmt, src);
  }

  glCopyTexImage2D(target, level, ifmt, x, y, w, h, border) {
    this.gl.copyTexImage2D(target, level, ifmt, x, y, w, h, border);
  }

  glCopyTexSubImage2D(target, level, xo, yo, x, y, w, h) {
    this.gl.copyTexSubImage2D(target, level, xo, yo, x, y, w, h);
  }

  glReadPixels(x, y, w, h, fmt, type, dstp) {
    const len = this.measureImage(w, h, fmt, type);
    if (len < 1) return;
    const dst = this.egg.exec.getView(dstp, len);
    if (!dst) return;
    this.gl.readPixels(x, y, w, h, fmt, type, dst);
  }

  glTexImage2D(target, level, ifmt, w, h, border, fmt, type, srcp) {
    const len = this.measureImage(w, h, fmt, type);
    if (len < 1) return;
    const src = this.egg.exec.getView(srcp, len);
    if (!src) return;
    this.gl.texImage2D(target, level, ifmt, w, h, border, fmt, type, src);
  }

  glTexSubImage2D(target, level, xo, yo, w, h, fmt, type, srcp) {
    const len = this.measureImage(w, h, fmt, type);
    if (len < 1) return;
    const src = this.egg.exec.getView(srcp, len);
    if (!src) return;
    this.gl.texSubImage2D(target, level, xo, yo, w, h, fmt, type, src);
  }

}
class Rom {
  constructor(src) {
    this.resv = []; // {tid,qual,rid,v:Uint8Array}, sorted
    this.decode(src);
  }
  
  getRes(tid, qual, rid) {
    let lo=0, hi=this.resv.length;
    while (lo < hi) {
      const ck = (lo + hi) >> 1;
      const q = this.resv[ck];
           if (tid < q.tid) hi = ck;
      else if (tid > q.tid) lo = ck + 1;
      else if (qual < q.qual) hi = ck;
      else if (qual > q.qual) lo = ck + 1;
      else if (rid < q.rid) hi = ck;
      else if (rid > q.rid) lo = ck + 1;
      else return q.v;
    }
    return this.empty;
  }
  
  decode(src) {
    let tid=1, qual=0, rid=1, i=0;
    const rdch = () => {
      let ch;
      for (;;) {
        ch = src.charCodeAt(i++);
        if (ch > 0x20) return ch;
        if (i >= src.length) return 0;
      }
    };
    const rdn = () => {
      let n=0;
      while (i < src.length) {
        const ch = rdch();
        if (!ch) break;
        if ((ch >= 0x30) && (ch <= 0x39)) { n <<= 4; n |= ch - 0x30; continue; }
        if ((ch >= 0x61) && (ch <= 0x66)) { n <<= 4; n |= ch - 0x61 + 10; continue; }
        if ((ch >= 0x41) && (ch <= 0x46)) { n <<= 4; n |= ch - 0x41 + 10; continue; }
        i--;
        break;
      }
      return n;
    };
    while (i < src.length) {
      const cmd = rdch();
      if (!cmd) break;
      switch (cmd) {
        case 0x74: tid += rdn() + 1; qual = 0; rid = 1; break;
        case 0x71: qual += rdn() + 1; rid = 1; break;
        case 0x73: rid += rdn() + 1; break;
        case 0x72: {
            if ((tid > 0x63) || (qual > 0x3ff) || (rid > 0xffff)) {
              throw new Error(`Invalid res id ${tid}:${qual}:${rid} around ${i}/${src.length} in ROM`);
            }
            const len = rdn();
            const body = new Uint8Array(len);
            let bodyp = 0;
            if (rdch() !== 0x28) throw new Error(`Expected '(' around ${i}/${src.length} in ROM`);
            const buf = [];
            for (;;) {
              const ch = rdch();
              if (ch === 0x29) break;
              if (!ch) throw new Error(`Unclosed resource body`);
                   if ((ch >= 0x41) && (ch <= 0x5a)) buf.push(ch - 0x41);
              else if ((ch >= 0x61) && (ch <= 0x7a)) buf.push(ch - 0x61 + 26);
              else if ((ch >= 0x30) && (ch <= 0x39)) buf.push(ch - 0x30 + 52);
              else if (ch === 0x2b) buf.push(62);
              else if (ch === 0x2f) buf.push(63);
              else throw new Error(`Expected ')' or base64 digit, found ${ch} (${i}/${src.length})`);
              if (buf.length >= 4) {
                body[bodyp++] = (buf[0] << 2) | (buf[1] >> 4);
                body[bodyp++] = (buf[1] << 4) | (buf[2] >> 2);
                body[bodyp++] = (buf[2] << 6) | buf[3];
                buf.splice(0, 4);
              }
            }
            body[bodyp++] = (buf[0] << 2) | (buf[1] >> 4);
            body[bodyp++] = (buf[1] << 4) | (buf[2] >> 2);
            body[bodyp++] = (buf[2] << 6) | buf[3];
            this.resv.push({ tid, qual, rid, v: body });
            rid++;
          } break;
        default: throw new Error(`Unexpected command '${cmd}' around ${i-1}/${src.length} in ROM`);
      }
    }
  }
}

Rom.RESTYPE_metadata = 1;
Rom.RESTYPE_wasm = 2;
Rom.RESTYPE_string = 3;
Rom.RESTYPE_image = 4;
Rom.RESTYPE_song = 5;
Rom.RESTYPE_sound = 6;
/* SfgPrinter.js
 * Produce PCM dumps from our tiny binary sound format.
 *
 * Unlike our C counterpart, we run completely synchronously.
 * That's because in WebAudio you don't get intimate access to the signal generator,
 * what we use to time and pay out printing in C.
 * Printing is not trivial. There's a real possibility of missing video frames due to sound effects being printed.
 *
 * It's written as a class to keep things flexible.
 * But typical usage is a one-shot kind of deal:
 *   const myPcm = new SfgPrinter(serial).print();
 * Uint8Array in, Float32Array out.
 */
 
class SfgPrinter {
  constructor(src, rate) {
    if (!(src instanceof Uint8Array)) throw new Error(`Expected Uint8Array`);
    if (!rate || (rate < 200) || (rate > 200000)) throw new Error(`Invalid rate for SfgPrinter`);
    this.src = src;
    this.rate = rate;
    this.dst = null; // Float32Array
  }
  
  print() {
    if (!this.dst) this._print();
    return this.dst;
  }
  
  /* Private below this point.
   */
  
  _print() {
    if (this.src.length < 6) throw new Error(`Invalid SFG`);
    if ((this.src[0] !== 0xeb) || (this.src[1] !== 0xeb)) throw new Error("Invalid SFG");
    const durms = (this.src[2] << 8) | this.src[3];
    const durframes = Math.max(1, Math.round(durms * this.rate / 1000));
    const master = this.src[4] + this.src[5] / 256.0;
    this.dst = new Float32Array(durframes);
    const tmp = new Float32Array(durframes);
    // Add one voice at a time to (this.dst).
    // Unlike the C implementation, we're synchronous, so we kind of process everything as we read it.
    for (let srcp=6; srcp<this.src.length; ) {
      const np = this._printVoice(tmp, srcp);
      if (!np || (np <= srcp)) throw new Error(`PCM print stalled at ${srcp}/${this.src.length}`);
      srcp = np;
      for (let i=durframes; i-->0; ) this.dst[i] += tmp[i];
    }
    // Apply master level.
    for (let i=durframes; i-->0; ) this.dst[i] *= master;
  }
  
  // Overwrite (dst), and return new (srcp).
  _printVoice(dst, srcp) {
    const waveSizeBits = 10;
    const waveSizeSamples = 1 << waveSizeBits;

    const features = this.src[srcp++];
    
    let wave = null; // Float32Array(waveSizeSamples) | "noise" | "silence"
    if (features & 0x01) { // shape
      switch (this.src[srcp++]) {
        case 0: wave = this._printSine(waveSizeSamples); break;
        case 1: wave = this._printSquare(waveSizeSamples); break;
        case 2: wave = this._printSawup(waveSizeSamples); break;
        case 3: wave = this._printSawdown(waveSizeSamples); break;
        case 4: wave = this._printTriangle(waveSizeSamples); break;
        case 5: wave = "noise"; break;
        case 6: wave = "silence"; break;
        default: throw new Error(`Unknown wave shape ${this.src[srcp-1]}`);
      }
    } else {
      wave = this._printSine(waveSizeSamples);
    }
    
    if (features & 0x02) { // harmonics
      const coefc = this.src[srcp++];
      if (wave instanceof Float32Array) {
        const nwave = new Float32Array(waveSizeSamples);
        for (let step=1; step<=coefc; step++) {
          this._printHarmonic(nwave, wave, step, this.src[srcp++] / 255.0);
        }
        wave = nwave;
      } else {
        // harmonics is meaningless for noise or silence, but it is technically legal. skip it.
        srcp += coefc;
      }
    }
    
    let fmrate = 0;
    let fmscale = 0;
    if (features & 0x04) { // fm
      fmrate = this.src[srcp] + this.src[srcp+1] / 256.0; srcp += 2;
      fmscale = this.src[srcp] + this.src[srcp+1] / 256.0; srcp += 2;
      fmrate *= Math.PI * 2;
    }
    
    const fmrange = {};
    if (features & 0x08) { // fmenv
      srcp = this._decodeEnv(fmrange, srcp, fmscale / 65535.0);
    } else {
      this._constantEnv(fmrange, fmscale);
    }
    
    const rate = {};
    if (features & 0x10) { // rate
      srcp = this._decodeEnv(rate, srcp, 1 / this.rate);
    } else {
      this._constantEnv(rate, 440 / this.rate);
    }
    
    let ratelforate = 0;
    let ratelfodepth = 0;
    if (features & 0x20) { // ratelfo
      const rate = this.src[srcp] + this.src[srcp+1] / 256.0; srcp += 2; // hz
      const depth = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2; // cents
      ratelforate = (rate * Math.PI * 2) / this.rate; // radians/frame
      ratelfodepth = depth / 1200; // power of 2
    }
    
    if (features & 0xc0) throw new Error(`Unknown features (0x${(features & 0xc0).toString(16)}) in voice`);
    
    /* We now have everything we need for the oscillator.
     * Run it to completion, overwriting (dst).
     */
    if (wave === "silence") {
      for (let i=dst.length; i-->0; ) dst[i] = 0;
    } else if (wave === "noise") {
      for (let i=dst.length; i-->0; ) dst[i] = Math.random() * 2 - 1;
    } else { //TODO Opportunities here to run simpler oscillators, eg if rate LFO or FM not in play. See sfg_update.c
      this._oscillateFull(
        dst, wave, rate, ratelforate, ratelfodepth, fmrate, fmrange
      );
    }
    
    /* Process all positional operations individually.
     */
    while (srcp < this.src.length) {
      const opcode = this.src[srcp++];
      if (!opcode) break; // End Of Voice
      switch (opcode) {
        case 0x01: srcp = this._printOpLevel(dst, srcp); break;
        case 0x02: srcp = this._printOpGain(dst, srcp); break;
        case 0x03: srcp = this._printOpClip(dst, srcp); break;
        case 0x04: srcp = this._printOpDelay(dst, srcp); break;
        case 0x05: srcp = this._printOpBandpass(dst, srcp); break;
        case 0x06: srcp = this._printOpNotch(dst, srcp); break;
        case 0x07: srcp = this._printOpLopass(dst, srcp); break;
        case 0x08: srcp = this._printOpHipass(dst, srcp); break;
        default: throw new Error(`Unknown voice op ${opcode}`);
      }
    }
  
    return srcp;
  }
  
  /* Oscillator.
   */
   
  _oscillateFull(dst, wave, rate, ratelforate, ratelfodepth, fmrate, fmrange) {
    for (let i=0, ratelfop=0, modp=0, carp=0; i<dst.length; i++) {
  
      // Acquire carrier rate.
      let crate = this._updateEnv(rate);
      crate *= Math.pow(2, Math.sin(ratelfop) * ratelfodepth);
      ratelfop += ratelforate;
      if (ratelfop >= Math.PI) ratelfop -= Math.PI * 2;
    
      // Acquire modulation.
      let mod = Math.sin(modp);
      mod *= this._updateEnv(fmrange);
      modp += crate * fmrate;
      if (modp >= Math.PI) modp -= Math.PI * 2;
    
      // Acquire sample and advance carrier.
      const sp = Math.floor(carp * wave.length);
      dst[i] = wave[sp] || 0;
      crate += crate * mod;
      carp += crate;
      while (carp >= 1) carp -= 1;
      while (carp < 0) carp += 1;
    }
  }
  
  /* Positional ops.
   * These all read from (this.src) and return the new position.
   */
  
  _printOpLevel(dst, srcp) {
    const env = {};
    srcp = this._decodeEnv(env, srcp, 1 / 65535.0);
    let lo=dst[0], hi=dst[0];
    for (let i=dst.length; i-->0; ) {
      if (dst[i]<lo) lo=dst[i];
      else if (dst[i]>hi) hi=dst[i];
    }
    for (let i=0; i<dst.length; i++) {
      dst[i] *= this._updateEnv(env);
    }
    return srcp;
  }
  
  _printOpGain(dst, srcp) {
    const gain = this.src[srcp] + this.src[srcp+1] / 256.0; srcp += 2;
    for (let i=dst.length; i-->0; ) {
      dst[i] *= gain;
    }
    return srcp;
  }
  
  _printOpClip(dst, srcp) {
    const hi = this.src[srcp++] / 255.0;
    const lo = -hi;
    for (let i=dst.length; i-->0; ) {
      const v = dst[i];
      if (v > hi) dst[i] = hi;
      else if (v < lo) dst[i] = lo;
    }
    return srcp;
  }
  
  _printOpDelay(dst, srcp) {
    const ms = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2;
    const period = Math.ceil((ms * this.rate) / 1000);
    if (isNaN(period) || (period < 1)) return srcp + 4;
    const buf = new Float32Array(period);
    let bufp = 0;
    const dry = this.src[srcp++] / 255.0;
    const wet = this.src[srcp++] / 255.0;
    const sto = this.src[srcp++] / 255.0;
    const fbk = this.src[srcp++] / 255.0;
    for (let i=0; i<dst.length; i++) {
      const next = dst[i];
      const prev = buf[bufp];
      dst[i] = next * dry + prev * wet;
      buf[bufp] = next * sto + prev * fbk;
      if (++bufp >= period) bufp = 0;
    }
    return srcp;
  }
  
  _printOpBandpass(dst, srcp) {
    const mid = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const wid = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const r = 1 - 3 * wid;
    const cosfreq = Math.cos(Math.PI * 2 * mid);
    const k = (1 - 2 * r * cosfreq + r * r) / (2 - 2 * cosfreq);
    const coefv = [
      1 - k,
      2 * (k - r) * cosfreq,
      r * r - k,
      2 * r * cosfreq,
      -r * r,
    ];
    this._applyIir(dst, coefv);
    return srcp;
  }
  
  _printOpNotch(dst, srcp) {
    const mid = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const wid = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const r = 1 - 3 * wid;
    const cosfreq = Math.cos(Math.PI * 2 * mid);
    const k = (1 - 2 * r * cosfreq + r * r) / (2 - 2 * cosfreq);
    const coefv = [
      k,
      -2 * k * cosfreq,
      k,
      2 * r * cosfreq,
      -r * r,
    ];
    this._applyIir(dst, coefv);
    return srcp;
  }
  
  _printOpLopass(dst, srcp) {
    const freq = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const rp = -Math.cos(Math.PI / 2);
    const ip = Math.sin(Math.PI / 2);
    const t = 2 * Math.tan(0.5);
    const w = 2 * Math.PI * freq;
    const m = rp * rp + ip * ip;
    const d = 4 - 4 * rp * t + m * t * t;
    const x0 = (t * t) / d;
    const x1 = (2 * t * t) / d;
    const x2 = (t * t) / d;
    const y1 = (8 - 2 * m * t * t) / d;
    const y2 = (-4 - 4 * rp * t - m * t * t) / d;
    const k = Math.sin(0.5 - w / 2) / Math.sin(0.5 + w / 2);
    const coefv = [
      (x0 - x1 * k + x2 * k * k) / d,
      (-2 * x0 * k + x1 + x1 * k * k - 2 * x2 * k) / d,
      (x0 * k * k - x1 * k + x2) / d,
      (2 * k + y1 + y1 * k * k - 2 * y2 * k) / d,
      (-k * k - y1 * k + y2) / d,
    ];
    this._applyIir(dst, coefv);
    return srcp;
  }
  
  _printOpHipass(dst, srcp) {
    const freq = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const rp = -Math.cos(Math.PI / 2);
    const ip = Math.sin(Math.PI / 2);
    const t = 2 * Math.tan(0.5);
    const w = 2 * Math.PI * freq;
    const m = rp * rp + ip * ip;
    const d = 4 - 4 * rp * t + m * t * t;
    const x0 = (t * t) / d;
    const x1 = (2 * t * t) / d;
    const x2 = (t * t) / d;
    const y1 = (8 - 2 * m * t * t) / d;
    const y2 = (-4 - 4 * rp * t - m * t * t) / d;
    const k = -Math.cos(w / 2 + 0.5) / Math.cos(w / 2 - 0.5);
    const coefv = [
      -(x0 - x1 * k + x2 * k * k) / d,
      (-2 * x0 * k + x1 + x1 * k * k - 2 * x2 * k) / d,
      (x0 * k * k - x1 * k + x2) / d,
      -(2 * k + y1 + y1 * k * k - 2 * y2 * k) / d,
      (-k * k - y1 * k + y2) / d,
    ];
    this._applyIir(dst, coefv);
    return srcp;
  }
  
  _applyIir(dst, coefv) {
    const statev = [0, 0, 0, 0, 0];
    for (let i=0; i<dst.length; i++) {
      statev[2]=statev[1];
      statev[1]=statev[0];
      statev[0]=dst[i];
      dst[i]=(
        statev[0]*coefv[0]+
        statev[1]*coefv[1]+
        statev[2]*coefv[2]+
        statev[3]*coefv[3]+
        statev[4]*coefv[4]
      );
      statev[4]=statev[3];
      statev[3]=dst[i];
    }
  }
  
  /* Envelopes.
   * Decode into a blank object.
   * Values are in 0..65535 if you don't scale. (eg 1/65535 to normalize)
   */
   
  _decodeEnv(env, srcp, scale) {
    env.v0 = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2;
    env.v0 *= scale;
    const pointc = this.src[srcp++];
    if (isNaN(pointc) || (srcp > this.src.length - pointc * 4)) throw new Error(`Envelope overruns EOF`);
    env.pointv = [];
    for (let i=pointc; i-->0; ) {
      const ms = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2;
      const t = Math.max(1, Math.round(ms * this.rate / 1000));
      let v = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2;
      v *= scale;
      env.pointv.push({ t, v });
    }
    env.pointp = 0;
    env.v = env.v0;
    if (pointc > 0) {
      env.ttl = env.pointv[0].t;
      env.dv = (env.pointv[0].v - env.v) / env.ttl;
    } else {
      env.ttl = 0x7fffffff;
      env.dv = 0;
    }
    return srcp;
  }
  
  _constantEnv(env, k) {
    env.v0 = k;
    env.v = k;
    env.ttl = 0x7fffffff;
    env.dv = 0;
    env.pointv = [];
    env.pointp = 0;
  }
  
  _updateEnv(env) {
    if (env.ttl-- > 0) {
      env.v += env.dv;
    } else {
      env.pointp++;
      if (env.pointp >= env.pointv.length) {
        env.pointp = env.pointv.length;
        env.dv = 0;
        env.ttl = 0x7fffffff;
        if (env.pointv.length) env.v = env.pointv[env.pointv.length-1].v;
        else env.v = env.v0;
      } else {
        env.v = env.pointv[env.pointp-1].v;
        env.ttl = env.pointv[env.pointp].t;
        env.dv = (env.pointv[env.pointp].v - env.v) / env.ttl;
      }
    }
    return env.v;
  }
  
  /* Wave generators.
   */
          
  _printSine(len) {
    const dst = new Float32Array(len);
    for (let i=0, p=0, dp=Math.PI*2/len; i<dst.length; i++, p+=dp) {
      dst[i] = Math.sin(p);
    }
    return dst;
  }
  
  _printSquare(len) {
    const dst = new Float32Array(len);
    const halflen = len >> 1;
    for (let i=halflen; i-->0; ) dst[i] = 1;
    for (let i=halflen; i<dst.length; i++) dst[i] = -1;
    return dst;
  }
  
  _printSawup(len) {
    const dst = new Float32Array(len);
    for (let i=0, p=-1, dp=2/len; i<dst.length; i++, p+=dp) {
      dst[i] = p;
    }
    return dst;
  }
  
  _printSawdown(len) {
    const dst = new Float32Array(len);
    for (let i=0, p=1, dp=-2/len; i<dst.length; i++, p+=dp) {
      dst[i] = p;
    }
    return dst;
  }
  
  _printTriangle(len) {
    const dst = new Float32Array(len);
    const halflen = len >> 1;
    for (let i=0, p=-1, dp=2/halflen; i<halflen; i++, p+=dp) {
      dst[i] = p;
    }
    for (let i=halflen, p=1, dp=-2/halflen; i<dst.length; i++, p+=dp) {
      dst[i] = p;
    }
    return dst;
  }
  
  _printHarmonic(dst, src, step, level) {
    if (level <= 0) return;
    for (let dstp=0, srcp=0; dstp<dst.length; dstp++, srcp+=step) {
      if (srcp >= src.length) srcp -= src.length;
      dst[dstp] += src[srcp] * level;
    }
  }
}
/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
// https://github.com/imaya/zlib.js
(function() {'use strict';var l=void 0,aa=window;function r(c,d){var a=c.split("."),b=aa;!(a[0]in b)&&b.execScript&&b.execScript("var "+a[0]);for(var e;a.length&&(e=a.shift());)!a.length&&d!==l?b[e]=d:b=b[e]?b[e]:b[e]={}};var t="undefined"!==typeof Uint8Array&&"undefined"!==typeof Uint16Array&&"undefined"!==typeof Uint32Array&&"undefined"!==typeof DataView;function v(c){var d=c.length,a=0,b=Number.POSITIVE_INFINITY,e,f,g,h,k,m,n,p,s,x;for(p=0;p<d;++p)c[p]>a&&(a=c[p]),c[p]<b&&(b=c[p]);e=1<<a;
f=new (t?Uint32Array:Array)(e);g=1;h=0;for(k=2;g<=a;){for(p=0;p<d;++p)if(c[p]===g){m=0;n=h;for(s=0;s<g;++s)m=m<<1|n&1,n>>=1;x=g<<16|p;for(s=m;s<e;s+=k)f[s]=x;++h}++g;h<<=1;k<<=1}return[f,a,b]};function w(c,d){this.g=[];this.h=32768;this.d=this.f=this.a=this.l=0;this.input=t?new Uint8Array(c):c;this.m=!1;this.i=y;this.r=!1;if(d||!(d={}))d.index&&(this.a=d.index),d.bufferSize&&(this.h=d.bufferSize),d.bufferType&&(this.i=d.bufferType),d.resize&&(this.r=d.resize);switch(this.i){case A:this.b=32768;
this.c=new (t?Uint8Array:Array)(32768+this.h+258);break;case y:this.b=0;this.c=new (t?Uint8Array:Array)(this.h);this.e=this.z;this.n=this.v;this.j=this.w;break;default:throw Error("invalid inflate mode");
}}var A=0,y=1,B={t:A,s:y};
w.prototype.k=function(){for(;!this.m;){var c=C(this,3);c&1&&(this.m=!0);c>>>=1;switch(c){case 0:var d=this.input,a=this.a,b=this.c,e=this.b,f=d.length,g=l,h=l,k=b.length,m=l;this.d=this.f=0;if(a+1>=f)throw Error("invalid uncompressed block header: LEN");g=d[a++]|d[a++]<<8;if(a+1>=f)throw Error("invalid uncompressed block header: NLEN");h=d[a++]|d[a++]<<8;if(g===~h)throw Error("invalid uncompressed block header: length verify");if(a+g>d.length)throw Error("input buffer is broken");switch(this.i){case A:for(;e+
g>b.length;){m=k-e;g-=m;if(t)b.set(d.subarray(a,a+m),e),e+=m,a+=m;else for(;m--;)b[e++]=d[a++];this.b=e;b=this.e();e=this.b}break;case y:for(;e+g>b.length;)b=this.e({p:2});break;default:throw Error("invalid inflate mode");}if(t)b.set(d.subarray(a,a+g),e),e+=g,a+=g;else for(;g--;)b[e++]=d[a++];this.a=a;this.b=e;this.c=b;break;case 1:this.j(ba,ca);break;case 2:for(var n=C(this,5)+257,p=C(this,5)+1,s=C(this,4)+4,x=new (t?Uint8Array:Array)(D.length),S=l,T=l,U=l,u=l,M=l,F=l,z=l,q=l,V=l,q=0;q<s;++q)x[D[q]]=
C(this,3);if(!t){q=s;for(s=x.length;q<s;++q)x[D[q]]=0}S=v(x);u=new (t?Uint8Array:Array)(n+p);q=0;for(V=n+p;q<V;)switch(M=E(this,S),M){case 16:for(z=3+C(this,2);z--;)u[q++]=F;break;case 17:for(z=3+C(this,3);z--;)u[q++]=0;F=0;break;case 18:for(z=11+C(this,7);z--;)u[q++]=0;F=0;break;default:F=u[q++]=M}T=t?v(u.subarray(0,n)):v(u.slice(0,n));U=t?v(u.subarray(n)):v(u.slice(n));this.j(T,U);break;default:throw Error("unknown BTYPE: "+c);}}return this.n()};
var G=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],D=t?new Uint16Array(G):G,H=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],I=t?new Uint16Array(H):H,J=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],K=t?new Uint8Array(J):J,L=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],da=t?new Uint16Array(L):L,ea=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,
13,13],N=t?new Uint8Array(ea):ea,O=new (t?Uint8Array:Array)(288),P,fa;P=0;for(fa=O.length;P<fa;++P)O[P]=143>=P?8:255>=P?9:279>=P?7:8;var ba=v(O),Q=new (t?Uint8Array:Array)(30),R,ga;R=0;for(ga=Q.length;R<ga;++R)Q[R]=5;var ca=v(Q);function C(c,d){for(var a=c.f,b=c.d,e=c.input,f=c.a,g=e.length,h;b<d;){if(f>=g)throw Error("input buffer is broken");a|=e[f++]<<b;b+=8}h=a&(1<<d)-1;c.f=a>>>d;c.d=b-d;c.a=f;return h}
function E(c,d){for(var a=c.f,b=c.d,e=c.input,f=c.a,g=e.length,h=d[0],k=d[1],m,n;b<k&&!(f>=g);)a|=e[f++]<<b,b+=8;m=h[a&(1<<k)-1];n=m>>>16;if(n>b)throw Error("invalid code length: "+n);c.f=a>>n;c.d=b-n;c.a=f;return m&65535}
w.prototype.j=function(c,d){var a=this.c,b=this.b;this.o=c;for(var e=a.length-258,f,g,h,k;256!==(f=E(this,c));)if(256>f)b>=e&&(this.b=b,a=this.e(),b=this.b),a[b++]=f;else{g=f-257;k=I[g];0<K[g]&&(k+=C(this,K[g]));f=E(this,d);h=da[f];0<N[f]&&(h+=C(this,N[f]));b>=e&&(this.b=b,a=this.e(),b=this.b);for(;k--;)a[b]=a[b++-h]}for(;8<=this.d;)this.d-=8,this.a--;this.b=b};
w.prototype.w=function(c,d){var a=this.c,b=this.b;this.o=c;for(var e=a.length,f,g,h,k;256!==(f=E(this,c));)if(256>f)b>=e&&(a=this.e(),e=a.length),a[b++]=f;else{g=f-257;k=I[g];0<K[g]&&(k+=C(this,K[g]));f=E(this,d);h=da[f];0<N[f]&&(h+=C(this,N[f]));b+k>e&&(a=this.e(),e=a.length);for(;k--;)a[b]=a[b++-h]}for(;8<=this.d;)this.d-=8,this.a--;this.b=b};
w.prototype.e=function(){var c=new (t?Uint8Array:Array)(this.b-32768),d=this.b-32768,a,b,e=this.c;if(t)c.set(e.subarray(32768,c.length));else{a=0;for(b=c.length;a<b;++a)c[a]=e[a+32768]}this.g.push(c);this.l+=c.length;if(t)e.set(e.subarray(d,d+32768));else for(a=0;32768>a;++a)e[a]=e[d+a];this.b=32768;return e};
w.prototype.z=function(c){var d,a=this.input.length/this.a+1|0,b,e,f,g=this.input,h=this.c;c&&("number"===typeof c.p&&(a=c.p),"number"===typeof c.u&&(a+=c.u));2>a?(b=(g.length-this.a)/this.o[2],f=258*(b/2)|0,e=f<h.length?h.length+f:h.length<<1):e=h.length*a;t?(d=new Uint8Array(e),d.set(h)):d=h;return this.c=d};
w.prototype.n=function(){var c=0,d=this.c,a=this.g,b,e=new (t?Uint8Array:Array)(this.l+(this.b-32768)),f,g,h,k;if(0===a.length)return t?this.c.subarray(32768,this.b):this.c.slice(32768,this.b);f=0;for(g=a.length;f<g;++f){b=a[f];h=0;for(k=b.length;h<k;++h)e[c++]=b[h]}f=32768;for(g=this.b;f<g;++f)e[c++]=d[f];this.g=[];return this.buffer=e};
w.prototype.v=function(){var c,d=this.b;t?this.r?(c=new Uint8Array(d),c.set(this.c.subarray(0,d))):c=this.c.subarray(0,d):(this.c.length>d&&(this.c.length=d),c=this.c);return this.buffer=c};function W(c,d){var a,b;this.input=c;this.a=0;if(d||!(d={}))d.index&&(this.a=d.index),d.verify&&(this.A=d.verify);a=c[this.a++];b=c[this.a++];switch(a&15){case ha:this.method=ha;break;default:throw Error("unsupported compression method");}if(0!==((a<<8)+b)%31)throw Error("invalid fcheck flag:"+((a<<8)+b)%31);if(b&32)throw Error("fdict flag is not supported");this.q=new w(c,{index:this.a,bufferSize:d.bufferSize,bufferType:d.bufferType,resize:d.resize})}
W.prototype.k=function(){var c=this.input,d,a;d=this.q.k();this.a=this.q.a;if(this.A){a=(c[this.a++]<<24|c[this.a++]<<16|c[this.a++]<<8|c[this.a++])>>>0;var b=d;if("string"===typeof b){var e=b.split(""),f,g;f=0;for(g=e.length;f<g;f++)e[f]=(e[f].charCodeAt(0)&255)>>>0;b=e}for(var h=1,k=0,m=b.length,n,p=0;0<m;){n=1024<m?1024:m;m-=n;do h+=b[p++],k+=h;while(--n);h%=65521;k%=65521}if(a!==(k<<16|h)>>>0)throw Error("invalid adler-32 checksum");}return d};var ha=8;r("Zlib.Inflate",W);r("Zlib.Inflate.prototype.decompress",W.prototype.k);var X={ADAPTIVE:B.s,BLOCK:B.t},Y,Z,$,ia;if(Object.keys)Y=Object.keys(X);else for(Z in Y=[],$=0,X)Y[$++]=Z;$=0;for(ia=Y.length;$<ia;++$)Z=Y[$],r("Zlib.Inflate.BufferType."+Z,X[Z]);}
).call(window);
/* Render.js
 */
 


 
class Render {
  constructor(egg) {
    this.canvas = egg.canvas;
    this.egg = egg;
    this.gl = this.canvas.getContext("webgl");
    this.webgl = new Webgl(this.egg, this.gl);
    
    // (texid) exposed to client is the index in this array, plus one.
    this.textures = []; // {texid,fbid,w,h,fmt}
  
    this.tint = 0;
    this.alpha = 1;
    this.tr = 0;
    this.tg = 0;
    this.tb = 0;
    this.ta = 0;
  
    this.pgm_raw = null;
    this.pgm_decal = null;
    this.pgm_tile = null;
  
    this.u_raw_screensize = 0;
    this.u_raw_alpha = 0;
    this.u_raw_tint = 0;
    this.u_decal_screensize = 0;
    this.u_decal_sampler = 0;
    this.u_decal_alpha = 0;
    this.u_decal_tint = 0;
    this.u_tile_screensize = 0;
    this.u_tile_sampler = 0;
    this.u_tile_alpha = 0;
    this.u_tile_tint = 0;
    this.u_tile_pointsize = 0;
    
    // Storage for draw_rect, draw_decal, and draw_to_main.
    // Decal is larger, 4 vertices * 12 bytes each.
    this.vbuf = new ArrayBuffer(12 * 4);
    this.vbufu8 = new Uint8Array(this.vbuf);
    this.vbufs16 = new Int16Array(this.vbuf);
    this.vbuff32 = new Float32Array(this.vbuf);
    
    this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA);
    this.gl.enable(this.gl.BLEND);
    if (!(this.buffer = this.gl.createBuffer())) throw new Error(`Failed to create WebGL vertex buffer.`);
    
    if (
      (this.egg_texture_new() !== 1) ||
      (this.egg_texture_upload(1, this.canvas.width, this.canvas.height, this.canvas.width << 2, 1, 0, 0) < 0)
    ) throw new Error(`Failed to create main framebuffer.`);
    
    this.compileShaders();
    
    this.sizeDirty = false;
    this.resizeObserver = new ResizeObserver(e => this.sizeDirty = true);
    this.resizeObserver.observe(this.canvas);
  }
  
  /*---------------------------- Entry points for Egg platform ------------------------------*/
  
  // Notify that the runtime is shutting down.
  stop() {
    this.resizeObserver.disconnect();
    this.egg_draw_rect(1, 0, 0, this.canvas.width, this.canvas.height, 0x808080ff);
    this.end(true);
  }
  
  begin() {
    this.egg_render_tint(0x00000000);
    this.alpha = 1;
    if (this.sizeDirty) {
      this.sizeDirty = false;
      if (this.egg.directgl) {
        const bounds = this.canvas.getBoundingClientRect();
        this.canvas.width = bounds.width;
        this.canvas.height = bounds.height;
      }
    }
  }
  
  end(override) {
    if (this.egg.directgl && !override) return;
    const srctex = this.textures[0];
    if (!srctex) return;

    const dstx = 0, dsty = 0, dstw = this.canvas.width, dsth = this.canvas.height;
    const aposv = this.vbufs16;
    const tcv = this.vbuff32;
    aposv[ 0] = dstx;      aposv[ 1] = dsty;      tcv[ 1] = 0.0; tcv[ 2] = 1.0;
    aposv[ 6] = dstx;      aposv[ 7] = dsty+dsth; tcv[ 4] = 0.0; tcv[ 5] = 0.0;
    aposv[12] = dstx+dstw; aposv[13] = dsty;      tcv[ 7] = 1.0; tcv[ 8] = 1.0;
    aposv[18] = dstx+dstw; aposv[19] = dsty+dsth; tcv[10] = 1.0; tcv[11] = 0.0;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vbuf, this.gl.STREAM_DRAW);
    
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
    this.gl.useProgram(this.pgm_decal);
    this.gl.uniform2f(this.u_decal_screensize, this.canvas.width, this.canvas.height);
    this.gl.bindTexture(this.gl.TEXTURE_2D, srctex.texid);
    this.gl.uniform4f(this.u_decal_tint, 0.0, 0.0, 0.0, 0.0);
    this.gl.uniform1f(this.u_decal_alpha, 1.0);
    this.gl.disable(this.gl.BLEND);
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 12, 0);
    this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 12, 4);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
    this.gl.enable(this.gl.BLEND);
  }
  
  /*------------------------ Public API entry points ---------------------------------*/
  
  egg_video_set_string_buffer(vp, a) {
    this.webgl.glstrp = vp;
    this.webgl.glstra = a;
  }
  
  egg_video_get_size(wp, hp) {
    if (wp) this.egg.exec.mem32[wp >> 2] = this.canvas.width;
    if (hp) this.egg.exec.mem32[hp >> 2] = this.canvas.height;
  }
  
  egg_texture_del(texid) {
    if ((texid < 2) || (texid > this.textures.length)) return; // sic "<2". You can't delete the main framebuffer.
    const texture = this.textures[texid - 1];
    if (!texture) return;
    if (texture.texid) this.gl.deleteTexture(texture.texid);
    if (texture.fbid) this.gl.deleteFramebuffer(texture.fbid);
    this.textures[texid - 1] = null;
  }
  
  egg_texture_new() {
    const texture = {
      texid: this.gl.createTexture(),
      fbid: null,
      w: 0,
      h: 0,
      fmt: 0,
    };
    if (!texture.texid) return 0;
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture.texid);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
    const p = this.textures.indexOf(null);
    if (p >= 0) {
      this.textures[p] = texture;
      return p + 1;
    } else {
      this.textures.push(texture);
      return this.textures.length;
    }
  }
  
  egg_texture_get_header(wp, hp, fmtp, texid) {
    const texture = this.textures[texid - 1];
    if (!texture) return;
    if (wp) this.egg.exec.mem32[wp >> 2] = texture.w;
    if (hp) this.egg.exec.mem32[hp >> 2] = texture.h;
    if (fmtp) this.egg.exec.mem32[fmtp >> 2] = texture.fmt;
  }
  
  egg_texture_load_image(texid, qual, rid) {
    if ((texid < 2) || (texid > this.textures.length)) return -1;
    const texture = this.textures[texid - 1];
    if (!texture) return -1;
    const serial = this.egg.rom.getRes(Rom.RESTYPE_image, qual, rid);
    if (!serial || !serial.length) return -1;
    const image = this.egg.imageDecoder.decode(serial);
    if (!image) return -1;
    return this.loadTexture(texture, image);
  }
  
  egg_texture_upload(texid, w, h, stride, fmt, v, c) {
    if ((texid < 1) || (texid > this.textures.length)) return -1;
    const texture = this.textures[texid - 1];
    if (!texture) return -1;
    if (texid === 1) { // Allowed to upload to texid 1, but not allowed to resize it.
      if (texture.w && texture.h) {
        if ((w !== texture.w) || (h !== texture.h)) return -1;
      }
    }
    let mem = null;
    if (c) {
      if (!(mem = this.egg.exec.getView(v, c))) return -1;
    }
    return this.loadTexture(texture, {
      v: mem,
      w, h, stride, fmt,
    });
  }
  
  egg_texture_clear(texid) {
    const texture = this.textures[texid - 1];
    if (!texture) return;
    this.requireFramebuffer(texture);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.fbid);
    this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
  }
  
  egg_render_tint(tint) {
    this.tint = tint;
    this.tr = ((tint >> 24) & 0xff) / 255.0;
    this.tg = ((tint >> 16) & 0xff) / 255.0;
    this.tb = ((tint >> 8) & 0xff) / 255.0;
    this.ta = (tint & 0xff) / 255.0;
  }
  
  egg_render_alpha(a) {
    this.alpha = a / 255.0;
  }
  
  egg_draw_rect(dsttexid, x, y, w, h, rgba) {
    const texture = this.textures[dsttexid - 1];
    if (!texture) return;
    const r = (rgba >> 24) & 0xff;
    const g = (rgba >> 16) & 0xff;
    const b = (rgba >> 8) & 0xff;
    const a = rgba & 0xff;
    this.requireFramebuffer(texture);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.fbid);
    this.gl.useProgram(this.pgm_raw);
    this.gl.viewport(0, 0, texture.w, texture.h);
    this.gl.uniform2f(this.u_raw_screensize, texture.w, texture.h);
    this.gl.uniform1f(this.u_raw_alpha, this.alpha);
    this.gl.uniform4f(this.u_raw_tint, this.tr, this.tg, this.tb, this.ta);
    
    const aposv = this.vbufs16;
    const colorv = this.vbufu8;
    aposv[ 0] = x;   aposv[ 1] = y;   colorv[ 4] = r; colorv[ 5] = g; colorv[ 6] = b; colorv[ 7] = a;
    aposv[ 4] = x;   aposv[ 5] = y+h; colorv[12] = r; colorv[13] = g; colorv[14] = b; colorv[15] = a;
    aposv[ 8] = x+w; aposv[ 9] = y;   colorv[20] = r; colorv[21] = g; colorv[22] = b; colorv[23] = a;
    aposv[12] = x+w; aposv[13] = y+h; colorv[28] = r; colorv[29] = g; colorv[30] = b; colorv[31] = a;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vbuf, this.gl.STREAM_DRAW);
    
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 8, 0);
    this.gl.vertexAttribPointer(1, 4, this.gl.UNSIGNED_BYTE, true, 8, 4);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  drawRaw(dsttexid, mode, v, c) {
    const texture = this.textures[dsttexid - 1];
    if (!texture) return;
    this.requireFramebuffer(texture);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.fbid);
    this.gl.useProgram(this.pgm_raw);
    this.gl.viewport(0, 0, texture.w, texture.h);
    this.gl.uniform2f(this.u_raw_screensize, texture.w, texture.h);
    this.gl.uniform1f(this.u_raw_alpha, this.alpha);
    this.gl.uniform4f(this.u_raw_tint, this.tr, this.tg, this.tb, this.ta);
    
    const len = c * 8;
    const srcview = this.egg.exec.getView(v, len);
    if (!srcview) return;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, srcview, this.gl.STREAM_DRAW);
    
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 8, 0);
    this.gl.vertexAttribPointer(1, 4, this.gl.UNSIGNED_BYTE, true, 8, 4);
    this.gl.drawArrays(mode, 0, c);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  egg_draw_line(dsttexid, v, c) {
    this.drawRaw(dsttexid, this.gl.LINE_STRIP, v, c);
  }
  
  egg_draw_trig(dsttexid, v, c) {
    this.drawRaw(dsttexid, this.gl.TRIANGLE_STRIP, v, c);
  }
  
  egg_draw_decal(dsttexid, srctexid, dstx, dsty, srcx, srcy, w, h, xform) {
    if (dsttexid === srctexid) return;
    const dsttex = this.textures[dsttexid - 1];
    const srctex = this.textures[srctexid - 1];
    if (!dsttex || !srctex) return;
    this.requireFramebuffer(dsttex);
    
    let dstw = w, dsth = h;
    if (xform & 4) { // SWAP
      dstw = h;
      dsth = w;
    }
    const aposv = this.vbufs16;
    const tcv = this.vbuff32;
    aposv[ 0] = dstx;      aposv[ 1] = dsty;      tcv[ 1] = 0.0; tcv[ 2] = 0.0;
    aposv[ 6] = dstx;      aposv[ 7] = dsty+dsth; tcv[ 4] = 0.0; tcv[ 5] = 1.0;
    aposv[12] = dstx+dstw; aposv[13] = dsty;      tcv[ 7] = 1.0; tcv[ 8] = 0.0;
    aposv[18] = dstx+dstw; aposv[19] = dsty+dsth; tcv[10] = 1.0; tcv[11] = 1.0;
    if (xform & 4) { // SWAP
      for (let i=1; i<12; i+=3) {
        const tmp = tcv[i];
        tcv[i] = tcv[i + 1];
        tcv[i + 1] = tmp;
      }
    }
    if (xform & 1) { // XREV
      for (let i=1; i<12; i+=3) {
        tcv[i] = 1.0 - tcv[i];
      }
    }
    if (xform & 2) { // YREV
      for (let i=2; i<12; i+=3) {
        tcv[i] = 1.0 - tcv[i];
      }
    }
    const tx0 = srcx / srctex.w;
    const tx1 = w / srctex.w;
    const ty0 = srcy / srctex.h;
    const ty1 = h / srctex.h;
    for (let i=1; i<12; i+=3) {
      tcv[i] = tx0 + tx1 * tcv[i];
      tcv[i+1] = ty0 + ty1 * tcv[i+1];
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vbuf, this.gl.STREAM_DRAW);
    
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, dsttex.fbid);
    this.gl.viewport(0, 0, dsttex.w, dsttex.h);
    this.gl.useProgram(this.pgm_decal);
    this.gl.uniform2f(this.u_decal_screensize, dsttex.w, dsttex.h);
    this.gl.bindTexture(this.gl.TEXTURE_2D, srctex.texid);
    this.gl.uniform4f(this.u_decal_tint, this.tr, this.tg, this.tb, this.ta);
    this.gl.uniform1f(this.u_decal_alpha, this.alpha);
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 12, 0);
    this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 12, 4);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  egg_draw_decal_mode7(dsttexid, srctexid, dstx, dsty, srcx, srcy, w, h, rotation, xscale, yscale) {
    if (dsttexid === srctexid) return;
    const dsttex = this.textures[dsttexid - 1];
    const srctex = this.textures[srctexid - 1];
    if (!dsttex || !srctex) return;
    this.requireFramebuffer(dsttex);
    rotation /= 65536;
    xscale /= 65536;
    yscale /= 65536;
    
    const aposv = this.vbufs16;
    const tcv = this.vbuff32;
    const cost = Math.cos(-rotation);
    const sint = Math.sin(-rotation);
    const halfw = w * xscale * 0.5;
    const halfh = h * yscale * 0.5;
    const nwx = Math.round( cost * halfw + sint * halfh);
    const nwy = Math.round(-sint * halfw + cost * halfh);
    const swx = Math.round( cost * halfw - sint * halfh);
    const swy = Math.round(-sint * halfw - cost * halfh);
    aposv[ 0] = dstx - nwx; aposv[ 1] = dsty - nwy; tcv[ 1] = 0.0; tcv[ 2] = 0.0;
    aposv[ 6] = dstx - swx; aposv[ 7] = dsty - swy; tcv[ 4] = 0.0; tcv[ 5] = 1.0;
    aposv[12] = dstx + swx; aposv[13] = dsty + swy; tcv[ 7] = 1.0; tcv[ 8] = 0.0;
    aposv[18] = dstx + nwx; aposv[19] = dsty + nwy; tcv[10] = 1.0; tcv[11] = 1.0;
    const tx0 = (srcx + 0.5) / srctex.w;
    const tx1 = (w - 1) / srctex.w;
    const ty0 = (srcy + 0.5) / srctex.h;
    const ty1 = (h - 1) / srctex.h;
    for (let i=1; i<12; i+=3) {
      tcv[i] = tx0 + tx1 * tcv[i];
      tcv[i+1] = ty0 + ty1 * tcv[i+1];
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vbuf, this.gl.STREAM_DRAW);
    
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, dsttex.fbid);
    this.gl.viewport(0, 0, dsttex.w, dsttex.h);
    this.gl.useProgram(this.pgm_decal);
    this.gl.uniform2f(this.u_decal_screensize, dsttex.w, dsttex.h);
    this.gl.bindTexture(this.gl.TEXTURE_2D, srctex.texid);
    this.gl.uniform4f(this.u_decal_tint, this.tr, this.tg, this.tb, this.ta);
    this.gl.uniform1f(this.u_decal_alpha, this.alpha);
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 12, 0);
    this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 12, 4);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  egg_draw_tile(dsttexid, srctexid, v, c) {
    if (!v || (c < 1)) return;
    if (dsttexid === srctexid) return;
    const dsttex = this.textures[dsttexid - 1];
    const srctex = this.textures[srctexid - 1];
    if (!dsttex || !srctex) return;
    this.requireFramebuffer(dsttex);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, dsttex.fbid);
    this.gl.useProgram(this.pgm_tile);
    this.gl.viewport(0, 0, dsttex.w, dsttex.h);
    this.gl.uniform2f(this.u_tile_screensize, dsttex.w, dsttex.h);
    this.gl.bindTexture(this.gl.TEXTURE_2D, srctex.texid);
    
    const len = c * 6;
    const srcview = this.egg.exec.getView(v, len);
    if (!srcview) return;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, srcview, this.gl.STREAM_DRAW);
    
    this.gl.uniform4f(this.u_tile_tint, this.tr, this.tg, this.tb, this.ta);
    this.gl.uniform1f(this.u_tile_alpha, this.alpha);
    this.gl.uniform1f(this.u_tile_pointsize, srctex.w >> 4);
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.enableVertexAttribArray(2);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 6, 0);
    this.gl.vertexAttribPointer(1, 1, this.gl.UNSIGNED_BYTE, false, 6, 4);
    this.gl.vertexAttribPointer(2, 1, this.gl.UNSIGNED_BYTE, false, 6, 5);
    this.gl.drawArrays(this.gl.POINTS, 0, c);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
    this.gl.disableVertexAttribArray(2);
  }
  
  /*------------------------------ Private -----------------------------------*/
   
  /* (texture) is from our list.
   * (image) is {v,w,h,fmt,stride} where (v) is null or Uint8Array.
   */
  loadTexture(texture, image) {
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture.texid);
    let ifmt = this.gl.RGBA, fmt = this.gl.RGBA, type = this.gl.UNSIGNED_BYTE;
    switch (image.fmt) {
      case 1: break; // RGBA, already initted like that
      case 2: ifmt = this.gl.ALPHA; fmt = this.gl.ALPHA; break;
      case 3: image = this.expand1(image, 0x00000000, 0x000000ff); break; // a1
      default: return -1;
    }
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, ifmt, image.w, image.h, 0, fmt, type, image.v);
    texture.w = image.w;
    texture.h = image.h;
    texture.fmt = image.fmt;
    return 0;
  }
  
  // Return an RGBA image from something 1-bit.
  expand1(image, zero, one) {
    const dststride = image.w << 2;
    const dst = new Uint8Array(dststride * image.h);
    for (let dstp=0, srcp=0, yi=image.h; yi-->0; srcp+=image.stride) {
      for (let xi=image.w, srcmask=0x80, srcpp=srcp; xi-->0; ) {
        if (image.v[srcpp] & srcmask) {
          dst[dstp++] = one >> 24;
          dst[dstp++] = one >> 16;
          dst[dstp++] = one >> 8;
          dst[dstp++] = one;
        } else {
          dst[dstp++] = zero >> 24;
          dst[dstp++] = zero >> 16;
          dst[dstp++] = zero >> 8;
          dst[dstp++] = zero;
        }
        if (srcmask === 1) { srcmask = 0x80; srcpp++; }
        else srcmask >>= 1;
      }
    }
    return {
      v: dst,
      w: image.w,
      h: image.h,
      fmt: 1, // RGBA
      stride: dststride,
    };
  }
  
  requireFramebuffer(texture) {
    if (texture.fbid) return;
    if (!(texture.fbid = this.gl.createFramebuffer())) throw new Error(`Failed to create WebGL framebuffer object.`);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.fbid);
    this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, texture.texid, 0);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
  }
  
  compileShaders() {
  
    this.pgm_raw = this.compileShader("raw", Render.vsrc_raw, Render.fsrc_raw);
    this.gl.useProgram(this.pgm_raw);
    this.u_raw_screensize = this.gl.getUniformLocation(this.pgm_raw, "screensize");
    this.u_raw_alpha = this.gl.getUniformLocation(this.pgm_raw, "alpha");
    this.u_raw_tint = this.gl.getUniformLocation(this.pgm_raw, "tint");
    this.gl.bindAttribLocation(this.pgm_raw, 0, "apos");
    this.gl.bindAttribLocation(this.pgm_raw, 1, "acolor");
  
    this.pgm_decal = this.compileShader("decal", Render.vsrc_decal, Render.fsrc_decal);
    this.gl.useProgram(this.pgm_decal);
    this.u_decal_screensize = this.gl.getUniformLocation(this.pgm_decal, "screensize");
    this.u_decal_sampler = this.gl.getUniformLocation(this.pgm_decal, "sampler");
    this.u_decal_alpha = this.gl.getUniformLocation(this.pgm_decal, "alpha");
    this.u_decal_tint = this.gl.getUniformLocation(this.pgm_decal, "tint");
    this.gl.bindAttribLocation(this.pgm_decal, 0, "apos");
    this.gl.bindAttribLocation(this.pgm_decal, 1, "atexcoord");
  
    this.pgm_tile = this.compileShader("tile", Render.vsrc_tile, Render.fsrc_tile);
    this.gl.useProgram(this.pgm_tile);
    this.u_tile_screensize = this.gl.getUniformLocation(this.pgm_tile, "screensize");
    this.u_tile_sampler = this.gl.getUniformLocation(this.pgm_tile, "sampler");
    this.u_tile_alpha = this.gl.getUniformLocation(this.pgm_tile, "alpha");
    this.u_tile_tint = this.gl.getUniformLocation(this.pgm_tile, "tint");
    this.u_tile_pointsize = this.gl.getUniformLocation(this.pgm_tile, "pointsize");
    this.gl.bindAttribLocation(this.pgm_tile, 0, "apos");
    this.gl.bindAttribLocation(this.pgm_tile, 1, "atileid");
    this.gl.bindAttribLocation(this.pgm_tile, 2, "axform");
  }
  
  compileShader(name, vsrc, fsrc) {
    const pid = this.gl.createProgram();
    if (!pid) throw new Error(`Failed to create new WebGL program for ${JSON.stringify(name)}`);
    try {
      this.compileShader1(name, pid, this.gl.VERTEX_SHADER, vsrc);
      this.compileShader1(name, pid, this.gl.FRAGMENT_SHADER, fsrc);
      this.gl.linkProgram(pid);
      if (!this.gl.getProgramParameter(pid, this.gl.LINK_STATUS)) {
        const log = this.gl.getProgramInfoLog(pid);
        throw new Error(`Failed to link program ${JSON.stringify(name)}:\n${log}`);
      }
    } catch (e) {
      this.gl.deleteProgram(pid);
      throw e;
    }
    return pid;
  }
  
  compileShader1(name, pid, type, src) {
    const sid = this.gl.createShader(type);
    if (!sid) throw new Error(`Failed to create new WebGL shader for ${JSON.stringify(name)}`);
    try {
      this.gl.shaderSource(sid, src);
      this.gl.compileShader(sid);
      if (!this.gl.getShaderParameter(sid, this.gl.COMPILE_STATUS)) {
        const log = this.gl.getShaderInfoLog(sid);
        throw new Error(`Failed to link ${(type === this.gl.VERTEX_SHADER) ? "vertex" : "fragment"} shader for ${JSON.stringify(name)}:\n${log}`);
      }
      this.gl.attachShader(pid, sid);
    } finally {
      this.gl.deleteShader(sid);
    }
  }
}

/* GLSL
 * TODO These need a minification strategy separate from the general Javascript one.
 ***********************************************************/
 
Render.vsrc_raw = `
  #version 100
  precision mediump float;
  uniform vec2 screensize;
  uniform vec4 tint;
  uniform float alpha;
  attribute vec2 apos;
  attribute vec4 acolor;
  varying vec4 vcolor;
  void main() {
    vec2 npos=(apos*2.0)/screensize-1.0;
    gl_Position=vec4(npos,0.0,1.0);
    vcolor=vec4(mix(acolor.rgb,tint.rgb,tint.a),acolor.a*alpha);
  }
`;

Render.fsrc_raw = `
  #version 100
  precision mediump float;
  varying vec4 vcolor;
  void main() {
    gl_FragColor=vcolor;
  }
`;
 
Render.vsrc_decal = `
  #version 100
  precision mediump float;
  uniform vec2 screensize;
  attribute vec2 apos;
  attribute vec2 atexcoord;
  varying vec2 vtexcoord;
  void main() {
    vec2 npos=(apos*2.0)/screensize-1.0;
    gl_Position=vec4(npos,0.0,1.0);
    vtexcoord=atexcoord;
  }
`;

Render.fsrc_decal = `
  #version 100
  precision mediump float;
  uniform sampler2D sampler;
  uniform float alpha;
  uniform vec4 tint;
  varying vec2 vtexcoord;
  void main() {
    gl_FragColor=texture2D(sampler,vtexcoord);
    gl_FragColor=vec4(mix(gl_FragColor.rgb,tint.rgb,tint.a),gl_FragColor.a*alpha);
  }
`;
 
Render.vsrc_tile = `
  #version 100
  precision mediump float;
  uniform vec2 screensize;
  uniform float pointsize;
  attribute vec2 apos;
  attribute float atileid;
  attribute float axform;
  varying vec2 vsrcp;
  varying mat2 vmat;
  void main() {
    vec2 npos=(apos*2.0)/screensize-1.0;
    gl_Position=vec4(npos,0.0,1.0);
    vsrcp=vec2(
      mod(atileid,16.0),
      floor(atileid/16.0)
    )/16.0;
         if (axform<0.5) vmat=mat2( 1.0, 0.0, 0.0, 1.0); // no xform
    else if (axform<1.5) vmat=mat2(-1.0, 0.0, 0.0, 1.0); // XREV
    else if (axform<2.5) vmat=mat2( 1.0, 0.0, 0.0,-1.0); // YREV
    else if (axform<3.5) vmat=mat2(-1.0, 0.0, 0.0,-1.0); // XREV|YREV
    else if (axform<4.5) vmat=mat2( 0.0, 1.0, 1.0, 0.0); // SWAP
    else if (axform<5.5) vmat=mat2( 0.0, 1.0,-1.0, 0.0); // SWAP|XREV
    else if (axform<6.5) vmat=mat2( 0.0,-1.0, 1.0, 0.0); // SWAP|YREV
    else if (axform<7.5) vmat=mat2( 0.0,-1.0,-1.0, 0.0); // SWAP|XREV|YREV
                    else vmat=mat2( 1.0, 0.0, 0.0, 1.0); // invalid; use identity
    gl_PointSize=pointsize;
  }
`;

Render.fsrc_tile = `
  #version 100
  precision mediump float;
  uniform sampler2D sampler;
  uniform float alpha;
  uniform vec4 tint;
  varying vec2 vsrcp;
  varying mat2 vmat;
  void main() {
    vec2 texcoord=gl_PointCoord;
    texcoord.y=1.0-texcoord.y;
    texcoord=vmat*(texcoord-0.5)+0.5;
    texcoord=vsrcp+texcoord/16.0;
    gl_FragColor=texture2D(sampler,texcoord);
    gl_FragColor=vec4(mix(gl_FragColor.rgb,tint.rgb,tint.a),gl_FragColor.a*alpha);
  }
`;
/* Exec.js
 * Owns the WebAssembly context.
 */
 

 
class Exec {
  constructor(egg) {
    this.egg = egg;
    if (!window.WebAssembly) throw new Error("WebAssembly not supported");
    this.textDecoder = new TextDecoder("utf8");
    this.textEncoder = new TextEncoder("utf8");
    this.memory = null;
    this.egg_client_quit = () => {};
    this.egg_client_init = () => -1;
    this.egg_client_update = () => {};
    this.egg_client_render = () => {};
    this.mem8 = null;
    this.mem32 = null;
    this.memf64 = null;
    this.fntab = null;
  }
  
  load() {
    const serial = this.egg.rom.getRes(Rom.RESTYPE_wasm, 0, 1);
    const options = { env: {
      egg_log: (f, v) => this.egg.egg_log(f, v),
      egg_time_real: () => Date.now() / 1000,
      egg_time_local: (v, a) => this.egg.egg_time_local(v, a),
      egg_request_termination: () => this.egg.stop(),
      egg_get_user_languages: (v, a) => this.egg.egg_get_user_languages(v, a),
      egg_video_set_string_buffer: (v, a) => this.egg.render.egg_video_set_string_buffer(v, a),
      egg_video_get_size: (wp, hp) => this.egg.render.egg_video_get_size(wp, hp),
      egg_texture_del: (texid) => this.egg.render.egg_texture_del(texid),
      egg_texture_new: () => this.egg.render.egg_texture_new(),
      egg_texture_get_header: (w, h, fmt, texid) => this.egg.render.egg_texture_get_header(w, h, fmt, texid),
      egg_texture_load_image: (texid, qual, rid) => this.egg.render.egg_texture_load_image(texid, qual, rid),
      egg_texture_upload: (texid, w, h, stride, fmt, v, c) => this.egg.render.egg_texture_upload(texid, w, h, stride, fmt, v, c),
      egg_texture_clear: (texid) => this.egg.render.egg_texture_clear(texid),
      egg_render_tint: (rgba) => this.egg.render.egg_render_tint(rgba),
      egg_render_alpha: (a) => this.egg.render.egg_render_alpha(a),
      egg_draw_rect: (dt, x, y, w, h, c) => this.egg.render.egg_draw_rect(dt, x, y, w, h, c),
      egg_draw_line: (dt, v, c) => this.egg.render.egg_draw_line(dt, v, c),
      egg_draw_trig: (dt, v, c) => this.egg.render.egg_draw_trig(dt, v, c),
      egg_draw_decal: (dt, st, dx, dy, sx, sy, w, h, xf) => this.egg.render.egg_draw_decal(dt, st, dx, dy, sx, sy, w, h, xf),
      egg_draw_decal_mode7: (dt, st, dx, dy, sx, sy, w, h, r, xs, ys) => this.egg.render.egg_draw_decal_mode7(dt, st, dx, dy, sx, sy, w, h, r, xs, ys),
      egg_draw_tile: (dt, st, v, c) => this.egg.render.egg_draw_tile(dt, st, v, c),
      egg_image_get_header: (wp, hp, sp, fp, qual, rid) => this.egg.data.egg_image_get_header(wp, hp, sp, fp, qual, rid),
      egg_image_decode: (v, a, qual, rid) => this.egg.data.egg_image_decode(v, a, qual, rid),
      egg_res_get: (v, a, tid, qual, rid) => this.egg.egg_res_get(v, a, tid, qual, rid),
      egg_res_for_each: (cb, ctx) => this.egg.egg_res_for_each(cb, ctx),
      egg_store_get: (v, a, k, kc) => this.egg.data.egg_store_get(v, a, k, kc),
      egg_store_set: (k, kc, v, vc) => this.egg.data.egg_store_set(k, kc, v, vc),
      egg_store_key_by_index: (v, a, p) => this.egg.data.egg_store_key_by_index(v, a, p),
      egg_event_get: (v, a) => this.egg.input.egg_event_get(v, a),
      egg_event_enable: (t, e) => this.egg.input.egg_event_enable(t, e),
      egg_show_cursor: (s) => this.egg.input.egg_show_cursor(s),
      egg_lock_cursor: (l) => this.egg.input.egg_lock_cursor(l),
      egg_joystick_devid_by_index: (p) => this.egg.input.egg_joystick_devid_by_index(p),
      egg_joystick_get_ids: (vid, pid, ver, devid) => this.egg.input.egg_joystick_get_ids(vid, pid, ver, devid),
      egg_joystick_get_name: (v, a, devid) => this.egg.input.egg_joystick_get_name(v, a, devid),
      egg_joystick_for_each_button: (devid, cb, ctx) => this.egg.input.egg_joystick_for_each_button(devid, cb, ctx),
      egg_audio_play_song: (qual, rid, f, r) => this.egg.audio.egg_audio_play_song(qual, rid, f, r),
      egg_audio_play_sound: (qual, rid, t, p) => this.egg.audio.egg_audio_play_sound(qual, rid, t, p),
      egg_audio_event: (c, o, a, b) => this.egg.audio.egg_audio_event(c, o, a, b),
      egg_audio_get_playhead: () => this.egg.audio.egg_audio_get_playhead(),
      egg_audio_set_playhead: (b) => this.egg.audio.egg_audio_set_playhead(b),
      ...this.egg.render.webgl.generatePublicApi(),
    }};
    return WebAssembly.instantiate(serial, options).then(result => {
      const yoink = name => {
        if (!result.instance.exports[name]) {
          throw new Error(`ROM does not export required symbol '${name}'`);
        }
        this[name] = result.instance.exports[name];
      };
      yoink("memory");
      yoink("egg_client_quit");
      yoink("egg_client_init");
      yoink("egg_client_update");
      yoink("egg_client_render");
      this.mem8 = new Uint8Array(this.memory.buffer);
      this.mem32 = new Uint32Array(this.memory.buffer);
      this.memf64 = new Float64Array(this.memory.buffer);
      this.fntab = result.instance.exports.__indirect_function_table;
    });
  }
  
  readCString(p) {
    let z = p;
    while (this.mem8[z]) z++;
    return this.textDecoder.decode(this.mem8.slice(p, z));
  }
  
  readLimitedString(p, limit) {
    let z = p;
    while (this.mem8[z] && (limit-- > 0)) z++;
    return this.textDecoder.decode(this.mem8.slice(p, z));
  }
  
  // (src) must be string or Uint8Array
  safeWrite(dst, dsta, src) {
    if (typeof(src) === "string") {
      src = this.textEncoder.encode(src);
    }
    const cpc = Math.min(dsta, src.length);
    if (cpc === src.length) {
      const dstview = new Uint8Array(this.memory.buffer, dst, cpc);
      dstview.set(src);
    } else if (cpc > 0) {
      const dstview = new Uint8Array(this.memory.buffer, dst, cpc);
      const srcview = new Uint8Array(src.buffer, src.byteOffset, cpc);
      dstview.set(srcview);
    }
    return src.length;
  }
  
  // Offset Uint8Array, or null if OOB
  getView(p, c) {
    if ((p < 0) || (c < 0) || (p > this.memory.buffer.byteLength - c)) return null;
    return new Uint8Array(this.memory.buffer, p, c);
  }
}
/* DataService.js
 * Coordinates higher-level services around resources,
 * and the persistent storage.
 */
 

 
class DataService {
  constructor(egg) {
    this.egg = egg;
    this.rom = egg.rom;
    this.metadata = null; // {k:v} strings
    this.masterKey = "store-" + this.getMetadata("title").substring(0, 32);
    try {
      this.store = JSON.parse(window.localStorage.getItem(this.masterKey));
      if (!this.store || (typeof(this.store) !== "object") || (this.store instanceof Array)) this.store = {};
    } catch (e) {
      this.store = {};
    }
    this.storeSaveTimeout = null;
  }
  
  getMetadata(k) {
    if (!this.metadata) this.metadata = this.decodeMetadata(this.rom.getRes(Rom.RESTYPE_metadata, 0, 1));
    // TODO Look for "*String", if we know the language.
    return this.metadata[k] || "";
  }
  
  decodeMetadata(src) {
    if ((src.length < 2) || (src[0] !== 0xee) || (src[1] !== 0x4d)) return {};
    const decoder = new TextDecoder("utf8");
    const dst = {};
    for (let srcp=2; srcp<src.length; ) {
      const kc = src[srcp++] || 0;
      const vc = src[srcp++] || 0;
      if (srcp > src.length - vc - kc) break;
      const k = decoder.decode(src.slice(srcp, srcp + kc));
      srcp += kc;
      const v = decoder.decode(src.slice(srcp, srcp + vc));
      srcp += vc;
      dst[k] = v;
    }
    return dst;
  }
  
  storeDirty() {
    /* This debounce shouldn't be long, in fact zero would probably be OK.
     * The idea is that if the game sets a whole bunch of fields in one update cycle, don't write them out more than once.
     * No matter what we do here, fields written by the game available to it for immediate readback.
     */
    const saveDebounceTimeMs = 500;
    if (!this.storeSaveTimeout) this.storeSaveTimeout = window.setTimeout(() => {
      this.storeSaveTimeout = null;
      window.localStorage.setItem(this.masterKey, JSON.stringify(this.store));
    }, saveDebounceTimeMs);
  }
  
  /*--------------------------- Public API entry points ---------------------------------*/
  
  egg_image_get_header(wp, hp, stridep, fmtp, qual, rid) {
    const serial = this.rom.getRes(Rom.RESTYPE_image, qual, rid);
    if (serial.length < 1) return;
    try {
      const header = this.egg.imageDecoder.decodeHeader(serial);
      this.egg.exec.mem32[wp >> 2] = header.w;
      this.egg.exec.mem32[hp >> 2] = header.h;
      this.egg.exec.mem32[stridep >> 2] = header.stride;
      this.egg.exec.mem32[fmtp >> 2] = header.fmt;
    } catch (e) {}
  }
  
  egg_image_decode(dst, dsta, qual, rid) {
    const serial = this.rom.getRes(Rom.RESTYPE_image, qual, rid);
    if (serial.length < 1) return -1;
    try {
      const image = this.egg.imageDecoder.decode(serial);
      return this.egg.exec.safeWrite(dst, dsta, image.v);
    } catch (e) {
      console.error(e);
      return -1;
    }
  }
  
  egg_store_get(dst, dsta, k, kc) {
    k = this.egg.exec.readLimitedString(k, kc);
    const v = this.store[k] || "";
    return this.egg.exec.safeWrite(dst, dsta, v);
  }
  
  egg_store_set(k, kc, v, vc) {
    k = this.egg.exec.readLimitedString(k, kc);
    v = this.egg.exec.readLimitedString(v, vc);
    if (!k) return -1;
    //TODO Access control.
    if (v) {
      if (this.store[k] === v) return 0;
      if (!this.store[k]) {
        //TODO Confirm length<256 when encoded UTF-8.
      }
      this.store[k] = v;
    } else {
      if (!this.store[k]) return 0;
      delete this.store[k];
    }
    this.storeDirty();
    return 0;
  }
  
  egg_store_key_by_index(dst, dsta, p) {
    const keys = Object.keys(this.store);
    return this.egg.exec.safeWrite(dst, dsta, keys[p] || "");
  }
}



function startEgg(rom) {
  const egg = new Egg(rom);
  egg.attachToDom();
  egg.start().then(() => {
  }).catch(displayError);
}

function displayError(error) {
  document.body.innerHTML = "";
  const element = document.createElement("DIV");
  document.body.appendChild(element);
  element.classList.add("error");
  console.error(error);
  if (typeof(error) === "string") {
    element.innerText = error;
  } else if (!error) {
    element.innerText = "Unspecified error.";
  } else if (error.stack) {
    element.innerText = error.stack;
  } else if (error.message) {
    element.innerText = error.message;
  } else {
    element.innerText = JSON.stringify(error, null, 2);
  }
}

window.addEventListener("load", () => {
  let rom;
  const emb = document.querySelector("egg-rom");
  if (emb) {
    // We have an embedded ROM. Easiest case, and unambiguous what to do.
    startEgg(new Rom(emb.innerText));
  } else {
    // If we were launched with '?delivery=message', wait for our parent to postMessage with the serial ROM.
    const query = window.location.search || "";
    if (query.startsWith("?")) {
      const qo = {};
      for (const encoded of query.substring(1).split('&')) {
        const sepp = encoded.indexOf('=');
        if (sepp >= 0) {
          const k = decodeURIComponent(encoded.substring(0, sepp));
          const v = decodeURIComponent(encoded.substring(sepp + 1));
          qo[k] = v;
        } else {
          qo[decodeURIComponent(encoded)] = "";
        }
      }
      if (qo.delivery === "message") {
        window.addEventListener("message", event => {
          startEgg(new Rom(event.data));
        });
        return;
      }
    }
    // Assume the dev server is running and ask it for a ROM.
    window.fetch("/api/roms").then(rsp => {
      if (!rsp.ok) throw rsp;
      return rsp.json();
    }).then(roms => {
      //TODO Should stop here and present these options to the user.
      // But maybe just load it, if there's exactly one.
      return window.fetch(roms[0]);
    }).then(rsp => {
      if (rsp.status === 599) {
        return rsp.text().then(msg => { throw msg; });
      }
      if (!rsp.ok) throw rsp;
      return rsp.arrayBuffer();
    }).then(serial => {
      startEgg(new Rom(serial));
    }).catch(error => {
      displayError(error);
    });
  }
});

/* Input.js
 */
 
class Input {
  constructor(egg) {
    this.egg = egg;
    
    this.evtq = []; // Each member is an array of 2..5 ints.
    this.evtmask = 
      (1 << Input.EGG_EVENT_JOY) |
      (1 << Input.EGG_EVENT_KEY) |
      (1 << Input.EGG_EVENT_TOUCH)|
      // MMOTION, MBUTTON, MWHEEL, TEXT, ACCEL: off by default
    0;
    this.gamepadSupported = !!window.navigator.getGamepads;
    this.keyboardSupported = true; // TODO Is this knowable? (eg are we on a smartphone?)
    this.touchSupported = true; // ''
    this.mouseSupported = true; // ''
    this.accelerometerSupported = true; // ''
    if (!this.gamepadSupported) this.evtmask &= ~(1 << Input.EGG_EVENT_JOY);
    if (!this.keyboardSupported) this.evtmask &= ~(1 << Input.EGG_EVENT_KEY);
    if (!this.touchSupported) this.evtmask &= ~(1 << Input.EGG_EVENT_TOUCH);
    
    this.cursorVisible = false;
    this.cursorDesired = true; // Should be visible when enabled. (egg_show_cursor())
    this.mouseEventListener = null;
    this.mouseButtonsDown = new Set();
    this.mouseX = 0;
    this.mouseY = 0;
    this.mouseLocked = false;
    
    this.keyListener = e => this.onKey(e);
    window.addEventListener("keydown", this.keyListener);
    window.addEventListener("keyup", this.keyListener);
    
    this.gamepads = []; // sparse
    this.gamepadListener = e => this.onGamepadConnection(e);
    window.addEventListener("gamepadconnected", this.gamepadListener);
    window.addEventListener("gamepaddisconnected", this.gamepadListener);
    
    this.touchListener = null;
    
    this.accel = null;
    this.accelListener = null;
    
    this.canvasChanged();
  }
  
  canvasChanged() {
    const canvas = this.egg.canvas;
    if (this.touchListener && (this.canvas !== canvas)) {
      this.canvas.removeEventListener("touchstart", this.touchListener);
      this.canvas.removeEventListener("touchend", this.touchListener);
      this.canvas.removeEventListener("touchcancel", this.touchListener);
      this.canvas.removeEventListener("touchmove", this.touchListener);
      this.touchListener = null;
    }
    if (canvas) {
      this.canvas = canvas;
      if (!this.touchListener) {
        this.touchListener = e => this.onTouch(e);
        canvas.addEventListener("touchstart", this.touchListener);
        canvas.addEventListener("touchend", this.touchListener);
        canvas.addEventListener("touchcancel", this.touchListener);
        canvas.addEventListener("touchmove", this.touchListener);
      }
    }
  }
  
  detach() {
    this._unlistenMouse();
    if (this.keyListener) {
      window.removeEventListener("keydown", this.keyListener);
      window.removeEventListener("keyup", this.keyListener);
      this.keyListener = null;
    }
    if (this.gamepadListener) {
      window.removeEventListener("gamepadconnected", this.gamepadListener);
      window.removeEventListener("gamepaddisconnected", this.gamepadListener);
      this.gamepadListener = null;
    }
    if (this.touchListener) {
      this.canvas.removeEventListener("touchstart", this.touchListener);
      this.canvas.removeEventListener("touchend", this.touchListener);
      this.canvas.removeEventListener("touchcancel", this.touchListener);
      this.canvas.removeEventListener("touchmove", this.touchListener);
      this.touchListener = null;
    }
    if (this.accel) {
      if (this.accelListener) {
        this.accel.removeEventListener("reading", this.accelListener);
        this.accelListener = null;
      }
      this.accel.stop();
    }
  }
  
  update() {
    this._updateGamepads();
  }
  
  // (v) is an array of 2..5 integers; see egg_input.h
  pushEvent(v) {
    if (!(this.evtmask & (1 << v[0]))) return;
    this.evtq.push(v);
  }
  
  reset() {
    this.evtq = [];
    const initialMask =
      (1 << Input.EGG_EVENT_JOY) |
      (1 << Input.EGG_EVENT_KEY) |
      (1 << Input.EGG_EVENT_TOUCH)|
    0;
    if (initialMask !== this.evtmask) {
      for (let i=0; i<30; i++) {
        if ((initialMask & (1 << i)) !== (this.evtmask & (1 << i))) {
          this.event_enable(i, initialMask & (1 << i));
        }
      }
    }
  }
  
  /* Touch.
   ********************************************************************/
   
  onTouch(e) {
    if (!e.changedTouches) return;
    if (!this.canvas) return;
    const bounds = this.canvas.getBoundingClientRect();
    let state;
    switch (e.type) {
      case "touchstart": state = 1; break;
      case "touchend":
      case "touchcancel": state = 0; break;
      case "touchmove": state = 2; break;
    }
    for (const touch of e.changedTouches) {
      const x = ((touch.clientX - bounds.x) * this.canvas.width) / bounds.width;
      const y = ((touch.clientY - bounds.y) * this.canvas.height) / bounds.height;
      this.pushEvent([Input.EGG_EVENT_TOUCH, this.eggSafeTouchId(touch.identifier), state, x, y]);
    }
  }
  
  // The spec doesn't constain Touch.identifier beyond saying it must be an integer.
  // For Egg, it must be a *positive* integer. I've seen zero.
  eggSafeTouchId(id) {
    return (id < 1) ? ((id & 0x7fffffff) | 0x00001000) : id;
  }
  
  /* Gamepad.
   * We will use (gamepad.index+1) as (devid) for reporting to the client.
   ******************************************************************************/
   
  _updateGamepads() {
    if (!window.navigator.getGamepads) return;
    for (const gamepad of window.navigator.getGamepads()) {
      if (!gamepad) continue;
      const local = this.gamepads[gamepad.index];
      if (!local) continue;
      
      for (let i=local.axes.length; i-->0; ) {
        const pv = local.axes[i];
        const nx = gamepad.axes[i] ? Math.floor(gamepad.axes[i] * 127) : 0;
        if (pv === nx) continue;
        local.axes[i] = nx;
        this.pushEvent([Input.EGG_EVENT_JOY, local.devid, local.axisBase + i, nx]);
        this.pushEvent([Input.EGG_EVENT_RAW, local.devid, local.axisBase + i, nx]);
      }
      
      for (let i=local.buttons.length; i-->0; ) {
        const pv = local.buttons[i];
        const nx = gamepad.buttons[i].value;
        if (pv === nx) continue;
        local.buttons[i] = nx;
        this.pushEvent([Input.EGG_EVENT_JOY, local.devid, local.buttonBase + i, nx]);
        this.pushEvent([Input.EGG_EVENT_RAW, local.devid, local.buttonBase + i, nx]);
      }
    }
  }
  
  onGamepadConnection(e) {
    switch (e.type) {
    
      case "gamepadconnected": {
          let axisBase, buttonBase;
          if (e.gamepad.mapping === "standard") {
            axisBase = 0x40;
            buttonBase = 0x80;
          } else {
            axisBase = 0x100;
            buttonBase = 0x200;
          }
          this.gamepads[e.gamepad.index] = {
            devid: e.gamepad.index + 1,
            index: e.gamepad.index,
            id: e.gamepad.id,
            axes: (e.gamepad.axes || []).map(v => v),
            buttons: (e.gamepad.buttons || []).map(v => 0),
            mapping: e.gamepad.mapping,
            axisBase,
            buttonBase,
          };
          this.pushEvent([Input.EGG_EVENT_JOY, e.gamepad.index + 1, 0, 1]);
          this.pushEvent([Input.EGG_EVENT_RAW, e.gamepad.index + 1, 0, 1]);
        } break;
        
      case "gamepaddisconnected": {
          const local = this.gamepads[e.gamepad.index];
          if (local) {
            delete this.gamepads[e.gamepad.index];
            this.pushEvent([Input.EGG_EVENT_JOY, local.devid, 0, 0]);
            this.pushEvent([Input.EGG_EVENT_RAW, local.devid, 0, 0]);
          }
        } break;
    }
  }
  
  /* Mouse.
   ********************************************************************************/
  
  _checkCursorVisibility(show) {
    const enableEvents = show;
    if (this.cursorDesired) show = !!show;
    else show = false;
    if (show !== this.cursorVisible) {
      this.cursorVisible = show;
      if (this.canvas) {
        if (show) {
          this.canvas.style.cursor = "pointer";
        } else {
          this.canvas.style.cursor = "none";
        }
      }
    }
    if (enableEvents) {
      if (!this.mouseListener) {
        this._listenMouse();
      }
    } else {
      if (this.mouseListener) {
        this._unlistenMouse();
      }
    }
  }
  
  _listenMouse() {
    if (this.mouseEventListener) return;
    this.mouseEventListener = e => this.onMouseEvent(e);
    window.addEventListener("mousewheel", this.mouseEventListener);
    window.addEventListener("mousemove", this.mouseEventListener);
    window.addEventListener("mouseup", this.mouseEventListener);
    if (this.canvas) {
      this.canvas.addEventListener("mousedown", this.mouseEventListener);
      this.canvas.addEventListener("contextmenu", this.mouseEventListener);
    }
  }
  
  _unlistenMouse() {
    if (this.mouseEventListener) {
      window.removeEventListener("mousewheel", this.mouseEventListener);
      window.removeEventListener("mousemove", this.mouseEventListener);
      window.removeEventListener("mouseup", this.mouseEventListener);
      if (this.canvas) {
        this.canvas.removeEventListener("mousedown", this.mouseEventListener);
        this.canvas.removeEventListener("contextmenu", this.mouseEventListener);
      }
      this.mouseEventListener = null;
    }
  }
  
  onMouseEvent(e) {
    if (!this.canvas) return;
    const bounds = this.canvas.getBoundingClientRect();
    const x = Math.floor(((e.x - bounds.x) * this.canvas.width) / bounds.width);
    const y = Math.floor(((e.y - bounds.y) * this.canvas.height) / bounds.height);
    switch (e.type) {
      case "mousemove": {
          if (this.mouseLocked) {
            if (e.movementX || e.movementY) {
              this.pushEvent([Input.EGG_EVENT_MMOTION, e.movementX, e.movementY]);
            }
          } else {
            if ((x === this.mouseX) && (y === this.mouseY)) return;
            this.mouseX = x;
            this.mouseY = y;
            this.pushEvent([Input.EGG_EVENT_MMOTION, x, y]);
          }
        } break;
      case "mousedown": {
          if (e.target !== this.canvas) return;
          let button;
          switch (e.button) {
            case 0: button = Input.EGG_MBUTTON_LEFT; break;
            case 1: button = Input.EGG_MBUTTON_MIDDLE; break;
            case 2: button = Input.EGG_MBUTTON_RIGHT; break;
            default: button = e.button;
          }
          if (this.mouseButtonsDown.has(button)) return;
          this.mouseButtonsDown.add(button);
          e.preventDefault();
          this.pushEvent([Input.EGG_EVENT_MBUTTON, x, y, button, 1]);
        } break;
      case "mouseup": {
          let button;
          switch (e.button) {
            case 0: button = Input.EGG_MBUTTON_LEFT; break;
            case 1: button = Input.EGG_MBUTTON_MIDDLE; break;
            case 2: button = Input.EGG_MBUTTON_RIGHT; break;
            default: button = e.button;
          }
          if (!this.mouseButtonsDown.has(button)) return;
          this.mouseButtonsDown.delete(button);
          this.pushEvent([Input.EGG_EVENT_MBUTTON, x, y, button, 0]);
        } break;
      case "contextmenu": e.preventDefault(); break;
      case "mousewheel": {
          if ((x < 0) || (y < 0) || (x >= bounds.width) || (y >= bounds.height)) return;
          let dx = e.deltaX, dy = e.deltaY;
          if (e.wheelDeltaX) dx /= Math.abs(e.wheelDeltaX);
          if (e.wheelDeltaY) dy /= Math.abs(e.wheelDeltaY);
          if (e.wheelDelta && !e.wheelDeltaX && !e.wheelDeltaY) {
            dx /= Math.abs(e.wheelDelta);
            dy /= Math.abs(e.wheelDelta);
          }
          if (e.shiftKey) { // I like Shift+Wheel to mean X instead of Y.
            let tmp = dx;
            dx = dy;
            dy = tmp;
          }
          if (dx || dy) {
            this.pushEvent([Input.EGG_EVENT_MWHEEL, x, y, dx, dy]);
          }
          //event.preventDefault(); // It's installed as passive... why is that? (Chrome Linux)
        } break;
    }
  }
  
  /* Keyboard.
   **************************************************************************/
  
  onKey(e) {
    
    // Ignore all keyboard events when Alt or Ctrl is held.
    if (e.ctrlKey || e.altKey) {
      return;
    }
    
    // TODO We might be too heavy-handed with event suppression. Bear in mind that we are listening on Window.
    
    // If we recognize the key and user wants key events, pass it on and suppress it in browser.
    if (this.evtmask & (1 << Input.EGG_EVENT_KEY)) {
      const usage = this.hidUsageByKeyCode(e.code);
      if (usage) {
        const v = (e.type === "keyup") ? 0 : e.repeat ? 2 : 1;
        this.pushEvent([Input.EGG_EVENT_KEY, usage, v]);
        e.preventDefault();
        e.stopPropagation();
      }
    }
    
    // Likewise, if user wants text and it looks like text. (but not for "keyup" of course).
    if (e.type !== "keyup") {
      if (this.evtmask & (1 << Input.EGG_EVENT_TEXT)) {
        switch (e.key) {
          case "Backspace": this.pushEvent([Input.EGG_EVENT_TEXT, 0x08]); e.preventDefault(); e.stopPropagation(); break;
          case "Tab":       this.pushEvent([Input.EGG_EVENT_TEXT, 0x09]); e.preventDefault(); e.stopPropagation(); break;
          case "Enter":     this.pushEvent([Input.EGG_EVENT_TEXT, 0x0a]); e.preventDefault(); e.stopPropagation(); break;
          case "Escape":    this.pushEvent([Input.EGG_EVENT_TEXT, 0x1b]); e.preventDefault(); e.stopPropagation(); break;
          default: if (e.key?.length === 1) {
              this.pushEvent([Input.EGG_EVENT_TEXT, e.key.charCodeAt(0)]);
              e.preventDefault();
              e.stopPropagation();
            } break;
        }
      }
    }
  }
  
  hidUsageByKeyCode(code) {
    if (!code) return 0;
  
    // "KeyA".."KeyZ" => 0x04..0x1d
    if ((code.length === 4) && code.startsWith("Key")) {
      const ch = code.charCodeAt(3);
      if ((ch >= 0x41) && (ch <= 0x5a)) return 0x00070004 + ch - 0x41;
    }
    
    // "Digit1".."Digit9" => 0x1e..0x25, some jackass put "0" on the right side... why...
    if ((code.length === 6) && code.startsWith("Digit")) {
      const ch = code.charCodeAt(5);
      if ((ch >= 0x31) && (ch <= 0x39)) return 0x0007001e + ch - 0x31;
      if (ch === 0x30) return 0x00070027; // zero
    }
    
    // "F1".."F12" => 0x3a..0x45
    // "F13".."F24" => 0x68..0x73
    if (((code.length === 2) || (code.length === 3)) && (code[0] === 'F')) {
      const v = +code.substring(1);
      if ((v >= 1) && (v <= 12)) return 0x0007003a + v - 1;
      if ((v >= 13) && (v <= 24)) return 0x00070068 + v - 13;
    }
    
    // "Numpad1".."Numpad9" => 0x59..0x61, again with zero on top because Jesus hates me.
    if ((code.length === 7) && code.startsWith("Numpad")) {
      const v = +code[7];
      if ((v >= 1) && (v <= 9)) return 0x00070059 + v - 1;
      if (v === 0) return 0x00070062;
    }
    
    // And finally a not-too-crazy set of one-off names.
    switch (code) {
      case "Enter":          return 0x00070028;
      case "Escape":         return 0x00070029;
      case "Backspace":      return 0x0007002a;
      case "Tab":            return 0x0007002b;
      case "Space":          return 0x0007002c;
      case "Minus":          return 0x0007002d;
      case "Equal":          return 0x0007002e;
      case "BracketLeft":    return 0x0007002f;
      case "BracketRight":   return 0x00070039;
      case "Backslash":      return 0x00070031;
      case "Semicolon":      return 0x00070033;
      case "Quote":          return 0x00070034;
      case "Backquote":      return 0x00070035;
      case "Comma":          return 0x00070036;
      case "Period":         return 0x00070037;
      case "Slash":          return 0x00070038;
      case "CapsLock":       return 0x00070039;
      case "Pause":          return 0x00070048;
      case "Insert":         return 0x00070049;
      case "Home":           return 0x0007004a;
      case "PageUp":         return 0x0007004b;
      case "Delete":         return 0x0007004c;
      case "PageDown":       return 0x0007004e;
      case "ArrowRight":     return 0x0007004f;
      case "ArrowLeft":      return 0x00070050;
      case "ArrowDown":      return 0x00070051;
      case "ArrowUp":        return 0x00070052;
      case "NumLock":        return 0x00070053;
      case "NumpadDivide":   return 0x00070054;
      case "NumpadMultiply": return 0x00070055;
      case "NumpadSubtract": return 0x00070056;
      case "NumpadAdd":      return 0x00070057;
      case "NumpadEnter":    return 0x00070058;
      case "NumpadDecimal":  return 0x00070063;
      case "ContextMenu":    return 0x00070076;
      case "ShiftLeft":      return 0x000700e1;
      case "ShiftRight":     return 0x000700e5;
      case "ControlLeft":    return 0x000700e0;
      case "ControlRight":   return 0x000700e4;
      case "AltLeft":        return 0x000700e2;
      case "AltRight":       return 0x000700e6;
    }
    return 0;
  }
  
  /* Accelerometer.
   **************************************************************************/
   
  accelerometerEnable() {
    this._accelerometerEnableInternal().then(() => {
      if (!this.accelListener) {
        this.accelListener = () => this.onAccelerometer();
        this.accel.addEventListener("reading", this.accelListener);
      }
      this.accel.start();
    }).catch(() => {});
  }
  
  _accelerometerEnableInternal() {
    if (this.accel) return Promise.resolve();
    if (!window.navigator.permissions) return Promise.reject();
    return window.navigator.permissions.query({ name: "accelerometer" }).then(result => {
      if (result.state === "denied") throw null;
      if (!this.accel) {
        this.accel = new Accelerometer({ referenceFrame: "device", frequency: 60 });
      }
    });
  }
  
  accelerometerDisable() {
    if (!this.accel) return;
    if (this.accelListener) {
      this.accel.removeEventListener("reading", this.accelListener);
      this.accelListener = null;
    }
    this.accel.stop();
  }
  
  onAccelerometer() {
    if (!this.accel) return;
    const x = ~~(this.accel.x * 65536.0);
    const y = ~~(this.accel.y * 65536.0);
    const z = ~~(this.accel.z * 65536.0);
    this.pushEvent([Input.EGG_EVENT_ACCEL, x, y, z]);
  }
  
  /*--------------------------- Public API entry points -----------------------------------*/
  
  egg_event_get(v, a) {
    const eventSizeWords = 5;//TODO Can we assert that this is sizeof(union egg_event)/sizeof(int)?
    const cpc = Math.min(a, this.evtq.length);
    if (cpc < 1) return 0;
    let dst = this.egg.exec.mem32;
    let dstp = v >> 2;
    for (let i=0; i<cpc; i++) {
      const e = this.evtq[i];
      for (let j=0; j<eventSizeWords; j++) {
        dst[dstp++] = e[j];
      }
    }
    this.evtq.splice(0, cpc);
    return cpc;
  }
  
  egg_event_enable(type, enable) {
    if (!type) return 0;
    const bit = 1 << type;
    if (enable) {
      if (this.evtmask & bit) return 1;
      this.evtmask |= bit;
    } else {
      if (!(this.evtmask & bit)) return 0;
      this.evtmask &= ~bit;
    }
    switch (type) {
      case Input.EGG_EVENT_RAW: break;
      case Input.EGG_EVENT_JOY: {
          if (!this.gamepadSupported) return 0;
        } break;
      case Input.EGG_EVENT_KEY:
      case Input.EGG_EVENT_TEXT: {
          if (!this.keyboardSupported) return 0;
        } break;
      case Input.EGG_EVENT_MMOTION:
      case Input.EGG_EVENT_MBUTTON:
      case Input.EGG_EVENT_MWHEEL: {
          if (!this.mouseSupported) return 0;
          const mouseEvents = (1 << Input.EGG_EVENT_MMOTION) | (1 << Input.EGG_EVENT_MBUTTON) | (1 << Input.EGG_EVENT_MWHEEL);
          this._checkCursorVisibility(this.evtmask & mouseEvents);
        } break;
      case Input.EGG_EVENT_TOUCH: {
          if (!this.touchSupported) return 0;
        } break;
      case Input.EGG_EVENT_ACCEL: {
          if (!this.accelerometerSupported) return 0;
          if (enable) {
            this.accelerometerEnable();
          } else {
            this.accelerometerDisable();
          }
        } break;
    }
    return enable ? 1 : 0;
  }
  
  egg_show_cursor(show) {
    this.cursorDesired = !!show;
    const mouseEvents = (1 << Input.EGG_EVENT_MMOTION) | (1 << Input.EGG_EVENT_MBUTTON) | (1 << Input.EGG_EVENT_MWHEEL);
    this._checkCursorVisibility(this.evtmask & mouseEvents);
  }
  
  egg_lock_cursor(lock) {
    if (!this.canvas || !this.canvas.requestPointerLock) return 0;
    if (lock) {
      if (this.mouseLocked) return 1;
      this.mouseLocked = true;
      this.canvas.requestPointerLock(/*{
        unadjustedMovement: true, // Not supported in Chrome/Linux, and the whole request gets rejected for it.
      }*/).then(rsp => {
      }).catch(e => {
        this.mouseLocked = false;
      });
    } else if (this.mouseLocked) {
      this.mouseLocked = false;
      document.exitPointerLock();
    }
    return 1;
  }
  
  egg_joystick_devid_by_index(p) {
    if (p < 0) return 0;
    for (let i=0; i<this.gamepads.length; i++) {
      if (!this.gamepads[i]) continue;
      if (!p--) return i + 1;
    }
    return 0;
  }
  
  egg_joystick_get_ids(vidp, pidp, verp, devid) {
    const local = this.gamepads[devid - 1];
    if (!local || (local.devid !== devid)) return;
    // Linux Chrome: Microsoft X-Box 360 pad (STANDARD GAMEPAD Vendor: 045e Product: 028e)
    // Not at all sure how standard that formatting is, but we don't have much else to go on...
    let vid=0, pid=0, version=0;
    let match;
    if (match = local.id.match(/Vendor: ([0-9a-fA-F]{4})/)) {
      vid = parseInt(match[1], 16);
    }
    if (match = local.id.match(/Product: ([0-9a-fA-F]{4})/)) {
      pid = parseInt(match[1], 16);
    }
    if (match = local.id.match(/Version: ([0-9a-fA-F]{4})/)) {
      // This one doesn't exist for me. And not sure whether they'd break it out as MAJOR.MINOR.REVISION.
      // 0xf000=MAJOR, 0x0f00=MINOR, 0x00ff=REVISION
      version = parseInt(match[1], 16);
    }
    if (vidp) this.egg.exec.mem32[vidp >> 2] = vid;
    if (pidp) this.egg.exec.mem32[pidp >> 2] = pid;
    if (verp) this.egg.exec.mem32[verp >> 2] = version;
  }
  
  egg_joystick_get_name(dst, dsta, devid) {
    const local = this.gamepads[devid - 1];
    if (!local || (local.devid !== devid)) return 0;
    const name = local.id.split('(')[0].trim();
    return name || local.id;
    return this.egg.exec.safeWrite(dst, dsta, name);
  }
  
  egg_joystick_for_each_button(devid, cb, ctx) {
    // int (*cb)(int btnid,int usage,int lo,int hi,int value,void *userdata)
    if (!(cb = this.egg.exec.fntab.get(cb))) return 0;

    const local = this.gamepads[devid - 1];
    if (!local || (local.devid !== devid)) return null;
    
    for (let i=0; i<local.axes.length; i++) {
      let hidusage = 0;
      if (local.mapping === "standard") {
        hidusage = Input.STANDARD_AXIS_USAGE[i] || 0;
      }
      const err = cb(local.axisBase + i, hidusage, -128, 127, 0, ctx);
      if (err) return err;
    }
    
    for (let i=0; i<local.buttons.length; i++) {
      let hidusage = 0x00090000 + i;
      if (local.mapping === "standard") {
        const alt = Input.STANDARD_BUTTON_USAGE[i];
        if (alt) hidusage = alt;
      }
      const err = cb(local.buttonBase + i, hidusage, 0, 1, 0, ctx);
    }
    
    return 0;
  }
}

Input.EGG_EVENT_JOY = 1;
Input.EGG_EVENT_KEY = 2;
Input.EGG_EVENT_TEXT = 3;
Input.EGG_EVENT_MMOTION = 4;
Input.EGG_EVENT_MBUTTON = 5;
Input.EGG_EVENT_MWHEEL = 6;
Input.EGG_EVENT_TOUCH = 7;
Input.EGG_EVENT_ACCEL = 8;
Input.EGG_EVENT_RAW = 9;

Input.EGG_JOYBTN_LX    = 0x40;
Input.EGG_JOYBTN_LY    = 0x41;
Input.EGG_JOYBTN_RX    = 0x42;
Input.EGG_JOYBTN_RY    = 0x43;
Input.EGG_JOYBTN_SOUTH = 0x80;
Input.EGG_JOYBTN_EAST  = 0x81;
Input.EGG_JOYBTN_WEST  = 0x82;
Input.EGG_JOYBTN_NORTH = 0x83;
Input.EGG_JOYBTN_L1    = 0x84;
Input.EGG_JOYBTN_R1    = 0x85;
Input.EGG_JOYBTN_L2    = 0x86;
Input.EGG_JOYBTN_R2    = 0x87;
Input.EGG_JOYBTN_AUX2  = 0x88;
Input.EGG_JOYBTN_AUX1  = 0x89;
Input.EGG_JOYBTN_LP    = 0x8a;
Input.EGG_JOYBTN_RP    = 0x8b;
Input.EGG_JOYBTN_UP    = 0x8c;
Input.EGG_JOYBTN_DOWN  = 0x8d;
Input.EGG_JOYBTN_LEFT  = 0x8e;
Input.EGG_JOYBTN_RIGHT = 0x8f;
Input.EGG_JOYBTN_AUX3  = 0x90;

Input.EGG_MBUTTON_LEFT = 1;
Input.EGG_MBUTTON_RIGHT = 2;
Input.EGG_MBUTTON_MIDDLE = 3;

Input.EGG_TOUCH_END = 0;
Input.EGG_TOUCH_BEGIN = 1;
Input.EGG_TOUCH_MOVE = 2;

Input.STANDARD_AXIS_USAGE = [
  0x00010030, // lx
  0x00010031, // ly
  0x00010033, // rx
  0x00010034, // ry
];

Input.STANDARD_BUTTON_USAGE = [
  0x00050037, // south
  0x00050037, // east
  0x00050037, // west
  0x00050037, // north
  0x00050039, // l1
  0x00050039, // r1
  0x00050039, // l2
  0x00050039, // r2
  0x0001003e, // select
  0x0001003d, // start
  0x00090000, // lp
  0x00090001, // rp
  0x00010090, // dup
  0x00010091, // ddown
  0x00010093, // dleft
  0x00010092, // dright
  0x00010085, // heart -- "System Main Menu", debatable.
];
// Do not edit! Generated from src/opt/synth/synth_builtin.c.
const Instruments = [
{"mode":"fmrel","fmRate":2,"fmRangeScale":4,"fmRangeEnv":36808,"levelTiny":132},
0,
{"mode":"fmrel","fmRate":2,"fmRangeScale":4,"fmRangeEnv":36808,"levelTiny":132},
{"mode":"fmrel","fmRate":1.5,"fmRangeScale":4,"fmRangeEnv":65410,"levelTiny":139},
{"mode":"rock","wave":[0,0.5019607843137255,0.7529411764705882,0.25098039215686274,0.12549019607843137,0.03137254901960784],"mix":3968,"levelTiny":139},
{"mode":"fmabs","fmRate":128,"fmRangeScale":0.0625,"fmRangeEnv":3888,"levelTiny":84},
{"mode":"fmrel","fmRate":5,"fmRangeScale":5,"fmRangeEnv":65520,"levelTiny":5},
{"mode":"fmrel","fmRate":4,"fmRangeScale":5,"fmRangeEnv":36608,"levelTiny":69},
{"mode":"fmrel","fmRate":7.625,"fmRangeScale":8.4375,"fmRangeEnv":63610,"levelTiny":6},
{"mode":"fmrel","fmRate":3,"fmRangeScale":4,"fmRangeEnv":65524,"levelTiny":3},
{"mode":"fmrel","fmRate":6.125,"fmRangeScale":8,"fmRangeEnv":65412,"levelTiny":5},
{"mode":"fmrel","fmRate":4,"fmRangeScale":4,"fmRangeEnv":4084,"levelTiny":13},
{"mode":"fmrel","fmRate":8,"fmRangeScale":3,"fmRangeEnv":65524,"levelTiny":5},
null,
{"mode":"fmrel","fmRate":3.5,"fmRangeScale":6.4375,"fmRangeEnv":63743,"levelTiny":14},
{"mode":"fmrel","fmRate":6,"fmRangeScale":7,"fmRangeEnv":36740,"levelTiny":6},
{"mode":"rock","wave":[0,1,0.00784313725490196,0.3333333333333333,0.00392156862745098,0.2,0,0.06666666666666667],"mix":12172,"levelTiny":213},
{"mode":"rock","wave":[0,0,0.7529411764705882,0.01568627450980392,0.25098039215686274,0.00392156862745098],"mix":49908,"levelTiny":69},
{"mode":"rock","wave":[0,0.7529411764705882,0,0.3764705882352941,0,0.18823529411764706,0,0.09411764705882353],"mix":3972,"levelTiny":148},
{"mode":"rock","wave":[0,0.7529411764705882,0.6274509803921569,0.3764705882352941,0,0.18823529411764706,0,0.09411764705882353],"mix":65520,"levelTiny":158},
{"mode":"rock","wave":[0,0,0.48627450980392156,0.6470588235294118,0.5019607843137255,0.2,0.3764705882352941,0.06666666666666667,0],"mix":4080,"levelTiny":147},
16,
16,
16,
{"mode":"fmrel","fmRate":2,"fmRangeScale":1,"fmRangeEnv":20416,"levelTiny":5},
{"mode":"fx","fmRangeEnv":3968,"fmRangeLfo":0,"fmRangeLfoDepth":0,"fmRate":6,"fmRangeScale":7.5,"detuneRate":4,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.06274509803921569,"levelTiny":68},
{"mode":"fx","fmRangeEnv":4095,"fmRangeLfo":1,"fmRangeLfoDepth":0.5,"fmRate":2,"fmRangeScale":4,"detuneRate":4,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":0,"delayDepth":0,"levelTiny":68},
{"mode":"fx","fmRangeEnv":32644,"fmRangeLfo":2,"fmRangeLfoDepth":1,"fmRate":2,"fmRangeScale":4,"detuneRate":1,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":0.5,"delayDepth":0.25098039215686274,"levelTiny":76},
{"mode":"fx","fmRangeEnv":4080,"fmRangeLfo":2,"fmRangeLfoDepth":2,"fmRate":2,"fmRangeScale":4,"detuneRate":1,"detuneDepth":0.06274509803921569,"overdrive":0.06274509803921569,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":68},
{"mode":"fx","fmRangeEnv":65408,"fmRangeLfo":4,"fmRate":2,"fmRangeScale":3,"levelTiny":76,"detuneRate":4,"detuneDepth":0.00784313725490196,"overdrive":0.3764705882352941,"delayRate":1,"delayDepth":0.12549019607843137},
{"mode":"fx","fmRangeEnv":65348,"fmRangeLfo":2,"fmRangeLfoDepth":0.5,"fmRate":0.5,"fmRangeScale":3,"detuneRate":1,"detuneDepth":0.06274509803921569,"overdrive":0.8784313725490196,"delayRate":1,"delayDepth":0.06274509803921569,"levelTiny":93},
{"mode":"fx","fmRangeEnv":4080,"fmRangeLfo":0,"fmRangeLfoDepth":0,"fmRate":7.4375,"fmRangeScale":8,"detuneRate":1,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.06274509803921569,"levelTiny":93},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":4,"fmRangeEnv":63624,"levelTiny":221},
{"mode":"fx","fmRangeEnv":36804,"fmRangeLfo":2,"fmRangeLfoDepth":0.25,"fmRate":0.5,"fmRangeScale":2,"detuneRate":0,"detuneDepth":0,"overdrive":0,"delayRate":0,"delayDepth":0,"levelTiny":67},
{"mode":"wave","wave":[0,0.7529411764705882,0.7529411764705882,0.18823529411764706,0,0.06274509803921569,0.5019607843137255,0.25098039215686274,0.12549019607843137],"levelTiny":75},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":2,"fmRangeEnv":20352,"levelTiny":156},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":2.5,"fmRangeEnv":28513,"levelTiny":75},
{"mode":"rock","wave":[0,0.25098039215686274,1,0.7529411764705882,0.5019607843137255,0.25098039215686274,0.06274509803921569,0.03137254901960784,0.00784313725490196],"mix":3904,"levelTiny":84},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":3,"fmRangeEnv":20418,"levelTiny":82},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":5,"fmRangeEnv":36848,"levelTiny":76},
{"mode":"rock","wave":[0,0.12549019607843137,0.7529411764705882,0.4392156862745098,0.34509803921568627,0.25098039215686274,0.12549019607843137,0.03137254901960784],"mix":36800,"levelTiny":221},
{"mode":"rock","wave":[0,1,0.5019607843137255,0.3333333333333333,0.25098039215686274,0.2,0.12549019607843137,0.03137254901960784],"mix":36800,"levelTiny":221},
{"mode":"rock","wave":[0,0.25098039215686274,1,0.5019607843137255,0.3333333333333333,0.25098039215686274,0.2,0.12549019607843137,0.03137254901960784],"mix":36800,"levelTiny":220},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":4,"fmRangeEnv":63624,"levelTiny":221},
{"mode":"fx","fmRangeEnv":4036,"fmRangeLfo":0.5,"fmRangeLfoDepth":0.125,"fmRate":1,"fmRangeScale":2,"detuneRate":0,"detuneDepth":0,"overdrive":0,"delayRate":0,"delayDepth":0,"levelTiny":198},
{"mode":"fx","fmRangeEnv":4036,"fmRangeLfo":0.5,"fmRangeLfoDepth":0.5,"fmRate":1,"fmRangeScale":3,"detuneRate":0.25,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.06274509803921569,"levelTiny":5},
{"mode":"fx","fmRangeEnv":36804,"fmRangeLfo":0,"fmRangeLfoDepth":0,"fmRate":3,"fmRangeScale":3,"detuneRate":0.25,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":6},
{"mode":"sub","subQ1":83.33333333333333,"subQ2":96.66666666666667,"subGain":150,"levelTiny":11},
{"mode":"fx","fmRangeEnv":36804,"fmRangeLfo":4,"fmRangeLfoDepth":0.5,"fmRate":1.5,"fmRangeScale":2,"detuneRate":1,"detuneDepth":0.03137254901960784,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":213},
48,
{"mode":"fx","fmRangeEnv":53220,"fmRangeLfo":4,"fmRangeLfoDepth":0.5,"fmRate":0.5,"fmRangeScale":5,"detuneRate":1,"detuneDepth":0.03137254901960784,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":213},
48,
48,
48,
48,
48,
{"mode":"rock","wave":[0,0.12549019607843137,0.7529411764705882,0.3764705882352941,0.3137254901960784,0.25098039215686274,0.06274509803921569,0.03137254901960784,0.00784313725490196],"mix":61684,"levelTiny":219},
56,
56,
56,
56,
56,
56,
56,
{"mode":"fmrel","fmRate":4,"fmRangeScale":3,"fmRangeEnv":20418,"levelTiny":148},
64,
64,
64,
64,
64,
64,
{"mode":"rock","wave":[0,0.12549019607843137,0.5490196078431373,0.8784313725490196,0,0.45098039215686275,0,0.19215686274509805,0],"mix":255,"levelTiny":76},
"blip",
72,
{"mode":"wave","wave":[0,0.5019607843137255,0.06274509803921569,0.9607843137254902,0,0.2,0,0.06666666666666667,0.01568627450980392],"levelTiny":163},
72,
{"mode":"sub","subQ1":91.66666666666667,"subQ2":95,"subGain":45,"levelTiny":140},
{"mode":"fmrel","fmRate":4.1875,"fmRangeScale":1.5,"fmRangeEnv":3888,"levelTiny":84},
72,
{"mode":"fmrel","fmRate":2,"fmRangeScale":2.5,"fmRangeEnv":36608,"levelTiny":213},
{"mode":"wave","wave":[0,1,0,0.3333333333333333,0,0.2,0,0.06274509803921569],"levelTiny":139},
{"mode":"wave","wave":[0,1,0.5019607843137255,0.3333333333333333,0.25098039215686274,0.2,0.12549019607843137,0.06274509803921569,0.03137254901960784],"levelTiny":147},
{"mode":"rock","wave":[0,0,1,0.12549019607843137],"mix":3968,"levelTiny":141},
"blip",
{"mode":"rock","wave":[0,0,1,0.25098039215686274,0.12549019607843137,0.06274509803921569,0.03137254901960784],"mix":255,"levelTiny":140},
{"mode":"fmrel","fmRate":2.5,"fmRangeScale":2,"fmRangeEnv":63684,"levelTiny":220},
{"mode":"fmrel","fmRate":1.5,"fmRangeScale":4,"fmRangeEnv":36804,"levelTiny":156},
{"mode":"rock","wave":[0,0,0,0,1],"mix":52992,"levelTiny":148},
{"mode":"fx","fmRangeEnv":65535,"fmRangeLfo":8,"fmRangeLfoDepth":2,"fmRate":1,"fmRangeScale":1,"detuneRate":1,"detuneDepth":0.09411764705882353,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":199},
{"mode":"wave","wave":[0,1,0.06274509803921569,0.03137254901960784,0.00784313725490196],"levelTiny":195},
{"mode":"fx","fmRangeEnv":53056,"fmRangeLfo":4,"fmRangeLfoDepth":1,"fmRate":1,"fmRangeScale":4,"detuneRate":4,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":213},
{"mode":"sub","subQ1":86.66666666666667,"subQ2":91.66666666666667,"subGain":40,"levelTiny":220},
{"mode":"sub","subQ1":93.33333333333333,"subQ2":86.66666666666667,"subGain":30,"levelTiny":213},
{"mode":"fx","fmRangeEnv":65520,"fmRangeLfo":4,"fmRangeLfoDepth":0.25,"fmRate":7.375,"fmRangeScale":3,"detuneRate":8,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.03137254901960784,"levelTiny":214},
{"mode":"rock","wave":[0,0,1,0.12549019607843137,0.06274509803921569,0.03137254901960784,0.01568627450980392,0.00784313725490196,0.00392156862745098],"mix":1264,"levelTiny":222},
{"mode":"fx","fmRangeEnv":65535,"fmRangeLfo":4,"fmRangeLfoDepth":2,"fmRate":4,"fmRangeScale":3,"detuneRate":4,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.03137254901960784,"levelTiny":214},
{"mode":"fx","fmRangeEnv":36848,"fmRangeLfo":8,"fmRangeLfoDepth":8,"fmRate":3.5,"fmRangeScale":6,"detuneRate":0,"detuneDepth":0,"overdrive":0,"delayRate":0.5,"delayDepth":0.6274509803921569,"levelTiny":19},
96,
96,
96,
96,
{"mode":"fx","fmRangeEnv":36848,"fmRangeLfo":4,"fmRangeLfoDepth":4,"fmRate":0.5,"fmRangeScale":4,"detuneRate":0,"detuneDepth":0,"overdrive":0.25098039215686274,"delayRate":1,"delayDepth":0.5019607843137255,"levelTiny":83},
{"mode":"fx","fmRangeEnv":61695,"fmRangeLfo":4,"fmRangeLfoDepth":8,"fmRate":2,"fmRangeScale":1,"detuneRate":1,"detuneDepth":0.12549019607843137,"overdrive":0,"delayRate":0.5,"delayDepth":0.6274509803921569,"levelTiny":83},
{"mode":"fx","fmRangeEnv":4095,"fmRangeLfo":8,"fmRangeLfoDepth":1.5,"fmRate":2,"fmRangeScale":6,"detuneRate":1,"detuneDepth":0.03137254901960784,"overdrive":0.03137254901960784,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":205},
"blip",
104,
104,
104,
104,
104,
104,
104,
{"mode":"fmrel","fmRate":9,"fmRangeScale":10,"fmRangeEnv":65423,"levelTiny":6},
{"mode":"fmrel","fmRate":5.4375,"fmRangeScale":4,"fmRangeEnv":65535,"levelTiny":5},
{"mode":"fmrel","fmRate":5.5,"fmRangeScale":4,"fmRangeEnv":61695,"levelTiny":13},
{"mode":"fmrel","fmRate":1.5,"fmRangeScale":2,"fmRangeEnv":4095,"levelTiny":2},
{"mode":"fmrel","fmRate":0.25,"fmRangeScale":3,"fmRangeEnv":61695,"levelTiny":13},
{"mode":"fmrel","fmRate":1.5,"fmRangeScale":3.5,"fmRangeEnv":63728,"levelTiny":11},
{"mode":"fx","fmRangeLfo":0.625,"fmRangeLfoDepth":2,"fmRate":0.5,"fmRangeScale":2,"fmRangeEnv":65408,"detuneRate":0.5,"detuneDepth":0.01568627450980392,"levelTiny":3},
112,
{"mode":"fmrel","fmRate":5.5,"fmRangeScale":10,"fmRangeEnv":63631,"levelTiny":28},
{"mode":"sub","subQ1":86.66666666666667,"subQ2":86.66666666666667,"subGain":30,"levelTiny":91},
{"mode":"sub","subQ1":33.33333333333333,"subQ2":66.66666666666666,"subGain":5,"levelTiny":223},
{"mode":"fmabs","fmRate":128,"fmRangeScale":1.125,"fmRangeEnv":62464,"levelTiny":77},
{"mode":"fmabs","fmRate":256,"fmRangeScale":0.5,"fmRangeEnv":53184,"levelTiny":27},
{"mode":"fmabs","fmRate":128,"fmRangeScale":1,"fmRangeEnv":4080,"levelTiny":141},
"blip",
null,
];
/* ImageDecoder.js
 * Would be awesome if we could use browser facilities for this but alas
 * that is not possible because we have to be synchronous.
 * We could add image formats. But I think we'll advise devs to use PNG exclusively.
 */
 

 
class ImageDecoder {
  constructor() {
  }
  
  /* Returns {w,h,stride,fmt} or throws.
   * We reject images larger than 32767 on either axis, even if otherwise valid.
   */
  decodeHeader(src) {
    if (this.isPng(src)) return this.decodeHeaderPng(src);
    throw new Error(`Image format unknown`);
  }
  
  /* Returns {w,h,stride,fmt,v:Uint8Array} or throws.
   * We reject images larger than 32767 on either axis, even if otherwise valid.
   */
  decode(src) {
    if (this.isPng(src)) return this.decodePng(src);
    throw new Error(`Image format unknown`);
  }
  
  /* PNG.
   ***************************************************************************/
   
  isPng(src) {
    return (
      (src.length >= 8) &&
      (src[0] === 0x89) &&
      (src[1] === 0x50) &&
      (src[2] === 0x4e) &&
      (src[3] === 0x47) &&
      (src[4] === 0x0d) &&
      (src[5] === 0x0a) &&
      (src[6] === 0x1a) &&
      (src[7] === 0x0a)
    );
  }
   
  decodeHeaderPng(src) {
    // We require IHDR to be the first chunk.
    // The spec does say that, but I've seen violations before.
    if (src.length < 26) throw new Error("Invalid PNG");
    const w = (src[16] << 24) | (src[17] << 16) | (src[18] << 8) | src[19];
    const h = (src[20] << 24) | (src[21] << 16) | (src[22] << 8) | src[23];
    if ((w < 1) || (h < 1) || (w > 0x7fff) || (h > 0x7fff)) throw new Error("Invalid PNG");
    let depth = src[24];
    const colortype = src[25];
    switch (colortype) {
      case 0: break;
      case 2: depth *= 3; break;
      case 3: break;
      case 4: depth *= 2; break;
      case 6: depth *= 4; break;
      default: throw new Error("Invalid PNG");
    }
    let fmt;
    switch (depth) {
      case 1: fmt = 3; break;
      case 8: fmt = 2; break;
      case 32: fmt = 1; break;
      // Anything that isn't 1, 8, or 32 bits/pixel, we coerce to 32 at decode.
      case 2: case 4: case 16: case 24: case 48: case 64: fmt = 1; depth = 32; break;
      default: throw new Error("Invalid PNG");
    }
    const stride = (w * depth + 7) >> 3;
    return {w, h, stride, fmt};
  }
  
  decodePng(src) {
    const chunks = this.dechunkPng(src);
    const ihdr = this.decodePngIhdr(chunks.ihdr);
    let fmt;
    switch (ihdr.pixelsize) {
      case 32: fmt = 1; break;
      case 8: fmt = 2; break;
      case 1: fmt = 3; break;
      default: fmt = 0; // force RGBA after preliminary decode
    }
    const filtered = new Zlib.Inflate(chunks.idat).decompress();
    let dst = new Uint8Array(ihdr.stride * ihdr.h);
    this.unfilterPng(dst, filtered, ihdr.stride, ihdr.xstride);
    if (!fmt) {
      const rgbastride = ihdr.w << 2;
      const rgba = new Uint8Array(rgbastride * ihdr.h);
      this.forceRgba(rgba, rgbastride, dst, ihdr, chunks.plte);
      dst = rgba;
      ihdr.stride = rgbastride;
      fmt = 1;
    }
    return {
      w: ihdr.w,
      h: ihdr.h,
      stride: ihdr.stride,
      fmt,
      v: dst,
    };
  }
  
  dechunkPng(src) {
    const chunks = {};
    for (let srcp=8; srcp<src.length; ) {
      const len = (src[srcp] << 24) | (src[srcp+1] << 16) | (src[srcp+2] << 8) | src[srcp+3];
      srcp += 4;
      const cid = (src[srcp] << 24) | (src[srcp+1] << 16) | (src[srcp+2] << 8) | src[srcp+3];
      srcp += 4;
      switch (cid) {
        case 0x49484452: chunks.ihdr = src.slice(srcp, srcp + len); break;
        case 0x504c5445: chunks.plte = src.slice(srcp, srcp + len); break;
        case 0x49444154: { // IDAT
            if (chunks.idat) {
              const nv = new Uint8Array(chunks.idat.length + len);
              nv.set(chunks.idat);
              const dstview = new Uint8Array(nv.buffer, chunks.idat.length, len);
              dstview.set(src.slice(srcp, srcp + len));
              chunks.idat = nv;
            } else {
              chunks.idat = src.slice(srcp, srcp + len);
            }
          } break;
      }
      srcp += len;
      srcp += 4;
    }
    return chunks;
  }
  
  decodePngIhdr(src) {
    if (!src || (src.length < 13)) throw new Error("Invalid PNG");
    const w = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
    const h = (src[4] << 24) | (src[5] << 16) | (src[6] << 8) | src[7];
    if ((w < 1) || (h < 1) || (w > 0x7fff) || (h > 0x7fff)) throw new Error("Invalid PNG");
    const depth = src[8];
    const colortype = src[9];
    if (src[10] || src[11] || src[12]) {
      // We're not supporting interlaced PNG. Compression and filter, there's only one defined for each.
      throw new Error(`Unsupported PNG compression, filter, or interlace (${src[10]}, ${src[11]}, ${src[12]}`);
    }
    let pixelsize = depth;
    switch (colortype) {
      case 0: break;
      case 2: pixelsize *= 3; break;
      case 3: break;
      case 4: pixelsize *= 2; break;
      case 6: pixelsize *= 4; break;
      default: throw new Error("Invalid PNG");
    }
    const xstride = Math.max(1, pixelsize >> 3);
    const stride = (pixelsize * w + 7) >> 3;
    return { w, h, stride, depth, colortype, pixelsize, xstride };
  }
  
  unfilterPng(dst, src, dststride, xstride) {
    const srcstride = 1 + dststride;
    let dstp=0, srcp=0, dstppv=0;
    const paeth = (a, b, c) => {
      const p = a + b - c;
      const pa = Math.abs(p - a);
      const pb = Math.abs(p - b);
      const pc = Math.abs(p - c);
      if ((pa <= pb) && (pa <= pc)) return a;
      if (pb <= pc) return b;
      return c;
    };
    while (dstp < dst.length) {
      const filter = src[srcp++];
      if (dstp) dstppv = dstp - dststride;
      switch (filter) {
        case 0: {
            for (let i=dststride; i-->0; dstp++, srcp++) dst[dstp] = src[srcp];
          } break;
        case 1: {
            let i=0;
            for (; i<xstride; i++, dstp++, srcp++) dst[dstp] = src[srcp];
            for (; i<dststride; i++, dstp++, srcp++) dst[dstp] = src[srcp] + dst[dstp-xstride];
          } break;
        case 2: {
            if (dstp) {
              for (let i=dststride; i-->0; dstp++, dstppv++, srcp++) dst[dstp] = src[srcp] + dst[dstppv];
            } else {
              for (let i=dststride; i-->0; dstp++, srcp++) dst[dstp] = src[srcp];
            }
          } break;
        case 3: {
            let i=0;
            if (dstp) {
              for (; i<xstride; i++, dstp++, srcp++, dstppv++) dst[dstp] = src[srcp] + (dst[dstppv] >> 1);
              for (; i<dststride; i++, dstp++, srcp++, dstppv++) dst[dstp] = src[srcp] + ((dst[dstp-xstride] + dst[dstppv]) >> 1);
            } else {
              for (; i<xstride; i++, dstp++, srcp++) dst[dstp] = src[srcp];
              for (; i<dststride; i++, dstp++, srcp++) dst[dstp] = src[srcp] + (dst[dstp-xstride] >> 1);
            }
          } break;
        case 4: {
            let i=0;
            if (dstp) {
              for (; i<xstride; i++, dstp++, srcp++, dstppv++) dst[dstp] = src[srcp] + dst[dstppv];
              for (; i<dststride; i++, dstp++, srcp++, dstppv++) dst[dstp] = src[srcp] + paeth(dst[dstp-xstride], dst[dstppv], dst[dstppv-xstride]);
            } else { // PAETH is exactly SUB on the first row, but it is legal.
              for (; i<xstride; i++, dstp++, srcp++) dst[dstp] = src[srcp];
              for (; i<dststride; i++, dstp++, srcp++) dst[dstp] = src[srcp] + dst[dstp-xstride];
            }
          } break;
      }
    }
  }
  
  forceRgba(dst, dststride, src, ihdr, plte) {
    for (
      let dstrowp=0, yi=ihdr.h, srciter=this.iteratePng(src, ihdr, plte);
      yi-->0;
      dstrowp+=dststride
    ) {
      for (let dstp=dstrowp, xi=ihdr.w; xi-->0; ) {
        const rgba = srciter();
        dst[dstp++] = rgba >> 24;
        dst[dstp++] = rgba >> 16;
        dst[dstp++] = rgba >> 8;
        dst[dstp++] = rgba;
      }
    }
  }
  
  // Returns a function that returns every pixel LRTB as 32-bit big-endian RGBA.
  // TODO We're not accepting tRNS chunks. Should we?
  iteratePng(src, ihdr, plte) {
    let rowp=0, p=0, xi=ihdr.w, yi=ihdr.h, mask=0x80, shift;
    
    if (plte && (ihdr.colortype === 3)) { // INDEX
      switch (ihdr.depth) {
        case 1: return () => {
            if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; mask = 0x80; } xi--;
            let ix = (src[p] & mask) ? 1 : 0;
            ix *= 3;
            if (mask === 1) { mask = 0x80; p++; }
            else mask >>= 1;
            return (plte[ix] << 24) | (plte[ix+1] << 16) | (plte[ix+2] << 8) | 0xff;
          };
        case 2: shift = 6; return () => {
            if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; shift = 6; } xi--;
            let ix = (src[p] >> shift) & 3;
            ix *= 3;
            if (shift) shift -= 2;
            else { shift = 6; p++; }
            return (plte[ix] << 24) | (plte[ix+1] << 16) | (plte[ix+2] << 8) | 0xff;
          };
        case 4: shift = 4; return () => {
            if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; shift = 4; } xi--;
            let ix = (src[p] >> shift) & 15;
            ix *= 3;
            if (shift) shift = 0;
            else { shift = 6; p++; }
            return (plte[ix] << 24) | (plte[ix+1] << 16) | (plte[ix+2] << 8) | 0xff;
          };
        case 8: return () => {
            if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
            let ix = src[p++];
            ix *= 3;
            return (plte[ix] << 24) | (plte[ix+1] << 16) | (plte[ix+2] << 8) | 0xff;
          };
      }
      
    } else switch (ihdr.colortype) {
      case 0: case 3: switch (ihdr.depth) { // GRAY (or INDEX with missing PLTE)
          case 1: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; mask = 0x80; } xi--;
              const luma = (src[p] & mask) ? 0xff : 0;
              if (mask === 1) { mask = 0x80; p++; }
              else mask >>= 1;
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
          case 2: shift = 6; return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; shift = 6; } xi--;
              let luma = (src[p] >> shift) & 3;
              luma |= luma << 2;
              luma |= luma << 4;
              if (shift) shift -= 2;
              else { shift = 6; p++; }
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
          case 4: shift = 4; return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; shift = 4; } xi--;
              let luma = (src[p] >> shift) & 15;
              luma |= luma << 4;
              if (shift) shift = 0;
              else { shift = 6; p++; }
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
          case 8: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const luma = src[p++];
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
          case 16: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const luma = src[p];
              p += 2;
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
        } break;
      case 2: switch (ihdr.depth) { // RGB
          case 8: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const r = src[p++];
              const g = src[p++];
              const b = src[p++];
              return (r << 24) | (g << 16) | (b << 8) | 0xff;
            };
          case 16: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const r = src[p++]; p++;
              const g = src[p++]; p++;
              const b = src[p++]; p++;
              return (r << 24) | (g << 16) | (b << 8) | 0xff;
            };
        } break;
      case 4: switch (ihdr.depth) { // YA
          case 8: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const luma = src[p++];
              const alpha = src[p++];
              return (luma << 24) | (luma << 16) | (luma << 8) | alpha;
            };
          case 16: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const luma = src[p++]; p++;
              const alpha = src[p++]; p++;
              return (luma << 24) | (luma << 16) | (luma << 8) | alpha;
            };
        } break;
      case 6: switch (ihdr.depth) { // RGBA
          case 8: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const r = src[p++];
              const g = src[p++];
              const b = src[p++];
              const a = src[p++];
              return (r << 24) | (g << 16) | (b << 8) | a;
            };
          case 16: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const r = src[p++]; p++;
              const g = src[p++]; p++;
              const b = src[p++]; p++;
              const a = src[p++]; p++;
              return (r << 24) | (g << 16) | (b << 8) | a;
            };
        } break;
    }
    return () => 0;
  }
}
 /* Audio.js
 * Implements our synthesizer and exposes the public API.
 */




 
class Audio {
  constructor(egg) {
    this.egg = egg;
    
    this.rate = 44100; // TODO configurable?
    this.context = null;
    this.song = null;
    this.channels = [
      null, null, null, null,
      null, null, null, null,
      null, null, null, null,
      null, null, null, null,
    ];
    this.voices = [];
    this.sounds = {}; // key:"QUAL.RID", value:AudioBuffer
    this.soundEffects = [];
    this.noise = null; // AudioBuffer, null until we need it.
    
    this.hzByNoteid = [];
    for (let noteid=0; noteid<0x80; noteid++) {
      this.hzByNoteid.push(440 * Math.pow(2, (noteid - 69) / 12));
    }
  }
  
  start() {
    if (!window.AudioContext) return;
    this.context = new window.AudioContext({
      sampleRate: this.rate,
      latencyHint: "interactive",
    });
    if (this.context.state === "suspended") {
      this.context.resume();
    }
  }
  
  stop() {
    this.endSong();
    //TODO
  }
  
  update() {
    for (let i=this.voices.length; i-->0; ) {
      const voice = this.voices[i];
      if (!voice.isFinished()) continue;
      voice.terminate();
      this.voices.splice(i, 1);
    }
    if (this.song) {
      this.song.update();
    }
  }
  
  /* Public API.
   *****************************************************************/
  
  egg_audio_play_song(qual, songid, force, repeat) {
    if (!force && this.song && this.song.isResource(qual, songid)) return;
    this.endSong();
    const serial = this.egg.rom.getRes(Rom.RESTYPE_song, qual, songid);
    if (!serial || !serial.length) return;
    try {
      this.song = new Song(serial, this, repeat, qual, songid);
    } catch (e) {
      console.error(`Failed to play song:${qual}:${songid}.`, e);
      return;
    }
    this.beginSong();
  }
  
  egg_audio_play_sound(qual, soundid, trim, pan, when) {
    if (!this.context) return;
    trim /= 65536;
    pan /= 65536;
    if (!when) when = this.context.currentTime;
    const pcm = this.acquireSound(qual, soundid);
    if (!pcm) return;
    const node = new AudioBufferSourceNode(this.context, {
      buffer: pcm,
      channelCount: 1,
    });
    const gain = new GainNode(this.context, { gain: trim });
    node.connect(gain);
    gain.connect(this.context.destination);
    node.start(when);
    node.eggStartTime = when;
    this.soundEffects.push(node);
    node.onended = () => {
      const p = this.soundEffects.indexOf(node);
      if (p >= 0) this.soundEffects.splice(p, 1);
    };
  }
  
  egg_audio_event(chid, opcode, a, b) {
    switch (opcode) {
      case 0x80: this.endNote(chid, a, b); break;
      case 0x90: this.playNote(chid, a, b, 5.0, 0/*this.context.currentTime*/); break;
    }
  }
  
  egg_audio_get_playhead() {
    if (!this.song) return -1;
    let elapsed = this.context.currentTime - this.song.startTime;
    if (this.song.durations) elapsed %= this.song.durations;
    return (elapsed * 1000) / this.song.msperqnote;
  }
  
  egg_audio_set_playhead(beat) {
    if (!this.song) return;
    this.stopVoices();
    //TODO Set playhead. This is actually pretty tough to manage. Punt.
  }
  
  /* Internals.
   ******************************************************************/
   
  endSong() {
    if (!this.song) return;
    this.song = null;
    this.stopVoices();
  }
  
  stopVoices() {
    for (const voice of this.voices) voice.release();
    for (let chid=0; chid<8; chid++) {
      if (this.channels[chid]) {
        this.channels[chid].stop();
        this.channels[chid] = null;
      }
    }
    const now = this.context.currentTime;
    for (let i=this.soundEffects.length; i-->0; ) {
      const node = this.soundEffects[i];
      if (node.eggStartTime && (node.eggStartTime >= now)) {
        node.disconnect();
        this.soundEffects.splice(i, 1);
      }
    }
  }
  
  beginSong() {
    if (!this.song) return;
    for (let i=0; i<8; i++) {
      this.channels[i] = null;
      const src = this.song.channels[i];
      if (!src.volume) continue;
      this.channels[i] = new Channel(this, src.pid, src.volume, src.pan);
    }
  }
  
  acquireSound(qual, rid) {
    if (!this.context) return null;
    const key = `${qual}.${rid}`;
    if (key in this.sounds) return this.sounds[key];
    let v = null;
    const serial = this.egg.rom.getRes(Rom.RESTYPE_sound, qual, rid);
    if (serial && serial.length) {
      const fv = new SfgPrinter(serial, this.rate).print();
      if (fv && fv.length) {
        v = new AudioBuffer({
          length: fv.length,
          numberOfChannels: 1,
          sampleRate: this.rate,
          channelCount: 1,
        });
        v.copyToChannel(fv, 0);
      }
    }
    this.sounds[key] = v;
    return v;
  }
  
  endNote(chid, noteid, velocity) {
    const p = this.voices.findIndex(v => ((v.eggChid === chid) && (v.eggNoteid = noteid)));
    if (p < 0) return;
    const voice = this.voices[p];
    voice.eggChid = -1;
    voice.eggNoteid = -1;
    voice.release();
  }
  
  // (velocity) in 0..127 like MIDI. (when) in AudioContext time.
  playNote(chid, noteid, velocity, durs, when) {
    let channel = this.channels[chid];
    //console.log(`Audio.playNote`, { chid, noteid, velocity, durs, when, channel });
    if (!channel) {
      if ((chid < 0) || (chid >= 16)) return;
      channel = this.channels[chid] = new Channel(this, 0x00, 0x80, 0x80);
    }
    const voice = channel.playNote(this, noteid, velocity / 127.0, durs, when);
    if (!voice) return;
    voice.eggChid = chid;
    voice.eggNoteid = noteid;
  }
  
  // (v) in 0..0x3fff like MIDI. (when) in AudioContext time.
  changeWheel(chid, v, when) {
    const channel = this.channels[chid];
    if (!channel) return;
    if (!channel.wheelRange) return;
    if (v === channel.wheel) return;
    channel.wheel = v;
    channel.wheelCents = ((v - 0x2000) * channel.wheelRange) / 0x2000;
    //TODO Apply to in-flight voices. Must respect (when) too!
  }
  
  requireNoise() {
    if (this.noise) return;
    const fv = new Float32Array(this.rate);
    for (let i=fv.length; i-->0; ) fv[i] = Math.random() * 2 - 1;
    this.noise = new AudioBuffer({
      length: fv.length,
      numberOfChannels: 1,
      sampleRate: this.rate,
      channelCount: 1,
    });
    this.noise.copyToChannel(fv, 0);
  }
}

/* Song.
 **********************************************************************/
 
const SONG_READAHEAD_WINDOW_S = 0.500;
 
class Song {
  constructor(src, audio, repeat, qual, songid) {
    this.audio = audio;
    this.repeat = repeat;
    this.qual = qual;
    this.songid = songid;
    if (!(src instanceof Uint8Array)) throw new Error(`Expected Uint8Array`);
    if (src.length < 42) throw new Error(`Invalid song`);
    if ((src[0] !== 0xbe) || (src[1] !== 0xee) || (src[2] !== 0xee) || (src[3] !== 0x50)) throw new Error(`Invalid song`);
    this.msperqnote = (src[4] << 8) | src[5];
    this.startp = (src[6] << 8) | src[7];
    this.loopp = (src[8] << 8) | src[9];
    if ((this.startp < 42) || (this.loopp < this.startp) || (this.loopp >= src.length)) throw new Error(`Invalid song`);
    this.src = src;
    this.channels = [];
    for (let srcp=10; srcp<42; srcp+=4) {
      this.channels.push({
        pid: src[srcp],
        volume: src[srcp+1],
        pan: src[srcp+2],
        rsv: src[srcp+3],
      });
    }
    this.startTime = audio.context.currentTime;
    this.readp = this.startp;
    this.readTime = this.startTime;
    this.durations = 0; // Zero until the first loop.
    this.durationPending = 0;
  }
  
  isResource(qual, songid) {
    return ((qual === this.qual) && (songid === this.songid));
  }
  
  update() {
    const now = this.audio.context.currentTime;
    const later = now + SONG_READAHEAD_WINDOW_S;
    while (this.readTime < later) {
      const event = this.readEvent();
      
      // End of song?
      if (!event) {
        this.audio.endSong();
        return;
      }
      
      // Delay?
      if (typeof(event) === "number") {
        this.readTime += event;
        if (!this.durations) this.durationPending += event;
        continue;
      }
      
      // Anything else, readEvent() dispatched it. Carry on.
    }
  }
  
  /* Advance readp and return one event:
   *  - null: EOF and not repeating.
   *  - number: Delay, seconds. Never zero.
   *  - "ok": Processed one event (we dispatch it from here).
   */
  readEvent() {
    const lead = this.src[this.readp++];
    
    // Zero or end of input is End of Song.
    if (!lead) {
      if (!this.durations) this.durations = this.durationPending;
      if (!this.repeat) return null;
      this.readp = this.loopp;
      // Must delay a little, in case the song has no explicit delays, so we don't loop forever.
      // Note that if this happens, it's a disaster no matter what.
      return 0.010;
    }
    
    // High bit unset is a delay in ms.
    if (!(lead & 0x80)) {
      return lead / 1000;
    }

    // 1000vvvv cccnnnnn nntttttt : NOTE. duration=(t<<5)ms (~2s max)
    if ((lead & 0xf0) === 0x80) {
      const a = this.src[this.readp++] || 0;
      const b = this.src[this.readp++] || 0;
      let velocity = (lead & 0x0f) << 3;
      velocity |= velocity >> 4;
      const chid = a >> 5;
      const noteid = ((a & 0x1f) << 2) | (b >> 6);
      const durms = ((b & 0x3f) << 5);
      this.audio.playNote(chid, noteid, velocity, durms / 1000, this.readTime);
      return "ok";
    }
    
    // 1001vvcc cnnnnnnn : FIREFORGET. Same as NOTE but duration zero (and coarser velocity).
    if ((lead & 0xf0) === 0x90) {
      const a = this.src[this.readp++] || 0;
      let velocity = ((lead & 0x0c) << 2);
      velocity |= velocity >> 2;
      velocity |= velocity >> 4;
      const chid = ((lead & 0x03) << 1) | (a >> 7);
      const noteid = (a & 0x7f);
      this.audio.playNote(chid, noteid, velocity, 0, this.readTime);
      return "ok";
    }
    
    // 10100ccc wwwwwwww : WHEEL. 8 bits unsigned. 0x40 by default.
    if ((lead & 0xf8) === 0xa0) {
      const a = this.src[this.readp++] || 0;
      const chid = lead & 0x07;
      const v = (a << 6) | (a >> 2);
      this.audio.changeWheel(chid, v, this.readTime);
      return "ok";
    }
    
    // Anything else is reserved and illegal. End the song.
    console.log(`Illegal song command ${lead}.`);
    return null;
  }
}

/* Channel.
 *********************************************************************/
 
class Channel {
  constructor(audio, pid, volume, pan) {
    this.audio = audio;
    this.pid = pid;
    this.volume = volume / 255.0;
    this.master = 0.250;
    this.pan = (pan - 0x80) / 128.0;
    this.mode = "noop";
    this.wheelRange = 200; // cents
    this.wheel = 0; // Last value, 0..0x3fff
    this.wheelCents = 0;
    
    if (this.pid < 0x00) this._initNoop();
    else if (this.pid < 0x80) this._initBuiltin(audio);
    else if (this.pid < 0x100) this._initDrum();
    else this._initNoop();
  }
  
  _initNoop() {
    this.mode = "noop";
    this.wheelRange = 0;
  }
  
  _initDrum() {
    this.mode = "drum";
    this.wheelRange = 0;
    this.drumBase = (this.pid - 0x80) * 0x80;
  }
  
  _initBuiltin(audio) {
    let cfg = Instruments[this.pid];
    if (typeof(cfg) === "number") {
      cfg = Instruments[cfg];
    }
    if (!cfg) return this._initNoop();
    if (typeof(cfg) === "string") {
      this.mode = cfg;
      return;
    }
    for (const k of Object.keys(cfg)) {
      this[k] = cfg[k];
    }
    if (this.wave) {
      this.wave = new PeriodicWave(audio.context, { real: this.wave });
    }
    if (this.mode === "fx") {
      this.fxBegin(audio);
    }
  }
  
  // (velocity) normalized
  playNote(audio, noteid, velocity, durs, when) {
    switch (this.mode) {
      case "noop": break;
      
      case "drum": {
          const soundid = this.drumBase + noteid;
          const trim = 0.200 + (this.volume * this.master * velocity) * 0.900;
          audio.egg_audio_play_sound(0, soundid, trim * 65536.0, this.pan, when);
        } break;
        
      case "blip": {
          const attackTime = 0.010;
          const releaseTime = 0.050;
          const level = this.volume * this.master * (velocity + 0.079) * 0.400;
          const voice = new Voice(audio);
          voice.oscillateShape("square", audio.hzByNoteid[noteid], this.wheelCents);
          voice.plateauLevel(when, attackTime, level, durs, releaseTime);
          voice.begin();
          return voice;
        }
        
      case "wave": {
          const voice = new Voice(audio);
          voice.oscillateWave(this.wave, audio.hzByNoteid[noteid], this.wheelCents);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
          return voice;
        }
        
      case "rock": {
          const voice = new Voice(audio);
          voice.oscillateMix(this.wave, this.mix, audio.hzByNoteid[noteid], this.wheelCents);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
          return voice;
        }
        
      case "fmrel": {
          const voice = new Voice(audio);
          voice.oscillateFmRelative(audio.hzByNoteid[noteid], this.wheelCents, this.fmRate, this.fmRangeScale, this.fmRangeEnv);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
          return voice;
        }
        
      case "fmabs": {
          const voice = new Voice(audio);
          voice.oscillateFmAbsolute(audio.hzByNoteid[noteid], this.wheelCents, this.fmRate, this.fmRangeScale, this.fmRangeEnv);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
          return voice;
        }
        
      case "sub": {
          const voice = new Voice(audio);
          voice.oscillateSubtractive(audio.hzByNoteid[noteid], this.wheelCents, this.subQ1, this.subQ2, this.subGain);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
          return voice;
        }
        
      case "fx": {
          return this.fxNote(audio, when, noteid, velocity, durs);
        }
    }
  }
  
  stop() {
    switch (this.mode) {
      case "fx": this.fxStop(); break;
    }
  }
  
  fxBegin(audio) {
    this.audio = audio;
    this.fxMaster = new GainNode(audio.context);
    this.fxMaster.gain.setValueAtTime(this.volume * this.master, 0);
    this.fxMaster.connect(audio.context.destination);
    this.fxVoices = [];
    this.fxAttach = this.fxMaster;
    
    //TODO detune. Can't do it in post like the C implementation, but I think we can vary the voice's frequencies.
    
    if ((this.fmRangeLfo > 0) && (this.fmRangeLfoDepth > 0)) {
      let beatRate = 2;
      if (this.audio.song && (this.audio.song.msperqnote > 0)) {
        beatRate = 1000 / this.audio.song.msperqnote;
      }
      const osc = new OscillatorNode(this.audio.context, {
        type: "sine",
        frequency: beatRate / this.fmRangeLfo,
      });
      const gain = new GainNode(this.audio.context, {
        gain: this.fmRangeLfoDepth * 100, // TODO No idea why this *100 is needed.
      });
      osc.connect(gain);
      osc.start();
      this.fmLfo = osc;
      this.fmLfoOut = gain;
    }
    
    if ((this.delayRate > 0) && (this.delayDepth > 0) && this.audio.song && (this.audio.song.msperqnote > 0)) {
      const wetLevel = this.delayDepth * 0.500;
      const dryLevel = 1 - wetLevel;
      const period = (this.delayRate * this.audio.song.msperqnote) / 1000;
      const delay = new DelayNode(this.audio.context, { delayTime: period });
      
      const intake = new GainNode(this.audio.context, { gain: 1 });
      const output = new GainNode(this.audio.context, { gain: 1 });
      const dryGain = new GainNode(this.audio.context, { gain: dryLevel });
      const wetGain = new GainNode(this.audio.context, { gain: wetLevel });
      intake.connect(dryGain);
      dryGain.connect(output);
      intake.connect(delay);
      delay.connect(wetGain);
      wetGain.connect(delay);
      wetGain.connect(output);
      output.connect(this.fxAttach);
      this.fxAttach = intake;
    }
    
    if (this.overdrive > 0) {
      const len = 99;
      const odrange = 8;
      const midp = len >> 1;
      const odscaled = 0.5 + this.overdrive * (odrange - 0.5);
      const odcurved = 1 / odscaled; // Now in (1/odrange)..2
      const odnormed = (odcurved - 1 / odrange) / (2 - 1 / odrange);
      const ramplen = midp * odnormed;
      const vv = new Float32Array(len);
      for (let i=0; i<ramplen; i++) {
        vv[midp + i + 1] = Math.sin((i * Math.PI / 2) / ramplen);
      }
      for (let i=midp+ramplen+1; i<len; i++) {
        vv[i] = 1;
      }
      for (let dst=midp, src=midp+1; dst-->0; src++) {
        vv[dst] = -vv[src];
      }
      const shaper = new WaveShaperNode(this.audio.context, {
        curve: vv,
      });
      // Also some attenuation, after the wave-shape, since we're raising its average level.
      if (this.overdrive >= 0.25) {
        const drop = new GainNode(this.audio.context, {
          gain: 1 - (this.overdrive - 0.25) * 0.8,
        });
        shaper.connect(drop);
        drop.connect(this.fxAttach);
      } else {
        shaper.connect(this.fxAttach);
      }
      this.fxAttach = shaper;
    }
  }
  
  fxStop() {
    if (this.fxMaster) {
      this.fxMaster.disconnect();
      this.fxMaster = null;
    }
    if (this.fmLfo) {
      this.fmLfo.stop();
      this.fmLfo.disconnect();
      this.fmLfo = null;
    }
    if (this.fmLfoOut) {
      this.fmLfoOut.disconnect();
      this.fmLfoOut = null;
    }
  }
  
  fxNote(audio, when, noteid, velocity, durs) {
    const voice = new Voice(this.audio);
    voice.oscillateFmRelative(this.audio.hzByNoteid[noteid], this.wheelCents, this.fmRate, this.fmRangeScale, this.fmRangeEnv, this.fmLfoOut);
    voice.tinyEnv(when, this.levelTiny, durs, velocity, 1);
    voice.begin(this.fxAttach);
    return voice;
  }
}

/* Voice.
 *******************************************************************/
 
class Voice {
  constructor(audio) {
    this.audio = audio;
    this.osc = null;
    this.env = null;
    this.endTime = 0;
  }
  
  isFinished() {
    if (!this.audio || !this.audio.context || !this.env) return true;
    return (this.audio.context.currentTime > this.endTime);
  }
  
  terminate() {
    if (this.env) {
      this.env.disconnect();
      this.env = null;
    }
    if (this.osc) {
      if (this.osc.stop) this.osc.stop();
      this.osc.disconnect();
      this.osc = null;
    }
    if (this.oscDry) {
      this.oscDry.stop();
      this.oscDry.disconnect();
      this.oscDry = null;
    }
    if (this.oscWet) {
      this.oscWet.stop();
      this.oscWet.disconnect();
      this.oscWet = null;
    }
    if (this.modosc) {
      this.modosc.stop();
      this.modosc.disconnect();
      this.modosc = null;
    }
    if (this.noiseNode) {
      this.noiseNode.stop();
      this.noiseNode.disconnect();
      this.noiseNode = null;
    }
    if (this.post) {
      this.post.disconnect();
      this.post = null;
    }
  }
  
  release() {
    if (!this.audio || !this.audio.context) {
      this.terminate();
      return;
    }
    const now = this.audio.context.currentTime;
    if (this.startTime && (this.startTime <= now)) {
      this.terminate();
      return;
    }
    const endTime = now + 0.100;
    if (this.env) {
      this.env.gain.setValueAtTime(this.env.gain.value, now);
      this.env.gain.linearRampToValueAtTime(0, endTime);
    }
    this.endTime = endTime;
  }
  
  begin(dst) {
    if (!this.audio || !this.env) return;
    if (!dst) dst = this.audio.context.destination;
    if (this.osc) {
      this.osc.connect(this.env);
      if (this.osc.start) this.osc.start();
    } else if (this.gainDry) {
      this.gainDry.connect(this.env);
      this.gainWet.connect(this.env);
      this.oscDry.start();
      this.oscWet.start();
    } else {
      return;
    }
    if (this.post) this.post.connect(dst);
    else this.env.connect(dst);
    this.audio.voices.push(this);
  }
  
  oscillateShape(type, frequency, detune) {
    this.osc = new OscillatorNode(this.audio.context, {
      type,
      frequency,
      detune,
    });
  }
  
  oscillateWave(periodicWave, frequency, detune) {
    this.osc = new OscillatorNode(this.audio.context, {
      periodicWave,
      frequency,
      detune,
    });
  }
  
  // (mix) is 4 levels, 4 bits each, big-endian. eg 0xf842 = [1.0, 0.5, 0.25, 0.125]
  oscillateMix(periodicWave, mix, frequency, detune) {
    this.oscDry = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency,
      detune,
    });
    this.oscWet = new OscillatorNode(this.audio.context, {
      periodicWave,
      frequency,
      detune,
    });
    this.gainDry = new GainNode(this.audio.context);
    this.gainWet = new GainNode(this.audio.context);
    this.oscDry.connect(this.gainDry);
    this.oscWet.connect(this.gainWet);
    this.mix = mix;
  }
  
  oscillateFmRelative(frequency, detune, rate, scale, env, lfo) {
    this.osc = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency,
      detune,
    });
    this.modosc = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency: frequency * rate * Math.pow(2, detune / 1200),
    });
    this.modgain = new GainNode(this.audio.context);
    if (lfo) {
      this.fmGainLfo = lfo;
      this.fmGainLfo.connect(this.modgain.gain);
      this.modgain.gain.setValueAtTime(1, 0);
      this.modgain.connect(this.osc.frequency);
    } else {
      this.modgain.connect(this.osc.frequency);
    }
    this.modgainPeak = scale * frequency;
    this.fmRangeEnv = env;
    this.modosc.connect(this.modgain);
    this.modosc.start();
  }
  
  oscillateFmAbsolute(frequency, detune, rate, scale, env) {
    this.osc = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency,
      detune,
    });
    this.modosc = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency: rate,
    });
    this.modgain = new GainNode(this.audio.context);
    this.modgainPeak = scale * frequency;
    this.fmRangeEnv = env;
    this.modgain.connect(this.osc.frequency);
    this.modosc.connect(this.modgain);
    this.modosc.start();
  }
  
  oscillateSubtractive(frequency, detune, q1, q2, gain) {
    this.audio.requireNoise();
    this.noiseNode = new AudioBufferSourceNode(this.audio.context, {
      buffer: this.audio.noise,
      channelCount: 1,
      loop: true,
      loopStart: 0,
      loopEnd: this.audio.noise.duration,
    });
    const filter1 = new BiquadFilterNode(this.audio.context, {
      type: "bandpass",
      Q: q1,
      frequency,
    });
    const filter2 = new BiquadFilterNode(this.audio.context, {
      type: "bandpass",
      Q: q2,
      frequency,
    });
    const gainNode = new GainNode(this.audio.context);
    gainNode.gain.setValueAtTime(gain, 0);
    this.noiseNode.connect(filter1);
    filter1.connect(filter2);
    filter2.connect(gainNode);
    this.osc = gainNode;
    this.noiseNode.start();
  }
  
  plateauLevel(when, attackTimeRel, peakLevel, sustainTimeRel, releaseTimeRel) {
    this.startTime = when;
    if (!when) when = this.audio.context.currentTime;
    this.endTime = when + attackTimeRel + sustainTimeRel + releaseTimeRel;
    this.env = new GainNode(this.audio.context);
    this.env.gain.setValueAtTime(0, 0);
    this.env.gain.setValueAtTime(0, when);
    this.env.gain.linearRampToValueAtTime(peakLevel, when + attackTimeRel);
    this.env.gain.setValueAtTime(peakLevel, when + attackTimeRel + sustainTimeRel);
    this.env.gain.linearRampToValueAtTime(0, this.endTime);
  }
  
  /* A format I use in the C implementation for single-byte level envelopes:
   *   0xc0 Decay relative to attack:
   *         0x00 IMPULSE: Do not sustain.
   *         0x40 PLUCK: Heavy loss after attack.
   *         0x80 TONE: Attack noticeably louder than sustain.
   *         0xc0 BOW: No appreciable attack.
   *   0x38 Attack time: 0x00=Fast .. 0x38=Slow
   *   0x07 Release time: 0x00=Short .. 0x07=Long
   */
  tinyEnv(when, v, durs, velocity, trim) {
    this.startTime = when;
    if (!when) when = this.audio.context.currentTime;
    let attackTimeHi;
    switch (v & 0x38) {
      case 0x00: attackTimeHi = 0.005; break;
      case 0x08: attackTimeHi = 0.008; break;
      case 0x10: attackTimeHi = 0.012; break;
      case 0x18: attackTimeHi = 0.018; break;
      case 0x20: attackTimeHi = 0.030; break;
      case 0x28: attackTimeHi = 0.045; break;
      case 0x30: attackTimeHi = 0.060; break;
      case 0x38: attackTimeHi = 0.080; break;
    }
    let releaseTimeHi;
    switch (v & 0x07) {
      case 0x00: releaseTimeHi = 0.040; break;
      case 0x01: releaseTimeHi = 0.060; break;
      case 0x02: releaseTimeHi = 0.100; break;
      case 0x03: releaseTimeHi = 0.200; break;
      case 0x04: releaseTimeHi = 0.400; break;
      case 0x05: releaseTimeHi = 0.600; break;
      case 0x06: releaseTimeHi = 0.800; break;
      case 0x07: releaseTimeHi = 1.200; break;
    }
    let sustain = true;
    let attackValueHi = 1;
    let sustainValueHi;
    switch (v & 0xc0) {
      case 0x00: { // IMPULSE
          sustain = false;
          sustainValueHi = 0.250;
        } break;
      case 0x40: { // PLUCK
          sustainValueHi = 0.200;
        } break;
      case 0x80: { // TONE
          attackValueHi = 0.750;
          sustainValueHi = 0.400;
        } break;
      case 0xc0: { // BOW
          attackValueHi = 0.400;
          sustainValueHi = 0.400;
        } break;
    }
    let decayTimeHi = (attackTimeHi * 3) / 2;
    const attackTimeLo = attackTimeHi * 2;
    const decayTimeLo = decayTimeHi * 2;
    const releaseTimeLo = releaseTimeHi * 0.5;
    const attackValueLo = attackValueHi * 0.333;
    const sustainValueLo = sustainValueHi * 0.500;
    let a, b;
    if (velocity <= 0) { a=1; b=0; }
    else if (velocity >= 1) { a=0; b=1; }
    else { a = 1 - velocity; b = velocity; }
    const attackTime = attackTimeLo * a + attackTimeHi * b;
    const attackValue = (attackValueLo * a + attackValueHi * b) * trim;
    const decayTime = decayTimeLo * a + decayTimeHi * b;
    const sustainValue = (sustainValueLo * a + sustainValueHi * b) * trim;
    if (!sustain) durs = 0;
    const releaseTime = releaseTimeLo * a + releaseTimeHi * b;
    this.endTime = when + attackTime + decayTime + durs + releaseTime;
    
    this.env = new GainNode(this.audio.context);
    this.env.gain.setValueAtTime(0, 0);
    this.env.gain.setValueAtTime(0, when);
    this.env.gain.linearRampToValueAtTime(attackValue, when + attackTime);
    this.env.gain.linearRampToValueAtTime(sustainValue, when + attackTime + decayTime);
    this.env.gain.setValueAtTime(sustainValue, when + attackTime + decayTime + durs);
    this.env.gain.linearRampToValueAtTime(0, this.endTime);
    
    if (this.gainDry && this.gainWet) {
      const v0 = (this.mix >> 12) / 15.0;
      const v1 = ((this.mix >> 8) & 15) / 15.0;
      const v2 = ((this.mix >> 4) & 15) / 15.0;
      const v3 = (this.mix & 15) / 15.0;
      this.gainDry.gain.setValueAtTime(0, 0);
      this.gainDry.gain.setValueAtTime(1 - v0, when);
      this.gainDry.gain.linearRampToValueAtTime(1 - v1, when + attackTime);
      this.gainDry.gain.linearRampToValueAtTime(1 - v2, when + attackTime + decayTime);
      this.gainDry.gain.linearRampToValueAtTime(1 - v2, when + attackTime + decayTime + durs);
      this.gainDry.gain.linearRampToValueAtTime(1 - v3, this.endTime);
      this.gainWet.gain.setValueAtTime(0, 0);
      this.gainWet.gain.setValueAtTime(v0, when);
      this.gainWet.gain.linearRampToValueAtTime(v1, when + attackTime);
      this.gainWet.gain.linearRampToValueAtTime(v2, when + attackTime + decayTime);
      this.gainWet.gain.linearRampToValueAtTime(v2, when + attackTime + decayTime + durs);
      this.gainWet.gain.linearRampToValueAtTime(v3, this.endTime);
    }
    
    if (this.fmRangeEnv && !this.fmRangeLfo) {
      if (this.fmRangeEnv === 0xffff) {
        this.modgain.gain.setValueAtTime(this.modgainPeak, 0);
      } else {
        const v0hi = (this.modgainPeak * (this.fmRangeEnv >> 12)) / 15.0;
        const v1hi = (this.modgainPeak * ((this.fmRangeEnv >> 8) & 15)) / 15.0;
        const v2hi = (this.modgainPeak * ((this.fmRangeEnv >> 4) & 15)) / 15.0;
        const v3hi = (this.modgainPeak * (this.fmRangeEnv & 15)) / 15.0;
        const avg = (v0hi + v1hi + v2hi + v3hi) / 4;
        const v0lo = (v0hi + avg) / 2;
        const v1lo = (v1hi + avg) / 2;
        const v2lo = (v2hi + avg) / 2;
        const v3lo = (v3hi + avg) / 2;
        const v0 = v0lo * (1 - velocity) + v0hi * velocity;
        const v1 = v1lo * (1 - velocity) + v1hi * velocity;
        const v2 = v2lo * (1 - velocity) + v2hi * velocity;
        const v3 = v3lo * (1 - velocity) + v3hi * velocity;
        this.modgain.gain.setValueAtTime(v0, 0);
        this.modgain.gain.setValueAtTime(v0, when);
        this.modgain.gain.linearRampToValueAtTime(v1, when + attackTime);
        this.modgain.gain.linearRampToValueAtTime(v2, when + attackTime + decayTime);
        this.modgain.gain.setValueAtTime(v2, when + attackTime + decayTime + durs);
        this.modgain.gain.linearRampToValueAtTime(v3, this.endTime);
      }
    }
  }
}
/* SysExtra.js
 * Little helpers for the public API. Log, date, language...
 */
 
class SysExtra {
  constructor(window) {
    this.window = window;
    this.storage = null;
    this.storageKey = "egg"; // Set before the first access.
  }
  
  /* Returns:
   * {
   *   srcc: Length of (src) consumed.
   *   align: -1|0|1.
   *   fill: ' ' or '0'.
   *   len: integer or "*" to read from vargs.
   *   prec: integer or "*" to read from vargs, <0 if unspecified.
   *   value: null, you fill in from vargs.
   *   spec: Single character.
   * }
   * Or null if malformed.
   */
  parseLogFormatUnit(src, srcp) {
    const srcp0 = srcp;
    if (srcp >= src.length) return null;
    if (src[srcp++] !== '%') return null;
    
    let align = 1;
    if (src[srcp] === '-') {
      align = -1;
      srcp++;
    } else if (src[srcp] === '+') {
      align = 1;
      srcp++;
    } else if (src[srcp] === '=') {
      align = 0;
      srcp++;
    }
    
    let fill = ' ';
    if (src[srcp] === '0') {
      fill = '0';
      srcp++;
    }
    
    let len = 0;
    if (src[srcp] === '*') {
      len = '*';
      srcp++;
    } else while ((src[srcp] >= '0') && (src[srcp] <= '9')) {
      len *= 10;
      len += src.charCodeAt(srcp) - 0x30;
      srcp++;
    }
    
    let prec = -1;
    if (src[srcp] === '.') {
      srcp++;
      if (src[srcp] === '*') {
        prec = '*';
        srcp++;
      } else {
        prec = 0;
        while ((src[srcp] >= '0') && (src[srcp] <= '9')) {
          prec *= 10;
          prec += src.charCodeAt(srcp) - 0x30;
          srcp++;
        }
      }
    }
    
    let spec;
    switch (src[srcp]) {
      case 'd':
      case 'x':
      case 'p':
      case 'l':
      case 'f':
      case 's':
      case 'c': {
          spec = src[srcp];
          srcp++;
        } break;
      default: return null;
    }
    return { srcc: srcp - srcp0, fill, align, len, prec, spec, value: null };
  }
  
  applyLogFormatUnit(unit) {
    let pre = "";
    switch (unit.spec) {
      case 'u': pre = (~~unit.value || 0).toString(); break;
      case 'd': pre = (~~unit.value || 0).toString(); break;
      case 'x': pre = (~~unit.value || 0).toString(16); break;
      case 'p': pre = (~~unit.value || 0).toString(16); break;
      case 'l': pre = (~~unit.value || 0).toString(); break;
      case 'f': pre = (+unit.value).toString(); break; // TODO prec
      case 's': pre = (unit.value || "").toString(); if (unit.prec >= 0) pre = pre.substring(0, unit.prec); break;
      case 'c': pre = String.fromCharCode(~~unit.value || 0x3f); break;
    }
    let spaces = "                              ";
    if (unit.fill === '0') {
      spaces = "0000000000000000000000000000000000";
    }
    if (pre.length < unit.len) switch (unit.align) {
      case -1: pre += spaces.substring(0, unit.len - pre.length); break;
      case 0: {
          const addc = unit.len - pre.length;
          const each = addc >> 1;
          const more = addc & 1;
          pre = spaces.substring(0, each) + pre +spaces.substring(0, each + more);
        } break;
      case 1: pre = spaces.substring(0, unit.len - pre.length) + pre; break;
    }
    return pre;
  }
  
  /* (vargs) can be an array of values or an iterator function: (spec:[udxplfsc],prec) => any
   */
  applyLogFormat(fmt, vargs) {
    if (!fmt) return "";
    if (!vargs) return fmt;
    let fmtp=0, vargsp=0, dst="";
    while (fmtp < fmt.length) {
      let nextp = fmt.indexOf('%', fmtp);
      if (nextp < 0) nextp = fmt.length;
      if (nextp > fmtp) {
        dst += fmt.substring(fmtp, nextp);
        fmtp = nextp;
        if (fmtp >= fmt.length) break;
      }
      if (fmt[fmtp + 1] === '%') {
        dst += "%";
        fmtp += 2;
        continue;
      }
      const unit = this.parseLogFormatUnit(fmt, fmtp);
      if (!unit) {
        dst += fmt[fmtp++];
        continue;
      }
      fmtp += unit.srcc;
      if (typeof(vargs) === "function") {
        if (unit.len === "*") unit.len = vargs('u');
        if (unit.prec === "*") unit.prec = vargs('u');
        unit.value = vargs(unit.spec, unit.prec);
      } else {
        if (unit.len === "*") unit.len = vargs[vargsp++] || 0;
        if (unit.prec === "*") unit.prec = vargs[vargsp++] || 0;
        unit.value = vargs[vargsp++];
      }
      dst += this.applyLogFormatUnit(unit);
    }
    return dst;
  }
  
  getUserLanguages() {
    let list = this.window.navigator.languages;
    if (list && (list.length > 0)) {
      list = Array.from(new Set(list.map(l => this.evalLang(l)).filter(v => v)));
    }
    if (!list) list = [];
    if (!list.length) {
      const code = this.evalLang(this.window.navigator.language);
      if (code) list.push(code);
    }
    return list;
  }
  
  evalLang(src) {
    if (!src) return 0;
    if (src.length >= 2) {
      let a = src.charCodeAt(0);
      let b = src.charCodeAt(1);
      if ((a >= 0x61) && (a <= 0x7a)) a = a - 0x61 + 6;
      else if ((a >= 0x30) && (a <= 0x35)) a = a - 0x30;
      else return 0;
      if ((b >= 0x61) && (b <= 0x7a)) b = b - 0x61 + 6;
      else if ((b >= 0x30) && (b <= 0x35)) b = b - 0x30;
      else return 0;
      return (a << 5) | b;
    }
    return 0;
  }
}
/* Egg.js
 * Top level coordinator for the Egg Web Runtime.
 * You must provide a valid Rom at construction.
 */
 








 
class Egg {
  constructor(rom) {
    this.rom = rom;
    this.data = new DataService(this);
    this.sysExtra = new SysExtra(window);
    this.input = new Input(this);
    this.audio = new Audio(this);
    this.imageDecoder = new ImageDecoder();
    this.canvas = null;
    this.render = null;
    this.exec = null;
    this.running = false;
    this.loaded = false;
    this.pvtime = 0;
    this.pendingFrame = null;
    this.restoreTitle = document.title;
    this.directgl = false;
  }
  
  attachToDom() {
    const body = document.body;
    body.innerHTML = "";
    
    // Optional "terminate" button. XXX This shouldn't be in the final product; whoever embeds us should provide this.
    const terminate = document.createElement("INPUT");
    terminate.setAttribute("type", "button");
    terminate.setAttribute("value", "Terminate");
    terminate.addEventListener("click", () => this.stop());
    terminate.style.display = "block";
    body.appendChild(terminate);
    
    this.canvas = document.createElement("CANVAS");
    this.setCanvasSize();
    body.appendChild(this.canvas);
    this.render = new Render(this);
    this.exec = new Exec(this);
    this.retitlePerRom();
  }
  
  setCanvasSize() {
    const match = this.data.getMetadata("framebuffer").match(/^(\d+)x(\d+)\s?(.*)/);
    if (!match) throw new Error("ROM does not declare its framebuffer size.");
    this.canvas.width = +match[1];
    this.canvas.height = +match[2];
    this.directgl = false;
    for (const token of match[3].split(/\s+/)) {
      if (token === "gl") this.directgl = true;
    }
    this.input.canvasChanged();
  }
  
  retitlePerRom() {
    document.title = this.data.getMetadata("title");
    let url = "";
    const iconImageId = +this.data.getMetadata("iconImage");
    if (iconImageId) {
      const serial = this.rom.getRes(Rom.RESTYPE_image, 0, iconImageId);
      if (serial.length > 0) {
        const crop = new Uint8Array(serial.length);
        crop.set(serial);
        const blob = new Blob([crop.buffer], { type: "image/png" });
        url = URL.createObjectURL(blob);
      }
    }
    for (const link of window.document.querySelectorAll("link[rel='icon']")) link.remove();
    if (url) {
      const link = window.document.createElement("LINK");
      link.setAttribute("data-egg-favicon", "");
      link.setAttribute("rel", "icon");
      link.setAttribute("type", "image/png");
      link.setAttribute("href", url);
      window.document.head.appendChild(link);
    }
  }
  
  retitleDefault() {
    document.title = this.restoreTitle;
    for (const link of window.document.querySelectorAll("link[rel='icon']")) link.remove();
  }
  
  start() {
    if (this.running) return;
    this.running = true;
    this.loaded = false;
    this.pvtime = 0;
    this.audio.start();
    return this.exec.load().then(() => {
      this.loaded = true;
      if (this.exec.egg_client_init() < 0) {
        throw new Error("Game aborted during startup.");
      }
      this.exec.egg_client_init = () => -1;
      this.pendingFrame = window.requestAnimationFrame(() => this.update());
    });
  }
  
  stop() {
    if (!this.running) return;
    this.audio.stop();
    this.input.detach();
    this.running = false;
    if (this.loaded) {
      this.exec.egg_client_quit();
      this.exec.egg_client_quit = () => {};
      this.loaded = false;
    }
    if (this.pendingFrame) {
      window.cancelAnimationFrame(this.pendingFrame);
      this.pendingFrame = null;
    }
    if (this.render) this.render.stop();
    this.retitleDefault();
  }
  
  update() {
    this.pendingFrame = null;
    if (!this.running) return;
    this.audio.update();
    this.input.update();
    const elapsed = this.tick();
    if (elapsed >= 0) {
      this.exec.egg_client_update(elapsed);
      if (!this.running) return;
      this.render.begin();
      this.exec.egg_client_render();
      this.render.end();
    }
    this.pendingFrame = window.requestAnimationFrame(() => this.update());
  }
  
  tick() {
    if (!this.pvtime) { // Very first update only, we update with zero time elapsed.
      this.pvtime = Date.now();
      return 0;
    }
    const now = Date.now();
    let elapsed = (now - this.pvtime) / 1000;
    if (elapsed < 0.015) return -1; // skip a frame (eg high-frequency monitors, don't let us run at 200 Hz or whatever)
    this.pvtime = now;
    return Math.min(0.050, elapsed); // Very long elapsed time, clamp at 50 ms.
  }
  
  /*------------------------ Public API entry points ------------------------*/
  
  egg_log(fmt, vargs) {
    const msg = this.sysExtra.applyLogFormat(
      this.exec.readCString(fmt),
      (spec, prec) => { // udxplfsc
        switch (spec) {
          case 'u': case 'd': case 'x': case 'c': case 'p': {
              const v = this.exec.mem32[vargs >> 2] || 0;
              vargs += 4;
              return v;
            }
          case 'l': {
              const v = this.exec.mem32[vargs >> 2] | (this.exec.mem32[(vargs+4) >> 2] * 4294967296);
              vargs += 8;
              return v;
            }
          case 'f': {
              if (vargs & 7) vargs = (vargs + 8) & ~7;
              const v = this.exec.memf64[vargs >> 3];
              vargs += 8;
              return v;
            }
          case 's': {
              let v;
              const p = this.exec.mem32[vargs >> 2];
              if (prec >= 0) v = this.exec.readLimitedString(p, prec);
              else v = this.exec.readCString(p);
              vargs += 4;
              return v;
            }
        }
      }
    );
    console.log(`GAME: ${msg}`);
  }
  
  egg_time_local(v, a) {
    if (a < 1) return;
    v >>= 2;
    const now = new Date();
    this.exec.mem32[v++] = now.getFullYear();
    if (a < 2) return;
    this.exec.mem32[v++] = 1 + now.getMonth();
    if (a < 3) return;
    this.exec.mem32[v++] = now.getDate();
    if (a < 4) return;
    this.exec.mem32[v++] = now.getHours();
    if (a < 5) return;
    this.exec.mem32[v++] = now.getMinutes();
    if (a < 6) return;
    this.exec.mem32[v++] = now.getSeconds();
    if (a < 7) return;
    this.exec.mem32[v++] = now.getMilliseconds();
  }
  
  egg_get_user_languages(v, a) {
    const src = this.sysExtra.getUserLanguages();
    const cpc = Math.min(a, src.length);
    for (let i=0, dstp=v>>2; i<cpc; i++, dstp++) {
      this.exec.mem32[dstp] = src[i];
    }
    return src.length;
  }
  
  egg_res_get(dst, dsta, tid, qual, rid) {
    const serial = this.rom.getRes(tid, qual, rid);
    return this.exec.safeWrite(dst, dsta, serial);
  }
  
  egg_res_for_each(cb, ctx) {
    if (!(cb = this.exec.fntab.get(cb))) return 0;
    for (const { tid, qual, rid, v } of this.rom.resv) {
      const err = cb(tid, qual, rid, v.length, ctx);
      if (err) return err;
    }
    return 0;
  }
}
</script>
</head>
<body>
</body>
</html>

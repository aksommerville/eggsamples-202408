<!DOCTYPE html>
<html>
<head>
<style>
canvas {
width: 1280px;
image-rendering: pixelated;
}
</style>
<egg-rom style="display:none">
r74(7k0FCXRpdGxlTGlnaHRzIE9uCAF0aXRsZVN0cjIGDmF1dGhvckFLIFNvbW1lcnZpbGxlCQp0aW1lc3RhbXAyMDI0LTA1LTEyCwdm
cmFtZWJ1ZmZlcjMyMHgxODAJAWljb25JbWFnZTEIAmxhbmd1YWdlZW4)t0r10910(AGFzbQEAAAAB2AEdYAJ/fwF/YAF/AGACf38AYAJ/fABgBn9/
f39/fwBgBH9/f38Bf2AHf39/f39/fwF/YAABf2AEf39/fwBgBX9/f39/AX9gAAF8YAN/f38AYAl/f39/f39/f38AYAt/f39/f39/
f39/fwBgAX8Bf2ADf39/AX9gAXwAYAAAYAZ/f39/f38Bf2AKf39/f39/f39/fwF/YAl/f39/f39/f38Bf2AIf39/f39/f38Bf2AF
f39/f38AYAF8AXxgAnx8AXxgAnx/AXxgAXwBf2ACf38BfGADf398AX8CgQclA2VudhRlZ2dfaW1hZ2VfZ2V0X2hlYWRlcgAEA2Vu
dhBlZ2dfaW1hZ2VfZGVjb2RlAAUDZW52EmVnZ190ZXh0dXJlX3VwbG9hZAAGA2Vudg9lZ2dfdGV4dHVyZV9uZXcABwNlbnYPZWdn
X3RleHR1cmVfZGVsAAEDZW52FmVnZ190ZXh0dXJlX2dldF9oZWFkZXIACANlbnYPZWdnX3JlbmRlcl90aW50AAEDZW52EGVnZ19y
ZW5kZXJfYWxwaGEAAQNlbnYNZWdnX2RyYXdfdGlsZQAIA2VudhBlZ2dfcmVzX2Zvcl9lYWNoAAADZW52FmVnZ19nZXRfdXNlcl9s
YW5ndWFnZXMAAANlbnYLZWdnX3Jlc19nZXQACQNlbnYNZWdnX3RpbWVfcmVhbAAKA2VudgdlZ2dfbG9nAAIDZW52DWVnZ19kcmF3
X3JlY3QABANlbnYNZWdnX2RyYXdfbGluZQALA2Vudg1lZ2dfZHJhd190cmlnAAsDZW52DmVnZ19kcmF3X2RlY2FsAAwDZW52FGVn
Z19kcmF3X2RlY2FsX21vZGU3AA0DZW52G2VnZ19qb3lzdGlja19kZXZpZF9ieV9pbmRleAAOA2VudhBlZ2dfZXZlbnRfZW5hYmxl
AAADZW52FGVnZ19qb3lzdGlja19nZXRfaWRzAAgDZW52HGVnZ19qb3lzdGlja19mb3JfZWFjaF9idXR0b24ADwNlbnYVZWdnX2pv
eXN0aWNrX2dldF9uYW1lAA8DZW52D2VnZ19sb2NrX2N1cnNvcgAOA2Vudg5lZ2dfdGltZV9sb2NhbAACA2VudhZlZ2dfdGV4dHVy
ZV9sb2FkX2ltYWdlAA8DZW52DWVnZ19zdG9yZV9nZXQABQNlbnYNZWdnX3N0b3JlX3NldAAFA2VudhZlZ2dfc3RvcmVfa2V5X2J5
X2luZGV4AA8DZW52D2VnZ19hdWRpb19ldmVudAAIA2VudhZlZ2dfYXVkaW9fZ2V0X3BsYXloZWFkAAoDZW52E2VnZ19hdWRpb19w
bGF5X3NvbmcACANlbnYUZWdnX2F1ZGlvX3BsYXlfc291bmQACANlbnYWZWdnX2F1ZGlvX3NldF9wbGF5aGVhZAAQA2VudhdlZ2df
cmVxdWVzdF90ZXJtaW5hdGlvbgARA2Vudg1lZ2dfZXZlbnRfZ2V0AAADqQGnAREBDg8ODg4SEg8TCQAUFBUIARYWDw8HCQUAAAcB
Dw8PDw4PFxcXGBkYGBcXGRkXFxoOAQAABwERDgEDAgsOAQMCAQ4BAQACAwEPAgMBBQAbBQ8cDgEDAgEJAQ4BAwIBAgcBDgEDAgES
Cw4BDgEDAgEOARwOAQMCAQ4BAwIBDgEBDgEDAQgOAQMCAQkJDgEOAQMCAQ4CAQECAQkOAQMCAQ4BEQEHERARBAUBcAFFRQUEAQDB
AgYJAX8BQeCjgAoLB3YGBm1lbW9yeQIAGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAA9lZ2dfY2xpZW50X3F1aXQAxgEPZWdn
X2NsaWVudF9pbml0AMgBEWVnZ19jbGllbnRfdXBkYXRlAMoBEWVnZ19jbGllbnRfcmVuZGVyAMsBCX0BAEEBC0Q8Xl9gY2RlZmh5
ent8fYABgQGCAYMBhgFxcG+IAYkBigGLAYwBjwGRAZIBkwGUAZYBmQGaAZsBnAGeAZ8BoAGhAaMBpAGmAacBqAGrAawBrQGuAa8B
sAGyAbQBtQG2AbcBuQG6AbsBvAG9Ab4BwAHBAcIBwwHFAQrv2gOnAQIAC6QBAQN/AkAgAEUNAAJAIAAoAggiAUUNACAAIAAoAgwi
AkF/aiIDNgIMAkAgAkEBSA0AA0ACQCABIANBHGxqIgEoAhQiA0UNACADENeAgIAACwJAIAEoAhgiAUUNACABENeAgIAACyAAIAAo
AgwiAUF/aiIDNgIMAkAgAUEBSA0AIAAoAgghAQwBCwsgACgCCCEBCyABENeAgIAACyAAENeAgIAACws4AQJ/QQAhAQJAIABBAUgN
AEEBQRQQ2YCAgAAiAkUNACACIAA2AgAgAiAAQQF2NgIEIAIhAQsgAQu8CQEafyOAgICAAEEQayIDJICAgIAAAkACQCAARQ0AIANB
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
IhogFEGEAUEBELeAgIAAIAAoAgwgDSAMQYYBQQAQt4CAgAAgACgCDBC2gICAACADIAZBA3RqIgEoAgRFDQAgAUEEaiEJIAAoAgwg
ACgCEEH/gXxB/wEQtYCAgABBASEBA0ACQCAJKAIAIAFxRQ0AAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAg
AUH/H0oNAAJAIAFB/wBKDQAgAUF/ag5AAgMUBBQUFAUUFBQUFBQUBhQUFBQUFBQUFBQUFBQUFAcUFBQUFBQUFBQUFBQUFBQUFBQU
FBQUFBQUFBQUFBQUCBQLAkAgAUH/A0oNACABQYABRg0JIAFBgAJHDRQgAigCACANIA9BiwFBABC3gICAAAwUCyABQYAERg0JIAFB
gAhGDQogAUGAEEcNEyACKAIAIBUgC0GJAUEAELeAgIAADBMLAkAgAUH//w9KDQACQCABQf//AUoNACABQYAgRg0MIAFBgMAARg0N
IAFBgIABRw0UIAIoAgAgGCAUQYUBQQAQt4CAgAAMFAsgAUGAgAJGDQ0gAUGAgARGDQ4gAUGAgAhHDRMgAigCACAbIAtBiAFBABC3
gICAAAwTCwJAIAFB////AEoNACABQYCAEEYNDyABQYCAIEYNECABQYCAwABHDRMgAigCACAbIAtBiAFBBRC3gICAAAwTCwJAIAFB
////A0oNACABQYCAgAFGDREgAUGAgIACRw0TIAIoAgAgFSALQYgBQQEQt4CAgAAMEwsgAUGAgIAERg0RIAFBgICACEcNEiACKAIA
IBUgC0GIAUEFELeAgIAADBILIAIoAgAgDiAQQYcBQQAQt4CAgAAMEQsgAigCACASIBRBhwFBABC3gICAAAwQCyACKAIAIBYgFEGH
AUEAELeAgIAADA8LIAIoAgAgDiAXQYcBQQAQt4CAgAAMDgsgAigCACAZIApBlgFBABC3gICAACACKAIAIBsgCkGXAUEAELeAgIAA
DA0LIAIoAgAgFSAKQZcBQQEQt4CAgAAgAigCACAcIApBlgFBARC3gICAAAwMCyACKAIAIB0gCkGZAUEAELeAgIAADAsLIAIoAgAg
ESAKQZkBQQEQt4CAgAAMCgsgAigCACANIA9BiwFBARC3gICAAAwJCyACKAIAIBsgC0GJAUEAELeAgIAADAgLIAIoAgAgEyAMQYUB
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
IQIgCkF/aiIKQQFLDQALCyAAKAIMELaAgIAACyABQRBqJICAgIAAC+EBAQN/QQAhBAJAIANBAEgNACACKAIsIANMDQAgAigCKCAD
QQJ0aigCACEFQQAhBANAIAUgBGohAiAEQQFqIgMhBCACLQAADQALAkADQAJAIANBAUcNAEEAIQQMAgsgBSADaiEEIANBf2oiAiED
IARBfmotAABBIUkNAAsgBSACaiEDQQAhBANAAkAgA0F/aiIGLQAAQSFPDQAgAyEFDAILIAYhAyACIARBAWoiBEcNAAsgAiEECyAE
IAFKDQAgACAFIAQQwoCAgAAaCwJAIAQgAU4NACAAIARqQQA6AAALIAQLtAQBBn8jgICAgABBEGsiAiSAgICAAEEAIQMCQAJAAkAC
QCABQQBIDQBBACEDIAAoAiwgAUwNACAAKAIoIAFBAnRqKAIAIQBBACEDA0AgACADaiEBIANBAWoiBCEDIAEtAAANAAsgBEF/aiED
A0ACQCADDQBBACEDDAILIAAgA2ohASADQX9qIgQhAyABQX9qLQAAQSFJDQALIAAgBGoiA0EBaiEFAkACQCADLQAAQSFPDQBBACED
DAELIARBAWohBkEAIQMgBSEBA0ACQCAEIANHDQAgBiEDIAAhBQwCCyADQQFqIQMgAUF+aiEHIAFBf2oiBSEBIActAABBIEsNAAsL
IANBEEoNASACIAUgAxDCgICAACEBIANBEEcNAEEQIQMgAS0AACEADAILIAIgA2pBADoAAAtBACEBIANBb2pBcEkNASACKAIAIQAC
QCADQQRHDQBBASEBIABB9OTVqwZGDQILIANBBUcNAEEFIQNBACEBIAJB0ouAgABBBRDEgICAAEUNAQsCQAJAIABB/wFxQS1GDQBB
ACEBIAIhAANAIANFDQMgA0F/aiEDIAFBCmwgACwAACIEakFQaiEBIABBAWohACAEQUZqQf8BcUH1AUsNAAwCCwsgA0F/aiEDIAJB
AXIhAEEAIQEDQCADRQ0CIANBf2ohAyABQQpsIAAsAAAiBGtBMGohASAAQQFqIQAgBEFGakH/AXFB9gFPDQALC0EAIQELIAJBEGok
gICAgAAgAQubBQQGfwF8AX8BfCOAgICAAEEQayICJICAgIAAQQAhAwJAAkACQAJAIAFBAEgNAEEAIQMgACgCLCABTA0AIAAoAigg
AUECdGooAgAhBEEAIQEDQCAEIAFqIQAgAUEBaiIDIQEgAC0AAA0ACyADQX9qIQEDQAJAIAENAEEAIQMMAgsgBCABaiEAIAFBf2oi
BSEBIABBf2otAABBIUkNAAsgBCAFaiIBQQFqIQYCQAJAIAEtAABBIU8NAEEAIQMMAQsgBUEBaiEHQQAhAyAGIQEDQAJAIAUgA0cN
ACAHIQMgBCEGDAILIANBAWohAyABQX5qIQAgAUF/aiIGIQEgAC0AAEEgSw0ACwsgA0EQSg0BIAIgBiADEMKAgIAAIQEgA0EQRw0A
IAEtAABBLUYhBEEQIQMMAgsgAiADakEAOgAAC0QAAAAAAAAAACEIIANBb2pBcEkNASADIAItAABBLUYiBE0NAQsgAyAEayEHIAIg
BHIhBkQAAAAAAAAAACEIQQAhAQJAA0AgBiABaiIFLQAAIglBUGoiAEH/AXFBCUsNASAIRAAAAAAAACRAoiAAtyIImiAIIAQboCEI
IAcgAUEBaiIBRw0ADAILCyAJQS5HDQAgBCABakEBaiADTg0AIAFBf3MgB2ohAQJAIAQNAEQAAAAAAADwPyEKQQAhAANAIAUgAGpB
AWotAABBUGoiBEH/AXFBCUsNAiAEtyAKRJqZmZmZmbk/oiIKoiAIoCEIIAEgAEEBaiIARw0ADAILCyAFQQFqIQBEAAAAAAAA8D8h
CgNAIAAtAABBUGoiBEH/AXFBCUsNASAIIAS3IApEmpmZmZmZuT+iIgqioSEIIABBAWohACABQX9qIgENAAsLIAJBEGokgICAgAAg
CAumAwEGf0F/IQQCQCABQQBIDQAgACgCLCABTA0AQQAhBEEAIQUCQCACRQ0AIAMhBSADQX9KDQBBACEDA0AgAiADaiEGIANBAWoi
ByEDIAYtAAANAAsgB0F/aiEFCyAAKAIoIAFBAnRqKAIAIQYDQCAGIARqIQMgBEEBaiIHIQQgAy0AAA0ACyAHQX9qIQMCQANAIAMi
BEUNASAEQX9qIQMgBiAEakF/ai0AAEEhSQ0ACwsgBkF+aiEHAkADQCAEIgNFDQEgA0F/aiEEIAcgA2pBAWotAABBIEsNAAsLIAYg
A2pBfmohCEEAIQcCQANAIAMgByIEaiIJRQ0BIARBf2ohByAIIARqQQFqLQAAQSFJDQALCwJAIAUgA2ogBGpBAmoQ1oCAgAAiBw0A
QX8PCyAHIAYgCRDCgICAACIHIARqIgkgA2oiBEEgOgAAIARBAWogAiAFEMKAgIAAGkEAIQQgCSAFaiADakEBakEAOgAAIAYQ14CA
gAAgACgCKCABQQJ0aiAHNgIAIAAoAjgiA0UNACADEISAgIAAQQAhBCAAQQA2AjgLIAQL9gMBAn8jgICAgABBEGsiAySAgICAAEEA
IQQCQCACQX9KDQAgA0EtOgAAQQAgAmshAkEBIQQLAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACQYCU69wDSQ0A
IAMgBHIgAkGAlOvcA25BMHI6AAAgBEEBaiEEDAELIAJBgMLXL0kNAQsgAyAEciACQYDC1y9uQQpwQTByOgAAIARBAWohBAwBCyAC
QYCt4gRJDQELIAMgBHIgAkGAreIEbkH/AXFBCnBBMHI6AAAgBEEBaiEEDAELIAJBwIQ9SQ0BCyADIARyIAJBwIQ9bkEKcEEwcjoA
ACAEQQFqIQQMAQsgAkGgjQZJDQELIAMgBGogAkGgjQZuQQpwQTByOgAAIARBAWohBAwBCyACQZDOAEkNAQsgAyAEaiACQZDOAG5B
CnBBMHI6AAAgBEEBaiEEDAELIAJB6AdJDQELIAMgBGogAkHoB25BCnBBMHI6AAAgBEEBaiEEDAELIAJB5ABJDQELIAMgBGogAkHk
AG5BCnBBMHI6AAAgBEEBaiEEDAELIAJBCkkNAQsgAyAEaiACQQpuQQpwQTByOgAAIARBAWohBAsgAyAEaiACQQpwQTByOgAAIAAg
ASADIARBAWoQ9YCAgAAhBCADQRBqJICAgIAAIAQLmwQDBH8BfAF/I4CAgIAAQRBrIgMkgICAgABBACEEAkAgAkQAAAAAAAAAAGNF
DQAgA0EtOgAIIAKaIQJBASEECwJAIAJEAAAAAAAAWUBmRQ0AAkACQCACmUQAAAAAAADgQWNFDQAgAqohBQwBC0GAgICAeCEFCyAD
QQhqIARqQTAgBUHkAG1BCm8iBUEwaiAFQQBIGzoAACAEQQFqIQQLIAJEAAAAAAAAJEBmIQUCQAJAIAKZRAAAAAAAAOBBY0UNACAC
qiEGDAELQYCAgIB4IQYLAkAgBUUNACADQQhqIARqQTAgBkEKbUEKbyIFQTBqIAVBAEgbOgAAIARBAWohBAsgA0EIaiAEaiIFQQFq
QS46AAAgBUEwIAZBCm8iBkEwaiAGQQBIGzoAACAFQQRqIQYCQAJAIAJEAAAAAABAj0CiIgeZRAAAAAAAAOBBY0UNACAHqiEIDAEL
QYCAgIB4IQgLIAYgCEEKb0EwajoAACAFQQNqIQYCQAJAIAJEAAAAAAAAWUCiIgeZRAAAAAAAAOBBY0UNACAHqiEIDAELQYCAgIB4
IQgLIAYgCEEKb0EwajoAACAFQQJqIQUCQAJAIAJEAAAAAAAAJECiIgKZRAAAAAAAAOBBY0UNACACqiEGDAELQYCAgIB4IQYLIAUg
BkEKb0EwajoAACAAIAEgA0EIaiAEQQVqEPWAgIAAIQQgA0EQaiSAgICAACAEC2sAAkBB5AAgABDqgICAACIARQ0AIABBioCAgAA2
AiQgAEGLgICAADYCICAAQYyAgIAANgIcIABBjYCAgAA2AhggAEHUAGogACgCCEEIbTYCAEGOgICAACAAEImAgIAAGiAAEP6AgIAA
CyAACzEAQX8QhoCAgABBASAAKAIQIABB2ABqKAIAIABB3ABqKAIAEIiAgIAAQQAQhoCAgAALAgALuAYBAn8CQAJAAkACQCABKAIA
QX9qDgIAAQMLIAEoAgxFDQICQAJAAkACQAJAAkAgASgCCEH8fmoODAQFBAUICAgIAAECAwgLIABByABqKAIAIABB1ABqKAIAayIB
IABB0ABqKAIAIgJBf2oiAyADIAFKGyIBQQAgAUEAShsiASACRg0HIAAgATYCUAwGCyAAQcgAaigCACAAQdQAaigCAGsiASAAQdAA
aigCACICQQFqIgMgAyABShsiAUEAIAFBAEobIgEgAkYNBiAAIAE2AlAMBQsgAEHIAGooAgAgAEHUAGooAgAiAWsiAiAAQdAAaigC
ACIDIAFrIgEgASACShsiAUEAIAFBAEobIgEgA0YNBSAAIAE2AlAMBAsgAEHIAGooAgAgAEHUAGooAgAiAWsiAiAAQdAAaigCACID
IAFqIgEgASACShsiAUEAIAFBAEobIgEgA0YNBCAAIAE2AlAMAwsgAEHIAGooAgAgAEHUAGooAgAiAWsiAiAAQdAAaigCACIDIAFr
IgEgASACShsiAUEAIAFBAEobIgEgA0YNAyAAIAE2AlAMAgsgAEHIAGooAgAgAEHUAGooAgAiAWsiAiAAQdAAaigCACIDIAFqIgEg
ASACShsiAUEAIAFBAEobIgEgA0YNAiAAIAE2AlAMAQsgASgCCEUNAQJAAkACQAJAIAEoAgRBsf9jag4EAAECAwULIABByABqKAIA
IABB1ABqKAIAIgFrIgIgAEHQAGooAgAiAyABaiIBIAEgAkobIgFBACABQQBKGyIBIANGDQQgACABNgJQDAMLIABByABqKAIAIABB
1ABqKAIAIgFrIgIgAEHQAGooAgAiAyABayIBIAEgAkobIgFBACABQQBKGyIBIANGDQMgACABNgJQDAILIABByABqKAIAIABB1ABq
KAIAayIBIABB0ABqKAIAIgJBAWoiAyADIAFKGyIBQQAgAUEAShsiASACRg0CIAAgATYCUAwBCyAAQcgAaigCACAAQdQAaigCAGsi
ASAAQdAAaigCACICQX9qIgMgAyABShsiAUEAIAFBAEobIgEgAkYNASAAIAE2AlALIAAQ/oCAgAALCzIBAX8CQCAAKAJEIgFFDQAg
ARDXgICAAAsCQCAAQdgAaigCACIARQ0AIAAQ14CAgAALC5kBAQN/AkACQAJAIAQoAkgiBSAEKAJMIgZODQAgBCgCRCEGDAELQX8h
BSAGQYACaiIHQf///z9LDQEgBCgCRCAHQQR0ENiAgIAAIgZFDQEgBCAHNgJMIAQgBjYCRCAEKAJIIQULIAQgBUEBajYCSCAGIAVB
BHRqIgQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCAEEAIQULIAULuhcBEX8jgICAgABBIGsiASSAgICAACAAQdwAaiICQQA2AgAC
QCAAQdQAaigCACIDIABByABqKAIAIABB0ABqKAIAIgRrIgUgBSADShsiBkEBSA0AIABB2ABqIQcgAEHgAGohAyAAKAJEIARBBHRq
IQhBBiEJA0AgBiEKAkACQAJAAkAgCCgCACILQX9qIgBBBUsNACAAQQJ0QdCWgIAAaigCACIALQAAIgUNAUEMIQwMAwtBASEEAkAg
C0EKSQ0AQQohAEEAIQUCQANAIAVBAWohBSAAQZmz5swBSw0BIABBCmwiACALTQ0ACwtBICEEIAVBHksNACAFQQFqIQQLAkACQCAE
QQFxDQAgBCEFIAshAAwBCyABIARBf2oiBWogCyALQQpuIgBBCmxrQTByOgAACyAEQQFGDQEgBUEBaiEFA0AgASAFaiILQX1qIABB
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
cjoAACACQQFqIQIMAQsgA0EKSQ0BCyABIAJqIANB//8DcUEKbkEKcEEwcjoAACACQQFqIQILIANB//8DcUEKcEEwciEECyABIAJq
IAQ6AAAgACgCDEEoQSggASACQQFqELiAgIAAIAFBIDoAAiABQdn0ADsBAEEDIQICQCAAQcgAaigCACIDQX9KDQAgAUEtOgADQQAg
A2shA0EEIQILQT8hBAJAIANBj84ASw0AAkACQAJAAkACQCADQegHSQ0AIAEgAnIgA0H//wNxQegHbkEKcEEwcjoAACACQQFqIQIM
AQsgA0HkAEkNAQsgASACciADQf//A3FB5ABuQf8BcUEKcEEwcjoAACACQQFqIQIMAQsgA0EKSQ0BCyABIAJqIANB//8DcUEKbkEK
cEEwcjoAACACQQFqIQILIANB//8DcUEKcEEwciEECyABIAJqIAQ6AAAgACgCDEEoQTAgASACQQFqELiAgIAAIAFBIDoAAiABQfj0
ADsBAEEDIQICQCAAQcwAaigCACIDQX9KDQAgAUEtOgADQQAgA2shA0EEIQILQT8hBAJAIANBj84ASw0AAkACQAJAAkACQCADQegH
SQ0AIAEgAnIgA0H//wNxQegHbkEKcEEwcjoAACACQQFqIQIMAQsgA0HkAEkNAQsgASACciADQf//A3FB5ABuQf8BcUEKcEEwcjoA
ACACQQFqIQIMAQsgA0EKSQ0BCyABIAJqIANB//8DcUEKbkEKcEEwcjoAACACQQFqIQILIANB//8DcUEKcEEwciEECyABIAJqIAQ6
AAAgACgCDEEoQTggASACQQFqELiAgIAAIAFBIDoAAiABQfn0ADsBAEEDIQICQCAAQdAAaigCACIDQX9KDQAgAUEtOgADQQAgA2sh
A0EEIQILQT8hBAJAIANBj84ASw0AAkACQAJAAkACQCADQegHSQ0AIAEgAnIgA0H//wNxQegHbkEKcEEwcjoAACACQQFqIQIMAQsg
A0HkAEkNAQsgASACciADQf//A3FB5ABuQf8BcUEKcEEwcjoAACACQQFqIQIMAQsgA0EKSQ0BCyABIAJqIANB//8DcUEKbkEKcEEw
cjoAACACQQFqIQILIANB//8DcUEKcEEwciEECyABIAJqIAQ6AAAgACgCDEEoQcAAIAEgAkEBahC4gICAAAJAIABB6ABqLQAAIgNF
DQACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgA0EBcUUNACABQdIAOgAEIAFBz6ihqgQ2AgBBBSECIANBAnFFDQIgAUEs
OgAFQQYhAgwBC0EAIQIgA0ECcQ0AQQAhAiADQQRxDQJBACECIANBCHENBEEAIQIgA0EQcQ0GQQAhAiADQSBxDQhBACECIANBwABx
DQpBACECIANBgAFxDQwMDQsgAiABciIEQcwAOgAAIARBAXJB5QA6AAAgBEECakHm6AE7AQAgAkEEaiECCyADQQRxRQ0BIAEgAnJB
LDoAACACQQFqIQILIAEgAmoiBEHS0p3DBjYAACAEQQRqQfQAOgAAIAJBBWohAgsgA0EIcUUNAQJAIAINAEEAIQIMAQsgASACakEs
OgAAIAJBAWohAgsgASACaiIEQc3SkaMGNgAAIARBBGpB7MoBOwAAIAJBBmohAgsgA0EQcUUNAQJAIAINAEEAIQIMAQsgASACakEs
OgAAIAJBAWohAgsgASACakE0OgAAIAJBAWohAgsgA0EgcUUNAQJAIAINAEEAIQIMAQsgASACakEsOgAAIAJBAWohAgsgASACakE1
OgAAIAJBAWohAgsgA0HAAHFFDQECQCACDQBBACECDAELIAEgAmpBLDoAACACQQFqIQILIAEgAmpBNjoAACACQQFqIQILIANBgAFx
RQ0BAkAgAg0AQQAhAgwBCyABIAJqQSw6AAAgAkEBaiECCyABIAJqQTc6AAAgAkEBaiECCyAAKAIMQShByAAgASACELiAgIAACyAA
KAIMELaAgIAACyABQYABaiSAgICAAAuUAQEBfAJAIABB2ABqKwMAIgJEAAAAAAAAAABkRQ0AIAAgAiABoSICOQNYIAJEAAAAAAAA
AABlRQ0AIABCADcDWCAAQcwAakEANgIACwJAIABB4ABqKwMAIgJEAAAAAAAAAABkRQ0AIAAgAiABoSIBOQNgIAFEAAAAAAAAAABl
RQ0AIABCADcDYCAAQdAAakEANgIACwvQAQECfwJAAkACQAJAIAEoAgBBfGoOAwABAgMLIAAgASgCBDYCRCAAQcgAaiABKAIINgIA
DwtBASABKAIMIgJ0QQEgAkF/akEHSRshAiAAQegAai0AACEDAkAgASgCEEUNACAAIAMgAnI6AGgPCyAAIAMgAkF/c3E6AGgPCwJA
IAEoAgwiAkUNACAAQdgAakKAgICAgICA6D83AwAgAEHMAGogAjYCAAsgASgCECIBRQ0AIABB4ABqQoCAgICAgIDoPzcDACAAQdAA
aiABNgIACwsCAAvIAgECfwJAQZgCIAAQ6oCAgAAiAEUNACAAIAAoApACIgFBAWo2ApACIABBuoCAgAA2AkAgAEG7gICAADYCPCAA
QbyAgIAANgIkIABBlYCAgAA2AiAgAEG9gICAADYCHCAAQb6AgIAANgIYIABB8ABqIgIgAUECdGpBADYCAEG/gICAACAAEImAgIAA
GiAAQYuQgIAAQX8Q7oCAgAAaIABByYuAgABBfxDugICAABogAEGui4CAAEF/EO6AgIAAGiAAQZeQgIAAQX8Q7oCAgAAaIABBx4+A
gABBfxDugICAABogAEGkkICAAEF/EO6AgIAAGiAAQfWPgIAAQX8Q7oCAgAAaIABBACACKAIAEPaAgIAAGiAAQQMgAEHAAWooAgAQ
9oCAgAAaQQ9BwAFBEEEAEJ6AgIAAQQ9BsAFBB0H/ABCegICAAAsgAAupBQEHfyOAgICAAEEQayICJICAgIAAAkACQAJAAkACQAJA
AkACQCAAKAI0DgcAAQIDBAUGBwsgACgCkAJBAUgNBiAAQfAAaiEDIABBABDzgICAACEEIAAgACgCkAIiBUECdGpB7ABqIQYgBSEH
AkADQAJAIAdBAU4NAEF/IQcMAgsgB0F/aiEHIAYoAgAhCCAGQXxqIQYgCCAERw0ACwsgAEEAIAMgBUF/aiAHIAFqIgdBACAHIAVI
GyAHQQBIG0ECdGooAgAQ9oCAgAAaDAYLAkAgAkEIakEIIABBARDygICAAEEERw0AIAIoAAhB9OTVqwZHDQAgAEEBQdKLgIAAQQUQ
9YCAgAAaDAYLIABBAUG4i4CAAEEEEPWAgIAAGgwFCwJAIAJBCGpBCCAAQQIQ8oCAgABBBEcNACACKAAIQfTk1asGRw0AIABBAkHS
i4CAAEEFEPWAgIAAGgwFCyAAQQJBuIuAgABBBBD1gICAABoMBAsgAEGUAmooAgBBAUgNAyAAQcABaiEDIABBAxDzgICAACEEIAAg
ACgClAIiBUECdGpBvAFqIQYgBSEHAkADQAJAIAdBAU4NAEF/IQcMAgsgB0F/aiEHIAYoAgAhCCAGQXxqIQYgCCAERw0ACwsgAEED
IAMgBUF/aiAHIAFqIgdBACAHIAVIGyAHQQBIG0ECdGooAgAQ9oCAgAAaDAMLIABBBCAAQQQQ84CAgAAgAUEKbGoiB0HjACAHQeMA
SBsiB0EAIAdBAEobEPaAgIAAGgwCCyAAQQUgAEEFEPOAgIAAIAFBFGxqIgdB4wAgB0HjAEgbIgdBnX8gB0Gdf0obEPaAgIAAGgwB
CyAAQQYgAEEGEPSAgIAAIAG3oEQAAAAAAAAAAKUQ94CAgAAaCyACQRBqJICAgIAAC54CAQJ/AkACQAJAAkACQAJAAkACQCAAKAI0
DgcAAQIDBAUGBwtBACAAQQAQ84CAgAAgAEEBEPOAgIAAIABBAhDzgICAABCggICAAA8LIABBARC5gYCAAA8LIABBARC5gYCAAA8L
IABBAxDzgICAACEBIABBBBDzgICAACECIABBBRDzgICAACEAIAFBAUgNA0EAIAEgAkEQdEHkAG0gAEEPdEHkAG0QoYCAgAAPCyAA
QQRB4wBBGSAAQQQQ84CAgABB4wBIGxD2gICAABoPC0GdfyEBAkAgAEEFEPOAgIAAIgJB4gBKDQBBACEBIAJBnn9IDQBBAEHjACAC
GyEBCyAAQQUgARD2gICAABoPCyAAQQYQ9ICAgAAQooCAgAALC4UEAwN/AXwBfyOAgICAAEEQayIBJICAgIAAIAAQ8YCAgAACQAJA
IAAoAkQiAg0AIAAoAgAiAkUNASAAIAJBk5GAgABBf0EAQYCBggQQsICAgAA2AkQMAQsgAUEANgIAIAFBADYCDCABIAFBDGpBACAC
EIWAgIAAQQEgACgCREEEIAAoAgggASgCDCICa0F8akEAQQAgASgCACACQQAQkYCAgAALAkAgACgCDEUNACAAKAIQRQ0AQf8BIQMC
QBCfgICAACABENGAgIAAIgREAAAAAAAAAABlDQACQEQAAAAAAAAAAEQAAAAAAADwPyAEoUQAAAAAAOBvQKIgBEQAAAAAAADwP2Yb
IgREAAAAAAAA8EFjIAREAAAAAAAAAABmcUUNACAEqyEDDAELQQAhAwsCQAJAIAErAwAiBJlEAAAAAAAA4EFjRQ0AIASqIQIMAQtB
gICAgHghAgsgASACQQAgAkEAShsiAkHkAG5BCnBBMHI6AA0gASACQegHbkEKcEEwcjoADCABIAJBCm4iBUEKcEEwcjoADiABIAIg
BUEKbGtBMHI6AA8gACgCDCAAKAIQQX8gAxC1gICAACAAKAIMIAAvAQRBEHRBgIDgfmpBEHUgAC8BCEEQdEGAgGBqQRB1IAFBDGpB
BBC4gICAACAAKAIMELaAgIAACyABQRBqJICAgIAAC/QLAQJ/AkACQAJAIAEoAgBBf2oOAgABAgsCQAJAAkACQAJAAkAgASgCCEH/
fmoOBwEHAAIDBAUHCyAAQcgAaigCACECAkACQCABKAIMRQ0AIAINCEGQASECQQEhAwwBCyACRQ0HQYABIQJBACEDCyAAIAM2AkhB
DyACQThBwAAQnoCAgAAgACABEO+AgIAADwsgAEHMAGooAgAhAgJAAkAgASgCDEUNACACDQdBkAEhAkEBIQMMAQsgAkUNBkGAASEC
QQAhAwsgACADNgJMQQ8gAkE6QcAAEJ6AgIAAIAAgARDvgICAAA8LIABB0ABqKAIAIQICQAJAIAEoAgxFDQAgAg0GQZABIQJBASED
DAELIAJFDQVBgAEhAkEAIQMLIAAgAzYCUEEPIAJBO0HAABCegICAACAAIAEQ74CAgAAPCyAAQdQAaigCACECAkACQCABKAIMRQ0A
IAINBUGQASECQQEhAwwBCyACRQ0EQYABIQJBACEDCyAAIAM2AlRBDyACQT1BwAAQnoCAgAAgACABEO+AgIAADwsgAEHYAGooAgAh
AgJAAkAgASgCDEUNACACDQRBkAEhAkEBIQMMAQsgAkUNA0GAASECQQAhAwsgACADNgJYQQ8gAkE/QcAAEJ6AgIAAIAAgARDvgICA
AA8LIABB3ABqKAIAIQICQAJAIAEoAgxFDQAgAg0DQZABIQJBASEDDAELIAJFDQJBgAEhAkEAIQMLIAAgAzYCXEEPIAJBwABBwAAQ
noCAgAAgACABEO+AgIAADwsCQAJAAkACQAJAAkACQAJAAkACQCABKAIEQfj/Y2oOFQIKCgoHCgoKCgoICQADCgQGCgEKBQoLIABB
yABqKAIAIQICQAJAIAEoAghFDQAgAg0LQZABIQJBASEDDAELIAJFDQpBgAEhAkEAIQMLIAAgAzYCSEEPIAJBOEHAABCegICAACAA
IAEQ74CAgAAPCyAAQcwAaigCACECAkACQCABKAIIRQ0AIAINCkGQASECQQEhAwwBCyACRQ0JQYABIQJBACEDCyAAIAM2AkxBDyAC
QTpBwAAQnoCAgAAgACABEO+AgIAADwsgAEHQAGooAgAhAgJAAkAgASgCCEUNACACDQlBkAEhAkEBIQMMAQsgAkUNCEGAASECQQAh
AwsgACADNgJQQQ8gAkE7QcAAEJ6AgIAAIAAgARDvgICAAA8LIABB1ABqKAIAIQICQAJAIAEoAghFDQAgAg0IQZABIQJBASEDDAEL
IAJFDQdBgAEhAkEAIQMLIAAgAzYCVEEPIAJBPUHAABCegICAACAAIAEQ74CAgAAPCyAAQdgAaigCACECAkACQCABKAIIRQ0AIAIN
B0GQASECQQEhAwwBCyACRQ0GQYABIQJBACEDCyAAIAM2AlhBDyACQT9BwAAQnoCAgAAgACABEO+AgIAADwsgAEHcAGooAgAhAgJA
AkAgASgCCEUNACACDQZBkAEhAkEBIQMMAQsgAkUNBUGAASECQQAhAwsgACADNgJcQQ8gAkHAAEHAABCegICAACAAIAEQ74CAgAAP
CyAAQeAAaigCACECAkACQCABKAIIRQ0AIAINBUGQASECQQEhAwwBCyACRQ0EQYABIQJBACEDCyAAIAM2AmBBDyACQcIAQcAAEJ6A
gIAAIAAgARDvgICAAA8LIABB5ABqKAIAIQICQAJAIAEoAghFDQAgAg0EQZABIQJBASEDDAELIAJFDQNBgAEhAkEAIQMLIAAgAzYC
ZEEPIAJBxABBwAAQnoCAgAAgACABEO+AgIAADwsgAEHoAGooAgAhAgJAAkAgASgCCEUNACACDQNBkAEhAkEBIQMMAQsgAkUNAkGA
ASECQQAhAwsgACADNgJoQQ8gAkHLAEHAABCegICAACAAIAEQ74CAgAAPCyAAQewAaigCACECAkACQCABKAIIRQ0AIAINAkGQASEC
QQEhAwwBCyACRQ0BQYABIQJBACEDCyAAIAM2AmxBDyACQdAAQcAAEJ6AgIAACyAAIAEQ74CAgAALFwACQCAAKAJEIgBFDQAgABCE
gICAAAsLiwEBAX8CQAJAAkACQAJAAkAgAEF7ag4CAAEDCyABDQMgBCgCkAIiAEEUTg0DIARBkAJqIQFB8AAhBQwBCyABDQIgBCgC
lAIiAEEUTg0CIARBlAJqIQFBwAEhBQsgASAAQQFqNgIAIAQgBWogAEECdGogAjYCAAwBC0EBIQEgAEEGSg0BC0EAIQELIAELVgAC
QEHUACAAEOqAgIAAIgBFDQAgAEHAgICAADYCJCAAQcGAgIAANgIgIABBwoCAgAA2AhwgAEHDgICAADYCGEEIQQEQlICAgAANACAA
QQE2AkQLIAALsQYBAn8jgICAgABBEGsiASSAgICAAAJAIAAoAgwiAkUNAAJAIAAoAkRFDQAgAiAAKAIQQf+BgHhB/wEQtYCAgAAg
ACgCDEEQQRBB7YmAgABBfxC4gICAACAAKAIMELaAgIAADAELIAIgACgCEEF/Qf8BELWAgIAAIAFBIDoAByABQfj0ADsABSABIABB
yABqKAIAIgJBD3FBnYuAgABqLQAAOgAPIAEgAkEcdkGdi4CAAGotAAA6AAggASACQQR2QQ9xQZ2LgIAAai0AADoADiABIAJBCHZB
D3FBnYuAgABqLQAAOgANIAEgAkEMdkEPcUGdi4CAAGotAAA6AAwgASACQRB2QQ9xQZ2LgIAAai0AADoACyABIAJBFHZBD3FBnYuA
gABqLQAAOgAKIAEgAkEYdkEPcUGdi4CAAGotAAA6AAkgACgCDEEoQSggAUEFakELELiAgIAAIAFBIDoAByABQfn0ADsABSABIABB
zABqKAIAIgJBD3FBnYuAgABqLQAAOgAPIAEgAkEcdkGdi4CAAGotAAA6AAggASACQQR2QQ9xQZ2LgIAAai0AADoADiABIAJBCHZB
D3FBnYuAgABqLQAAOgANIAEgAkEMdkEPcUGdi4CAAGotAAA6AAwgASACQRB2QQ9xQZ2LgIAAai0AADoACyABIAJBFHZBD3FBnYuA
gABqLQAAOgAKIAEgAkEYdkEPcUGdi4CAAGotAAA6AAkgACgCDEEoQTAgAUEFakELELiAgIAAIAFBIDoAByABQfr0ADsABSABIABB
0ABqKAIAIgJBD3FBnYuAgABqLQAAOgAPIAEgAkEcdkGdi4CAAGotAAA6AAggASACQQR2QQ9xQZ2LgIAAai0AADoADiABIAJBCHZB
D3FBnYuAgABqLQAAOgANIAEgAkEMdkEPcUGdi4CAAGotAAA6AAwgASACQRB2QQ9xQZ2LgIAAai0AADoACyABIAJBFHZBD3FBnYuA
gABqLQAAOgAKIAEgAkEYdkEPcUGdi4CAAGotAAA6AAkgACgCDEEoQTggAUEFakELELiAgIAAIAAoAgwQtoCAgAALIAFBEGokgICA
gAALAgALOQACQCABKAIAQQhHDQAgAEHIAGogASgCBDYCACAAQcwAaiABKAIINgIAIABB0ABqIAEoAgw2AgALCw0AQQhBABCUgICA
ABoLugEAAkBBxAAgABDqgICAACIARQ0AIABBxICAgAA2AjwgAEGUgICAADYCJCAAQZWAgIAANgIgIABBloCAgAA2AhwgAEGCi4CA
AEEIEO6AgIAAGiAAQf6KgIAAQQwQ7oCAgAAaIABB5YyAgABBCBDugICAABogAEHDi4CAAEEFEO6AgIAAGiAAQfOKgIAAQQoQ7oCA
gAAaIABBi4uAgABBBRDugICAABogAEH+iYCAAEENEO6AgIAAGgsgAAtuAAJAAkACQAJAAkACQAJAAkAgACgCNA4HAAECAwQFBgcL
IAAQ4oCAgAAaDwsgABCHgYCAABoPCyAAEJiBgIAAGg8LIAAQs4GAgAAaDwsgABCQgYCAABoPCyAAEJ2BgIAAGg8LIAAQv4GAgAAa
CwsCAAukAwECfyOAgICAAEHwAGsiASSAgICAAEEBQQEQlICAgAAhAgJAIABFDQAgAg0AIAFB/o6AgAA2AmBBrZCAgAAgAUHgAGoQ
jYCAgAALQQJBARCUgICAACECAkAgAEUNACACDQAgAUGCj4CAADYCUEGtkICAACABQdAAahCNgICAAAtBA0EBEJSAgIAAIQICQCAA
RQ0AIAINACABQYaPgIAANgJAQa2QgIAAIAFBwABqEI2AgIAAC0EEQQEQlICAgAAhAgJAIABFDQAgAg0AIAFBk4+AgAA2AjBBrZCA
gAAgAUEwahCNgICAAAtBBUEBEJSAgIAAIQICQCAARQ0AIAINACABQYuPgIAANgIgQa2QgIAAIAFBIGoQjYCAgAALQQZBARCUgICA
ACECAkAgAEUNACACDQAgAUGbj4CAADYCEEGtkICAACABQRBqEI2AgIAAC0EHQQEQlICAgAAhAgJAIABFDQAgAg0AIAFBoo+AgAA2
AgBBrZCAgAAgARCNgICAAAtBCEEAEJSAgIAAGkEJQQAQlICAgAAaIAFB8ABqJICAgIAAC84CAQJ/QbCXgIgAQbSXgIgAQQBBARCF
gICAAEEAEIOAgIAAIgA2AriXgIgAQX8hAQJAIABBAEECEJqAgIAAQQBIDQBBABCDgICAACIANgKYl4CIACAAQQBBCBCagICAAEEA
SA0AQQBBCRCngICAACIANgK8l4CIACAARQ0AIABBA0EhEKiAgIAAQQBIDQBBACgCvJeAiABBBEGhARCogICAAEEASA0AQQAoAryX
gIgAQQVBgAgQqICAgABBAEgNAEEAKAK8l4CIAEEGQQEQqICAgABBAEgNAEEBEMeBgIAAQQAQhYGAgAAiADYCwJeAiAAgAEUNACAA
QcSXgIgANgIMQQAhASAAQQAoAryXgIgANgIAIABBACgCsJeAiAA2AgQgAEEAKAK0l4CIADYCCCAAQQAoAriXgIgANgIQQQAQjICA
gAA5A6iXgIgACyABC2QBA39BACEAAkACQEEAKALAl4CIACIBRQ0AA0AgACECIAEiACgCFCIBDQALAkAgAkUNACACQQA2AhQLIAAQ
6YCAgAAgAEEAKALAl4CIAEcNAUEAQQA2AsCXgIgACxCjgICAAAsLwQUBB38jgICAgABBwAJrIgEkgICAgABBAEEAKwOgl4CIACAA
oDkDoJeAiAACQCABQRAQpICAgAAiAkEBSA0AIAEiAyEEA0AgAiEFAkACQAJAAkACQAJAIAQoAgBBf2oOBwEABAQCBAMECyAEKAII
RQ0DIAQoAgRBqYAcRw0DAkBBACgCwJeAiAAiBkUNAEEAIQIDQCACIQcgBiICKAIUIgYNAAsCQCAHRQ0AIAdBADYCFAsgAhDpgICA
ACACQQAoAsCXgIgARw0FQQBBADYCwJeAiAALEKOAgIAADAQLIAQoAgxFDQIgBCgCCEGCAUcNAgJAQQAoAsCXgIgAIgZFDQBBACEC
A0AgAiEHIAYiAigCFCIGDQALAkAgB0UNACAHQQA2AhQLIAIQ6YCAgAAgAkEAKALAl4CIAEcNBEEAQQA2AsCXgIgACxCjgICAAAwD
CyAEKAIQRQ0BIAQoAgxBAUcNASAEKAIEIgJBAEgNASAEKAIIIgZBBUoNASAGQQBIDQEgAkEFSw0BAkBBACgCwJeAiAAiBkUNAEEA
IQIDQCACIQcgBiICKAIUIgYNAAsCQCAHRQ0AIAdBADYCFAsgAhDpgICAACACQQAoAsCXgIgARw0DQQBBADYCwJeAiAALEKOAgIAA
DAILIAQoAghBAUcNACAEKAIMQQVKDQAgBCgCEEEFSg0AAkBBACgCwJeAiAAiBkUNAEEAIQIDQCACIQcgBiICKAIUIgYNAAsCQCAH
RQ0AIAdBADYCFAsgAhDpgICAACACQQAoAsCXgIgARw0CQQBBADYCwJeAiAALEKOAgIAADAELQQAoAsCXgIgAIAQQ64CAgAALIAVB
f2ohAiAEQRRqIQQgBUEBSg0AIAMhBCABQRAQpICAgAAiAkEBTg0ACwtBACgCwJeAiAAgABDsgICAACABQcACaiSAgICAAAtKAEEB
QQBBAEEAKAKwl4CIAEEAKAK0l4CIAEH/gcGBAhCOgICAAEEBQQBBAEEGQQZB/4GAeBCOgICAAEEAKALAl4CIABDtgICAAAsL8A4B
AEGACAvoDjAxMjM0NWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6ADAxMjM0NWFiY2RlZmdoaWprbG1ub3BxcnN0dXd4eXoALi4u
ZW1wdHkAICBOZXcgZGV2aWNlICVkOiAleDoleDoleABJbnB1dAAuLi5lbmQgb2YgbGlzdABMaXN0ACEhISB0b3VjaGlkICVkIGFs
cmVhZHkgZXhpc3RzACAgJWQgYnV0dG9ucwBUcmFuc2Zvcm1zAFByaW1pdGl2ZXMAVG9vIE1hbnkgU3ByaXRlcwBMaXN0IFJlc291
cmNlcwBsb2NrZWQgY3Vyc29yAE5vIGFjY2VsZXJvbWV0ZXIAQWNjZWxlcm9tZXRlcgBJbnRlcm1lZGlhdGUgRnJhbWVidWZmZXIA
QXVkaW8AVmlkZW8Ad2FzbQAhISEgVW5hYmxlIHRvIHJlY29yZCBrZXlib2FyZCBldmVudCAleD0lZCwgYnVmZmVyIGZ1bGwARGVj
YWwATW91c2UgTG9jawBSYXcgSm95c3RpY2sAVG91Y2gAc29uZwBzdHJpbmcAMDEyMzQ1Njc4OWFiY2RlZgAgIFJlcGVhdDogdHJ1
ZQBXcml0ZQBNb3VzZQAgIEZvcmNlOiBmYWxzZQBTdG9yZQBSZWFsIHRpbWUAR2FtZSB0aW1lAFRpbGUARUdHX0VWRU5UX1RPVUNI
IGZhaWxlZCB0byBlbmFibGUAbGFuZ3VhZ2UAU3RyaW5ncyBieSBMYW5ndWFnZQBpbWFnZQBQZXJzaXN0ZW5jZQBSZWZlcmVuY2UA
VE9ETzogbWVudV9rZXlib2FyZABLZXlib2FyZABzb3VuZABSZWFkAC4uLnRvbyBiaWchICVkPiVkAGRldmlkPSVkIGJ0bmlkPSVY
IHZhbHVlPSVkACEhISBJbnZhbGlkIHRvdWNoIHN0YXJ0IGV2ZW50IGZvciB0b3VjaGlkICVkACEhISBVbmV4cGVjdGVkIHRvdWNo
IGZpbmlzaCBldmVudCBmb3IgdG91Y2hpZCAlZAAhISEgVW5leHBlY3RlZCB0b3VjaCBtb3ZlIGV2ZW50IGZvciB0b3VjaGlkICVk
ACEhISBVbmV4cGVjdGVkIHN0YXRlICVkIGZvciBldmVudCBvbiB0b3VjaGlkICVkAE1pc2MAbWV0YWRhdGEAbXlTdG9yZWREYXRh
AEpPWQBLRVkAVEVYVABNQlVUVE9OAE1NT1RJT04ATVdIRUVMAFRPVUNIAElkZW50aWNhbD8AVGludDoATGFuZ3M6AEFscGhhOgAg
IFRyaW06IDk5ACEhISBGYWlsZWQgdG8gbG9hZCBpbWFnZTowOjgATW9kZTcARm9yY2UgUGxheWhlYWQgdG8gMS4wAFBsYXkgU29u
ZyAwAFBsYXkgU291bmQgMAAgIFBhbjogMABGYWlsZWQgdG8gZW5hYmxlICVzIGV2ZW50cy4AV2F0Y2ggbG9nIGZvciByZXN1bHRz
LgAhISEgRmFpbGVkIHRvIGFkZCB0b3VjaCAlZC4gRXhwZWN0IGZ1cnRoZXIgZXJyb3JzLgBKb3kgb3IgUS4uUCB0byBwbGF5IG5v
dGVzLgBFc2MsIG1vdXNlLCBvciAxMCBzIGlkbGUgdG8gcmV0dXJuLgBtZW51X3JhdyBjbG9zaW5nIGR1ZSB0byAlZiBzIGlkbGUu
AEwvUiB0byBjaGFuZ2UuAExpc3Rpbmcgc3RvcmFnZSBrZXlzLi4uAFJlYWRpbmcgJ215U3RvcmVkRGF0YScgZnJvbSBzdG9yYWdl
Li4uAC4uLiclLipzJwBXcml0aW5nIHN0b3JhZ2UgJ215U3RvcmVkRGF0YScgPSAnJS4qcycAICAnJS4qcycAICAiJXMiAFRvbyBt
YW55IQAuLi5zdWNjZXNzIQBOb25lIQBlZ2dfbG9ja19jdXJzb3IgZmFpbGVkIQBJbml0aWFsaXplIHRleHR1cmUgZmFpbGVkIQAu
Li5GQUlMVVJFIQAhISEgbWVudV9yYXcgcmVxdWlyZXMgYSBmb250IG9yIHRpbGVzaGVldCAhISEAAAAAAAAAAAAAAGZzLThSweA/
GC1EVPsh+T9mcy04UsHwPwAAAAAAAAAAAAAAAAAAAIAAAAAAgAAAAP8AAACAAAD//wAA/4D/AAD//wAAgP////////8AAAAAAAAA
AAAAAAAAAAAAQAAAAIAAAADAAAAA/wAAAAAAAAAAAAAAAAAAADIACgD/////WgAKAP////9GABQAAAAA/1oAHgD/AAD/RgAoAP8A
AAAAAAAAAAAAAGQACgD/////yAAKAP8AAP94ACgAAP8A/8gAKAAAAP8AZAA8ABQAAAAAAAAAAAAAABQALQAWACgALQAXADwALQAY
AFAALQAZAGQALQAaAHgALQAbAIwALQAcAKAALQAdABQASwAWACgASwAWATwASwAWAlAASwAWA2QASwAWBHgASwAWBYwASwAWBqAA
SwAWB2gHAAAxBQAAlgUAADUGAACRBQAAbgYAAADLGwRuYW1lAaMbzAEAFGVnZ19pbWFnZV9nZXRfaGVhZGVyARBlZ2dfaW1hZ2Vf
ZGVjb2RlAhJlZ2dfdGV4dHVyZV91cGxvYWQDD2VnZ190ZXh0dXJlX25ldwQPZWdnX3RleHR1cmVfZGVsBRZlZ2dfdGV4dHVyZV9n
ZXRfaGVhZGVyBg9lZ2dfcmVuZGVyX3RpbnQHEGVnZ19yZW5kZXJfYWxwaGEIDWVnZ19kcmF3X3RpbGUJEGVnZ19yZXNfZm9yX2Vh
Y2gKFmVnZ19nZXRfdXNlcl9sYW5ndWFnZXMLC2VnZ19yZXNfZ2V0DA1lZ2dfdGltZV9yZWFsDQdlZ2dfbG9nDg1lZ2dfZHJhd19y
ZWN0Dw1lZ2dfZHJhd19saW5lEA1lZ2dfZHJhd190cmlnEQ5lZ2dfZHJhd19kZWNhbBIUZWdnX2RyYXdfZGVjYWxfbW9kZTcTG2Vn
Z19qb3lzdGlja19kZXZpZF9ieV9pbmRleBQQZWdnX2V2ZW50X2VuYWJsZRUUZWdnX2pveXN0aWNrX2dldF9pZHMWHGVnZ19qb3lz
dGlja19mb3JfZWFjaF9idXR0b24XFWVnZ19qb3lzdGlja19nZXRfbmFtZRgPZWdnX2xvY2tfY3Vyc29yGQ5lZ2dfdGltZV9sb2Nh
bBoWZWdnX3RleHR1cmVfbG9hZF9pbWFnZRsNZWdnX3N0b3JlX2dldBwNZWdnX3N0b3JlX3NldB0WZWdnX3N0b3JlX2tleV9ieV9p
bmRleB4PZWdnX2F1ZGlvX2V2ZW50HxZlZ2dfYXVkaW9fZ2V0X3BsYXloZWFkIBNlZ2dfYXVkaW9fcGxheV9zb25nIRRlZ2dfYXVk
aW9fcGxheV9zb3VuZCIWZWdnX2F1ZGlvX3NldF9wbGF5aGVhZCMXZWdnX3JlcXVlc3RfdGVybWluYXRpb24kDWVnZ19ldmVudF9n
ZXQlEV9fd2FzbV9jYWxsX2N0b3JzJghmb250X2RlbCcIZm9udF9uZXcoDWZvbnRfYWRkX3BhZ2UpDWZvbnRfZ2V0X3Jvd2gqEWZv
bnRfY291bnRfZ2x5cGhzKxBmb250X2NvdW50X3BhZ2VzLBZmb250X3JlbmRlcl90b190ZXh0dXJlLRBmb250X2JyZWFrX2xpbmVz
Lgxmb250X21lYXN1cmUvF2ZvbnRfcmVuZGVyX3N0cmluZ19yZ2JhMBdmb250X3JlbmRlcl9uZXdfdGV4dHVyZTESZm9udF9tZWFz
dXJlX2dseXBoMhVmb250X3JlbmRlcl9zdHJpbmdfYTEzFWZvbnRfcmVuZGVyX2NoYXJfcmdiYTQTZm9udF9yZW5kZXJfY2hhcl9h
MTUTdGlsZV9yZW5kZXJlcl9iZWdpbjYRdGlsZV9yZW5kZXJlcl9lbmQ3EnRpbGVfcmVuZGVyZXJfdGlsZTgUdGlsZV9yZW5kZXJl
cl9zdHJpbmc5EHRleHRfdXRmOF9kZWNvZGU6EHRleHRfdXRmOF9lbmNvZGU7CXRleHRfaW5pdDwPdGV4dF9jYl9mb3JfcmVzPRF0
ZXh0X2dldF9tZXRhZGF0YT4PdGV4dF9nZXRfc3RyaW5nPxZ0ZXh0X2Zvcl9lYWNoX2xhbmd1YWdlQBF0ZXh0X2dldF9sYW5ndWFn
ZUERdGV4dF9zZXRfbGFuZ3VhZ2VCBm1lbWNweUMHbWVtbW92ZUQGbWVtY21wRQdzdHJuY21wRgZzdHJkdXBHBm1lbXNldEgEZmFi
c0kDc2luSgNjb3NLBWF0YW4yTAVmcmV4cE0EcG93Zk4EZm1vZE8DbG9nUANleHBRBG1vZGZSBWxkZXhwUwVsb2cxMFQEc3FydFUK
ZnBjbGFzc2lmeVYGbWFsbG9jVwRmcmVlWAdyZWFsbG9jWQZjYWxsb2NaBHJhbmRbBXNyYW5kXApzcmFuZF9hdXRvXRNtZW51X25l
d19wcmltaXRpdmVzXhJfcHJpbWl0aXZlc19yZW5kZXJfEl9wcmltaXRpdmVzX3VwZGF0ZWARX3ByaW1pdGl2ZXNfZXZlbnRhEXBy
aW1pdGl2ZXNfbW90aW9uYhFtZW51X25ld19qb3lzdGlja2MQX2pveXN0aWNrX3JlbmRlcmQQX2pveXN0aWNrX3VwZGF0ZWUPX2pv
eXN0aWNrX2V2ZW50Zg1fam95c3RpY2tfZGVsZxNtZW51X25ld190cmFuc2Zvcm1zaBJfdHJhbnNmb3Jtc19yZW5kZXJpCG1lbnVf
ZGVsaghtZW51X25ld2sKbWVudV9ldmVudGwLbWVudV91cGRhdGVtC21lbnVfcmVuZGVybg9tZW51X29wdGlvbl9hZGRvEW1lbnVf
b3B0aW9uX2V2ZW50cBJtZW51X29wdGlvbl91cGRhdGVxEm1lbnVfb3B0aW9uX3JlbmRlcnIcbWVudV9vcHRpb25fcmVhZF90YWls
X3N0cmluZ3MZbWVudV9vcHRpb25fcmVhZF90YWlsX2ludHQcbWVudV9vcHRpb25fcmVhZF90YWlsX2RvdWJsZXUfbWVudV9vcHRp
b25fcmV3cml0ZV90YWlsX3N0cmluZ3YcbWVudV9vcHRpb25fcmV3cml0ZV90YWlsX2ludHcfbWVudV9vcHRpb25fcmV3cml0ZV90
YWlsX2RvdWJsZXgQbWVudV9uZXdfbGlzdHJlc3kPX2xpc3RyZXNfcmVuZGVyeg9fbGlzdHJlc191cGRhdGV7Dl9saXN0cmVzX2V2
ZW50fAxfbGlzdHJlc19kZWx9D2xpc3RyZXNfYWRkX3Jlc34VbGlzdHJlc19yZWJ1aWxkX3RpbGVzfxBtZW51X25ld19zcHJpdGVz
gAEPX3Nwcml0ZXNfcmVuZGVygQEPX3Nwcml0ZXNfdXBkYXRlggEOX3Nwcml0ZXNfZXZlbnSDAQxfc3ByaXRlc19kZWyEARFzcHJp
dGVzX3NldF9jb3VudIUBDW1lbnVfbmV3X21haW6GAQxfbWFpbl9vcHRpb26HAQxtZW51X25ld19yYXeIAQtfcmF3X3JlbmRlcokB
C19yYXdfdXBkYXRligEKX3Jhd19ldmVudIsBCF9yYXdfZGVsjAEUcmF3X2NiX2NvdW50X2J1dHRvbnONAQpyYXdfYXBwZW5kjgEO
bWVudV9uZXdfc3RvcmWPAQ1fc3RvcmVfb3B0aW9ukAESbWVudV9uZXdfbW91c2Vsb2NrkQERX21vdXNlbG9ja19yZW5kZXKSARFf
bW91c2Vsb2NrX3VwZGF0ZZMBEF9tb3VzZWxvY2tfZXZlbnSUAQ5fbW91c2Vsb2NrX2RlbJUBDW1lbnVfbmV3X21pc2OWAQxfbWlz
Y19yZW5kZXKXAQ5taXNjX3JlcHJfdGltZZgBEW1lbnVfbmV3X2tleWJvYXJkmQEQX2tleWJvYXJkX3JlbmRlcpoBEF9rZXlib2Fy
ZF91cGRhdGWbAQ9fa2V5Ym9hcmRfZXZlbnScAQ1fa2V5Ym9hcmRfZGVsnQEObWVudV9uZXdfdG91Y2ieAQ1fdG91Y2hfcmVuZGVy
nwENX3RvdWNoX3VwZGF0ZaABDF90b3VjaF9ldmVudKEBCl90b3VjaF9kZWyiARRtZW51X25ld19wZXJzaXN0ZW5jZaMBE19wZXJz
aXN0ZW5jZV9vcHRpb26kARNfcGVyc2lzdGVuY2VfcmVuZGVypQEUbWVudV9uZXdfZnJhbWVidWZmZXKmARNfZnJhbWVidWZmZXJf
cmVuZGVypwETX2ZyYW1lYnVmZmVyX3VwZGF0ZagBEF9mcmFtZWJ1ZmZlcl9kZWypARZmcmFtZWJ1ZmZlcl9kcmF3X3NjZW5lqgEQ
bWVudV9uZXdfc3RyaW5nc6sBD19zdHJpbmdzX3JlbmRlcqwBD19zdHJpbmdzX3VwZGF0Za0BDl9zdHJpbmdzX2V2ZW50rgEMX3N0
cmluZ3NfZGVsrwEOc3RyaW5nc19jYl9yZXOwAQ9zdHJpbmdzX2NiX2RyYXexAQ5tZW51X25ld192aWRlb7IBDV92aWRlb19vcHRp
b26zAQ5tZW51X25ld19tb3VzZbQBDV9tb3VzZV9yZW5kZXK1AQ1fbW91c2VfdXBkYXRltgEMX21vdXNlX2V2ZW50twEKX21vdXNl
X2RlbLgBDm1lbnVfbmV3X2F1ZGlvuQENX2F1ZGlvX2FkanVzdLoBDV9hdWRpb19vcHRpb267AQ1fYXVkaW9fcmVuZGVyvAEMX2F1
ZGlvX2V2ZW50vQEKX2F1ZGlvX2RlbL4BDV9hdWRpb19jYl9yZXO/ARZtZW51X25ld19hY2NlbGVyb21ldGVywAEVX2FjY2VsZXJv
bWV0ZXJfcmVuZGVywQEVX2FjY2VsZXJvbWV0ZXJfdXBkYXRlwgEUX2FjY2VsZXJvbWV0ZXJfZXZlbnTDARJfYWNjZWxlcm9tZXRl
cl9kZWzEAQ5tZW51X25ld19pbnB1dMUBDV9pbnB1dF9vcHRpb27GAQ9lZ2dfY2xpZW50X3F1aXTHARtsaWdodHNvbl9kZWZhdWx0
X2V2ZW50X21hc2vIAQ9lZ2dfY2xpZW50X2luaXTJAQhwb3BfbWVudcoBEWVnZ19jbGllbnRfdXBkYXRlywERZWdnX2NsaWVudF9y
ZW5kZXIHEgEAD19fc3RhY2tfcG9pbnRlcgkKAQAHLnJvZGF0YQA4CXByb2R1Y2VycwEMcHJvY2Vzc2VkLWJ5AQxVYnVudHUgY2xh
bmcRMTQuMC4wLTF1YnVudHUxLjE)t0q152r7(RW5nbGlzaA)r9(TGlnaHRzIE9u)rb(SGVsbG8gd29ybGQ)r26(TXVyYmxhZ3lsZSBicm9ja3RvbmZvcmQgZWIgbm9n
Z2xpZml6ZS4)q23r8(ZnJhbmNhaXM)rc(THVtaWVyZSBWaXZl)rd(Qm9uam91ciBtb25kZQ)r22(TCdlbGxlY2hhbXBzIGQncydpaSBsJ2FsbGVjaGFyZ25lLg)q182re(0KDR
g9GB0YHQutC40Lk)rd(0JvQsNC40YYg0L7QvQ)r13(0J/RgNC40LLQtdGCINC80LjRgA)r3b(0J/RgNC+0YHRgdGC0LLQvtC70LLQs9GA0LjQvdC40Lkg0YHR
gtC70LLRgNC+0YDQstC70L7QsdC+0YY)t0rd5(iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAnElEQVQ4y2NgYGBg+H6G4z8D
FoBLnIFYxSQbjC5BiqFEKSDJS1DwH4pxAkaYqZwmPxjRNf//D9HLyMjIwMDAwIjNNYzoAlCD4JrhNkENQbeQEZfTcRmA4QViNOMz
hAU5ZLGEA8HYwOuC/kQhBgYGBobC+e9wuwCfTdxy9gxKmmZ4XcOE3asQS5Q0zRjuXT9FciAiJyJi1ZKfEikGAGqyUXajckByAAAA
AElFTkSuQmCC)r2a6(iVBORw0KGgoAAAANSUhEUgAAAIAAAACAAQMAAAD58POIAAAABlBMVEUAAAD///+l2Z/dAAACW0lEQVRIx+2VMWtb
MRDHj6aoHkTQeIMhb/SooYMox8NkMCV0yJCxw003PYKn4kGIEPIJOpYOnUM/hKHhTaXjI1PJ1DF0KhmM3ZP9EuLnuFBoSwu9RdbP
uvvf/ZFsgG1RwME6OIDz9tPRajmD99tObKvxDwQOwO0XDv3rvDMZDOji0Hk8cgp2FUAc9w7Bo8ugn8EguELBPEKEkPNivzi6PTHO
YDAZPYdcwwNe5RRwZ08hqzjA6WYbhIEkUaISwAITSHgxEmYjgprtRyBoTQvQRzRwjNhPMVpNQQbbh1fojTFixWhCRNQUHpmRoALd
eVWhSIYIyUBPVXCzj6gnYkokZGs+rQlORYOZVf4j118E3ui2BZd8/U3gPEWWyeQ4of3K87nA29UJbbS65OazwMmqRgZa45NAkqzC
pVCoU60qD/VRJqnrWlKYBrU1V0AFlRh/heEONEGsH2OlKVoUpZo7Qh+wBuBqYhRcB/S+n2fl40pBqCtkv7sEzyQiudMaUzAB5pt9
eGC9FNkrO13ahZQBKoaLJbAmUqmWRjUIZ1FnKXV8IZ3W3mCTJLfKqlNmx7CRFjCa7McKlKsagqG2jdCWq9oueqfWgHdY6PjlSyI1
SCQpGGeRpAZdNySWnW2WjmWDGhTUE/2cwtmPOZVeQU/9MEyWnHqcVipsbu/nj97QrPv1SdwnD8MOwHctebJYrIObTspOt+jjrmTv
IbA3uwfyUywe7c2oC4Z0H6iJd6Bo16HvAuiAuxj+DnDyZ8DOh8V6H7bbmOv+SXTn35vC//glsfHA+OcBbfnF+HviO+IR1/C4hII0
AAAAAElFTkSuQmCC)r20d(iVBORw0KGgoAAAANSUhEUgAAAFQAAAA2AQMAAABjmSzTAAAABlBMVEUAAAD///+l2Z/dAAABwklEQVQoz33R
zUsbQRQA8Jc4kjVIGxcPQXKYTLOwu4deBMHbugQ1OTXW3npQvHhsUBAPwuQLNn5AWEZUiEu67KL+AYKFCq2kB6FY8D/Q1ksPQegx
F9+uH7UFfTDw4/F4b+YNHMUaDQEACTyf8prq7vPQld+yyj5woOjSBEmw7sW1ge65rOtBnqMjpu2xfR5BAn+ZHhqE/l54CAL/R3H0
dNmZ4xBDrxHNjApuWNhoJ3TLMdAHyR8L1bkavMKaU5qOZxstx0TX0ZMNHpTAwvHXojWzDtFnZsHZsPNHORGs+gWWtfybaqYsRr5R
qGlmYE+/onDYMd9ffS639UMKx0Hesz19l0IpqPdswTYorLwedir+9y0X+zwVP1NL56uq2x2zAIRdktFxQ9zZZzJ1AX41Z+UpN8US
+ICqPSBP+ZIpoWvot/NWmaAr5xf9TLW6vfz6yVncIFESkUKPG4QQ5dbpYvNsKdK3l0TH8kpG+LlpD92XV9rCr9+b3OdjxWZ70Vem
t+/6Jh6tcEb6Z6/6I+fC9x51RCH7IhfMEj4RBY1ZHt5ftNri3UAm1xPkWxl7U1Nv6z+ezMaznbAPDz4QqPTX4V5vAIcAlO/GwEFb
AAAAAElFTkSuQmCC)r220(iVBORw0KGgoAAAANSUhEUgAAAFUAAAA2AQMAAACMW0ftAAAABlBMVEUAAAD///+l2Z/dAAAB1UlEQVQoz2Po
aFCa62/AwPi8gYFBlmPRggkdDEwCDAwMmuwyO4RmLGC6AGSvbOVQEVnpXzUBxGaXmSO0q5EJxJ6r0dEi0OgAVt95gGMHP8MCxgcM
uIHDOQU5JgelbiUge4mbgwnTAqVOBSDbL6/BhMlLZbITkM3CwCBygJVDoQ2sg1PkANO0wgwgiw/IZmBVm5TRABLnF2HgUpqlDlbD
0cCBZIcElBaRWCXwuUNRlGUKA4OSqoOmi4tTQ6cDA0OyxDFDF7nve+/eYWCYslTTK0WgRaGjg4Hh+9731UdknluA2CBxlwCIOIhd
PA+iHgQYkexihtKFHsoiC/gmuGl4GDB4tbis4JjI0cnQ58HgwZMscVSpgcFL04PhVdCUpUoqQMM0Axi8gWxVjaWanic9GLwuTVmq
MVFV0wOovsgnWeKAnsQxg44InGGoBPQXg0JLiCfQL46qDhoMglxMUyBSgu6GPQkgRvGc51YrvIImdTRA3H+ieM4jGLvDSaAJxAaq
sXxu2JPU0QDRzIRkBxuU5gT5i0GhJxDIlgL6i4lXUIhJYQEDOLyFgBgYedY9yRLnl3oFTdmpwAAklypogkkwW0kIIm4E8peOYU/y
AqTUsUABKRwPAAD+UJDf5v2M2AAAAABJRU5ErkJggg)r232(iVBORw0KGgoAAAANSUhEUgAAAF8AAAA2AQMAAACbedckAAAABlBMVEUAAAD/
//+l2Z/dAAAB50lEQVQoz2Nw2qHYt+KckIwgpxIDg4KAU8AELyEOhTYg5/uELwIgjpcCkNMi084zwXt+X1DGIgaG50ItTJO8gjyT
loJkhJqcQJxgJTugnimNcyZOntzppcPBgAekWz6u8pzo5e+qVsHAMEWV1ckr2MgzV9MDzHEMCGbqDAVxvltyFjyY6s0Z+hIks5TT
MSAyCiIzZSm/k1dklqcriDPdkhNkWqCrmgc+Sx/bNSlpqob6CS7s7GOY0uFSBOR4CSzyCmKYwqGx0lM11ElggVYQwxMOgRWdsqHO
cza882No4VBY6cka6hS0QsuNoaXDoUgTxFnl5cXQzNGgpN/6/fHcjZ2TYDYoYFrK2AAiHCAcJjDZAOGkWB5LjenSlNI0PsDAIK7K
NblpVpZ2phdQaclOroc8q9ZorQdxpiwVam46raWlCeIUW8qB9HhpGjkwkAUe1woKBoWGHFk8WQZotKBwF5DjsiBkCZAjsNQl8GpI
2sY7a0AcV6+A0JDwFSFTgHoEmydWxNelbZ6sAnI8I9wjMJ9AgNMEsPcbBUGUgoUDYwAD4yEOoN8YkgWY5zBaTGhpYAH5Z84XRQWN
CU9VRRxACaldUlHnxzSdJQ6ghNTCqqg1ZaqJO1BTskjzTlWfGVOWNjIghx0aAADsI5thJcwqQAAAAABJRU5ErkJggg)r85(iVBORw0KGgoA
AAANSUhEUgAAADcAAAAJAQMAAACsZSbYAAAABlBMVEUAAAD///+l2Z/dAAAAOklEQVQI12NgAAH5HwwThBjYHyiwMHiorOpQUJnC
oOLBILRQawmD0AQGRf1VR+B8DxUGDpA8TD1UPwA0+Q+Fiuq8wwAAAABJRU5ErkJggg)rf5(iVBORw0KGgoAAAANSUhEUgAAADAAAAAQCAYA
AABQrvyxAAAAvElEQVRIx82V0RHEIAhEV0q5JlLM1ZdibCKtmB9vJmPg1FVMmMknPFhwA9wj5W9GzKylhpTAI+444g4SfG1Yq5W8
BxhSuzJ8GhBmyQB/IzdfbuudAyjNum1Dem66Agyf7TtjQIup8qUG+ilV3LeXsySLafFDeZMN6wcAZLWDcRpMDYovDNjB72m+dD6+
2tpZ9Wm+LHYftz9xs4OMuI9HDWoDyvq7GjAMgMqXiUo+kh96HaFBvaX5MuocT+efVe6L32f2dpAAAAAASUVORK5CYII)rbc4(iVBORw0KGgoA
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
QmCC)t0s2rf88(vu7uUAHCACoAKiNYgAAaLIAAUXiAAAxogAATQIAAVFKAAIASgAAAAAAAiQ3Dhk/Hg8qCi8kCPz8/NIpPh4PKgT8/PyOM
D4KKT0WDyoGLygI/Pz8hjA+CiE6xi8oBPz8/I4wMhIvJAoPKgT8/PyKDyoE/Pz8jjQ+Ej5JLj5GLg8qCi8oCPz8/JIPKgT8/PyKO
DcODyoGLyQI/Pz8ij5JIj5GHg8qBPz8/I4oPgoPKgYvKAT8/PyGMD4SLygKDyoE/Pz80jQyEj5KLj5DLi8kCg8qBPz8/I4PKgT8/
PyOND4SDyoGLygI/Pz8jjpDFj5KFg8qBPz8/I48NxI9txoPKgYvJAj8/PyKPcMWDyoE/Pz8jjA+Cj23Ei8oCg8qBPz8/IokPhI5u
RIvKAoPKgT8/PyKLDIWPcUaDyoGLyQI/Pz8ij25Eg8qBPz8/IowPhY9ug4PKgYvKAj8/PzSPcYWDyoE/Pz8jjQ3Fj26Fi8kCg8qB
Pz8/Io9vB4PKgT8/PyOPDYOOcgaLygKDyoE/Pz8ijm8Gi8oCg8qBPz8/Io8NRY9vRYvJAoPKgT8/PyKIckWDyoE/Pz8jjw0Gj2+F
g8qBi8oCPz8/IYhyhILKgT8/PyOPDMWPT8mLyQODyoE/Pz8jjU+Hg8qBPz8/NI8OgopOhYvKAoPKgT8/PyKMDoKPTaODyoGLygI/
Pz8ijQzDg8qBi8kCPz8/IoPKgT8/PyOPDoSDyoKLygI/Pz8ig8qBPz8/I44NRYpNSI9tRoPKgYvJAj8/PyGMbgeTKj8/PyKMDwOP
bsiDyoGLygE/Pz8ijA8EjW+Ji8oCg8qBPz8/NI8NQoxwRovJAoPKgT8/PyKOcQeDyoE/Pz8jjA8FjXHFi8oCg8qBPz8/IYhyhYPK
gT8/PyOODAiIctuPkM6Pks6LyQKDyoE/Pz8jjA3Gkyo/Pz8ijA8Fg8qBi8oBPz8/IowMCIySFo+P1ovKAoPKgT8/PyOKDceLyQKD
yoE/Pz8jig8Gg8qBPz8/IowMCYvKAoPKgj8/PzSMDceDyoE/Pz8jjA8Gj4/Oj5DNi8kCg8qBPz8/IZMqEo4MBz8/PxGMDciLygKD
yoE/Pz8ijA8Gj4/Yj48XiskFg8qBPz8/Io4MB4PKgYvKAj8/PyOODceDyoGLyQI/Pz8iig8Gi8oCg8qBPz8/IYwMCIvJAoPKgT8/
PyOODIWPL4OPLkKPLIOPT8OPr8aLyQODyoI/Pz8yiS+BjyyBjC5BjU+CiK+Fg8qBPzCHLIKMLkGPL4E/L48OQo8vgo8uQo8sgo9P
QouvRovKAoPKgT8/PyGLDkKLLkKPL4KPLIKPT4KJr4aLygKDyoE/Pz8hiwyEjC+Ciy5CjyyCj0/DiK/Fi8kCg8qBPz8/II4uQo8s
go8vgo1Pg4qvhoPKgT8/Ao8uQY8vgY8sgT8vjw5FjyyCjy5Cjy+Cj09Diq9Gg8qBi8oCPz8/IYcuRI8vhI8sg45Pg4uvhoPKgT8/
PyKNDISPLIKPLkKPL4KPT8SPr8aDyoGLyQI/Pz8hjy+Bji5BjyyBjE+DiK+GgcqBPzCPL4GLLkGPLIE/MI0OQo8sgo8uQY8vgY9P
RIivRoPKgovKAj8/PzKLDkKNL4SDLkOPLIKPT4KJr4aLygKDyoE/Pz8gjg6GjyyWjy5Ujy+Sj1CYj7Cdi8kCg8qBPz8/IowOR5Mq
Pz8/I44OBoPKgYvKAj8/PyKMDkWDyoE/Pz8ijw3Fjy3Djy+DjzDCj0/Cj6/Gi8kCg8qBPz8/II8vgY8wwo8twY1PgYqvhoPKgT8/
A48vgYgtwY0wwT8viw+Cjy3EjzDCjy+Bj09CiK9Gi8oBg8qBPz8/IIsPg48vgo8wwo8twotPgoivhovKAoPKgT8/PyCJDcSPMMKP
LcKPL4KPT8OLr8aLyQODyoE/Pz8ijy3BjjDBjy+Bj0+Ch6+Gg8qBPy+NMMGPL4GPLcE/MY8PhY8vgo8two8wwY9PQ4evR4vKA4PK
gT8/PzKPL4KPLcKPMMKNT4OIr4c/Pz8jjA3Ejy3BjzDBjy+Bj0/Eiq/Gi8kCg8qBPz8/IY8wwY8vgY8twY5Pg4ivhoPKgT8wjzDB
jy3Bjy+BPzCPD4KPLcKPMMKPL4KPT0SJr0aDyoGLygI/Pz8hjQ+Djy+Bjy3BjzDBjU+Cia+Gi8oCg8qBPz8/IY4Px48w1o8t1Y8v
lo9RlI+xlIvJA4PKgT8/PyOMD4eDyoE/Pz8jjg9Gi8oCg8qBPz8/M44Ph4PKgT8/PyKPDIWPLkGPL4KPLIKPT8SPslKDyoKLyQI/
Pz8gjy+BjC5BjyyBjU+Cg8qBPy+PL4GILIGPLkE/MI8OQo0sgYssgY8uQY8vgY1PQ4PKgovKAj8/PyCKDkSPLkGPLIKPL4KOT4SP
spaLygKTKj8/PzOJDIWPLIGPLkGPL4GPT8SDyoKLyQI/Pz8gjyyBjy+Bjy5BjE+Dg8qBPzCILkGIL4GILIE/MY4ORI8vgY0uQY8s
go8vgY8uQY9PQ4PKgYvKAj8/PyGPLkKPL4KPLIKMT4OMskGDyoE/HIyygT8KjbJBN4wMho8sgo8uQY8vgY9PxI+xhoPKgovJAj8/
PzOPLIGOLkGPL4GNT4KHsUU/L40uQYgsgY8vgT8wjQ5CnLKPL4GPLkGcso9PQ4aww4PKgYvKAj8/Px+LDkWPL4KPLkGPLIGNT4OK
sIGLygKDyoE/HIqwwTaLsIE/CowOho8vlI8slY8uV49PxI+vxovJAoPKgT8/PyGJDkgSiU+Ch6+Fg8qBPz8/IowOBYtPQoOvB4vK
AoPKgT8/Pw2Gr4YSig5Gjk+Dg8qBPz8/IY8NxY8vgo8wwo8two9Oto+v1YPKgovJAj8/PyKPLcGLMMGPL4GDyoE/MI8wwYgtwY8v
gT8wjA+Ejy3Bjy+CjzDCjy3Bg8qCi8oCPz8/M40PhI4wwY8two8vgo+unovKAoPKgT8/PyCMDcWPL4GOMMKPLcGLyQKDyoE/Pz8i
jy3BijDBji+BgMqBPzCIMMGIL4GILcE/MY0PhI4wwY8vg5y3nLePMMGDyoGLygI/Pz8gjzDBjy3Cjy+BgMqBPz8/IY8Nx48vg48t
w48wwY9N4Y+uVIvJAoPKgT8/PzSMMMGPLcGOL4E/MIgtwYswwY0vgT8xjQ2Gji3CjzDCjy+Ci8oCPz8/Io8wwY8two8vgY+uiovK
Aj8/PyOPDUiPL5CPLdCPMNCLygI/Pz8ji8oBPz8/Io0NBovKAj8/PyOLygI/Pz8kjwyGjyyCjS+Cjy5Cj0/Cj6/Gg8qBi8kCPz8/
IYgsgYguQYgvgY5PgoavhoPKgT8wji+Biy5BjyyBPzGPDkKPLkKPL4KPLISPT0OHr0aDyoGLygI/Pz8hjA5Djy5Cjy+CjyyCj0+E
ia+Hi8oCg8qBPz8/M44MhI8sgo8uQY8vgY9PxIyvxovJAoPKgT8/PyKPL4KOLkKPLIGNT4OIr4aDyoE/LogsgY8uQY8vgT8xjw5E
jy+Bjy5BjyyBjk9Ehq9Gi8oCg8qBPz8/IY8vgo8uQY8sgo9Pg4evhoPKgT8/PyCIDIaPLkGPLIGPL4GPT8SLr8eDyoGLyQM/Pz8z
jy+BjyyBjy5BjU+Dh6+GgMqBPzCOLkGPL4GPLIE/MI0OQ48uQY8vgY8sgYxPQ4ivRoPKgYvKAj8/PyGLDkOPL4GPLIKPLkGOT4KJ
r4aLygKDyoE/Pz8gjQ6HjyyQjy+Qjy5Qj1CVj7CXi8kDg8qBPz8/I4sORoLKgT8/PyKPDgaDyoGLygI/Pz8hjA5FgcqBPz8/M48N
xY8two8wwo8vgo9PxI+vxoPKgYvJAj8/PyGKMMKML4GPLcGMT4OIr4aDyoE/L4gtwY4wwY8vgT8wjA+Cjy3FjzDCjy+Cj09DiK9G
g8qBi8oBPz8/IYsPgo8two8wwo8vgo9Pg4qvhovKApMqPz8/IYoNxI8wwY8two8vgY9Pw4uvxoPKgYvJAj8/PyGPLcGPMMGPL4GM
T4SLr4eCyoE/PwSOMMGILcGPL4E/MY8PhJy3jzDCjy+Cj09DiK9Gg8qCi8oCPz8/IogwwY8two8vgo5PgoivhoPKgT8/PyGMDcSP
MMGPLcGPL4GPT8SMr8aDyoGLyQI/Pz8ijy3BjTDBjy+Bi0+Diq+GPzCILcGIL4GIMME/MY8Pgo4wwY8two8vgY1PQ4ivRoPKgYvK
Aj8/PyCND4SPL4KPMMKPLcKNT4KLr4aLygKDyoE/Pz8hjw/GjjDLjy+Mjy3Lj1GTj7GUi8kCg8qBPz8/NIsPhj8/PyKJD0aDyoGL
ygI/Pz8hjQ+Fg8qBPz8/I4wOgoUMwo8vwo8ugo8swo9RgoKM6oKN6oKOqY6xhYPKhIvJBInMQz8/PyGNDMGLDoGPL8KPLoKPLMKN
UUKNsUSDyoI/Pz8hiw6CjAzCjyzCjy/Cjy6Bj1CCh7CCi8oCg8qCPz8/IosOgooMwY8swY8ugY4vwY9RgoixhIPKgovKAj8/PyGN
DoKMDMGPLMKPLoKPL8GOUUSPsUaLyQSDyoI/Pz8yjA6BjwzBjy6Bjy/BjyzBjlCCirCCPz8/IY0OgY8MwY8ugo8swo4vwY9Rg4ux
hovKA4PKgj8/PyCPDMGJDoGPLMKPL8GPLoKOUUKIsUKAyoE/Pz8hjQwCjw3Cjy8CjywCjy3Bj1GCgY8ogo3ngYzoj7GFg8qCicxC
i8kCPz8/IYoNwosMAo8sAo0twogvAo1RRIqxRj8/PzSKDcKODAKNLAKLLcKLLwKMUMKHsMKDyoGLygKDyoE/Pz8iiw3BiwwCjiwC
jS8BjC3Bj1GDiLGFi8oCg8qBPz8/IYsMAogNwY4sAowtwo8vAo1RRI+xRovJAoPKgT8/PyGMDAKLDcGPLAKMLcKPLwKLUMKNsMI/
Pz8hjQwCjg3CjywCjy8CjC3Bj1GDiLGFi8oCg8qBPz8/IYwNwo0MAowtwY4vAY0sAo9RQoaxQ4LKgT8/PzKPDLOPDnWPLLePLnaP
L7aPUYOCjLeCjnaCjbaPsYWLyQODyoKJzEI/Pz8jjVFDirFGg8qCPz8/Io5Qg4+wh4PKgYvKAj8/PyKPUUKOsUaLygKDyoE/Pz8g
j1CCj7CFi8oCg8qCPz8/Io9Pg4mvh4HKgT8/PyOJUIKDyoKLygISirCFPz8/D4tPg4qviD8/PzOPDIWPLkKPL4GPLIKPToKProSL
ygKDyoE/Pz8gjE+Eiq+HPz8/I48NBY5Og42uhYvKAj8/PyGLTcSNrceLygE/Pz8jjQ1Hj05Mj65bi8oCPz8/Pz8/PwaPDYeLygE/
Pz8/Pz8/Bw)s6r4a4(vu7uUAITACoAKgAAAAASZIAAJkyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiDCJiDGIiEnJPz8/PyOHSoo/Pz8/DYgwiIgx
iIhLiD8/Pz8NiEzJPz8/Pw2IMIiIMYeIS4s/Pz8/DYdKhj8/Pz8MiDDpiDGqiErLPz8/Pw2HS4o/Pz8/DIZMiD8/Pz8Nh03SPz8/
Pz8/Pz8/Pz8/J4gwh4cxhodJyT8/Pz8NhkqKPz8/Pw2HMIiHMYaGS4Y/Pz8/DIhMyj8/Pz8NhzCHiDGIh0uIPz8/PwyHSoY/Pz8/
DYkw1YgyFohKyj8/Pz8Nh0uGPz8/PwyGTIg/Pz8/DIkw0YgxkYlNzD8/Pz8Nh0yIPz8/PwyHS4U/Pz8/DIgwiIgxiIhJyj8/Pz8N
h0qJPz8/Pw2IMImHMYiGS4o/Pz8/DYdMyj8/Pz8NiDCIiDGIh0uLPz8/PyKHSoc/Pz8/DIkw0YkxkohKyz8/Pz8Nh0uPPz8/PwyH
TIg/Pz8/DIgvjYgwz4hNyz8/Pz8Nh06IPz8/PwyHT4Y/Pz8/DIcvyogwS4dLij8/Pz8Nh0xGPz8/PwyIL0eIMEiHTUg/Pz8/DYdO
iT8/Pz8NiC9IiDBIh01IPz8/Pw2HTEc/Pz8/DYgv6okwaIhMDD8/Pz8NhkzLPz8/PwyHTcg/Pz8/DIdPCD8/Pz8NhE3IPz8/Pw2G
TMY/Pz8/DYgvyYgwSYdLiz8/Pz8NhkxOPz8/PwyHL0iIMEiGTUg/Pz8/DYdOij8/Pz8NiC9IiDBIhk1KPz8/PyKHTEg/Pz8/DYgw
YIcxoYhLiD8/Pz8NhkxKPz8/Pw2FTUg/Pz8/DYdOlD8/Pz8/Pz8/Pz8/PyeIM5GHTMk/Pz8/DYVNiD8/Pz8NiDNRhk6IPz8/Pw2H
T8g/Pz8/DYcy0YZOiD8/Pz8Nhk2IPz8/Pw2HMbKITcc/Pz8/DYVOij8/Pz8Nh0+IPz8/Pw2GUMg/Pz8/DYVPiD8/Pz8NhU6IPz8/
Pw2IM5CHTMs/Pz8/DYZNiT8/Pz8MiTNThk6IPz8/Pw2IT8g/Pz8/DYcyz4ZOjz8/Pz8MhU2FPz8/H4YyQyyHMpmHTcg/Pz8/DYZO
ij8/Pz8Nhk+HPz8/PwyIMZqHUMc/Pz8/DYZPij8/Pz8NhU6FPz8/PwyHM5CHTMs/Pz8/DYVNiz8/Pz8iiTNRh06IPz8/Pw2HT8k/
Pz8/DYcy0IZOiT8/Pz8Nhk2HPz8/Pw2IM1KGTAk/Pz8/DYZMyD8/Pz8NhzLShU3KPz8/Pw2HTws/Pz8/DYYyDoZNxj8/Pz8MhkzH
Pz8/Pw2IM5GGTIw/Pz8/DYZNiT8/Pz8MhzLQh05IPz8/Pw2IT4k/Pz8/DYkykIdOST8/Pz8Nh02IPz8/Pw2JNFiITMg/Pz8/DYZN
iD8/Pz8Nhk6IPz8/Pw2INJQWhk/IPz8/NoZOiD8/Pz8Nhk2GPz8/H4Y0QiyINI6HTIw/Pz8/DYdNij8/Pz8MhzRShk5LPz8/Pw2H
T4c/Pz8/DIVOSxaIM5A/Pz82hk2HPz8/PwyIMqiHTIg/Pz8/DYdNhz8/Pz8Nhk5HPz8/Pw2HT48/Pz8/Pz8/Pz8/Pz89)s1r11fb(vu7uUAIs
ACoAKgh+gAAEUIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhxCJiCrHPz8/PxqHEMiHLcg/Pz8/GogSmocuiD8/Pz8aiC3HPz8/
PxqILIk/Pz8/GYcQioctyD8/Pz8aiBDKhiuIPz8/PxqIElGILcg/Pz8/GogqyD8/Pz8ahxCLhy3JPz8/PxmIEMiGLog/Pz8/GogS
E4ctyD8/Pz8ahyyIPz8/PxqIEcmHLcg/Pz8/GYgRiIYriD8/Pz8aiBFJhy3IPz8/PxqIEIqIKsg/Pz8/GokQyYctyT8/Pz8aiRKg
hy6IPz8/PxmGLcg/Pz8/GocsiD8/Pz8ahy3JPz8/PxqHK4g/Pz8/GYcUgYgtyD8/Pz8aiRS2iSrIPz8/PxqHLck/Pz8/GocuiD8/
Pz8ahi3IPz8/PxmHK4g/Pz8/GoctyD8/Pz8ahywIPz8/PxqHLcg/Pz8/GYcRCYgsSz8/Pz8ahhCIhi4JPz8/PxqHEmOGL0g/Pz8/
GoYvyD8/Pz8ahzAIPz8/PxmHL8k/Pz8/GoYvSj8/Pz8ahxQDhS4IPz8/PxqHFBuHLEk/Pz8/GYYuCT8/Pz8ahi9IPz8/PxqHL8k/
Pz8/GocUgocwBz8ZhhTDPyiFFIM/GIYUCIYvyD8/Pz8ZhxOJhy9JPz8/PxqHEwqFLgg/Pz8/GocSyIYsST8/Pz8aiBJJhi4JPz8/
PxmHESuGL0g/Pz8/GoUvyD8/Pz8ahjAIPz8/PxqHL8w/Pz8/GoUvSj8/Pz8ZiBCJhi4HPz8/PxqIETOHLEg/Pz8/GoUuCD8/Pz8a
hi9IPz8/PxmFLgk/Pz8/GocsSj8/Pz8/Pz8/Pz8/Pz8/Pz8/KIgQiYcqyD8/Pz8aiBDIhy3IPz8/PxqIEpqHLog/Pz8/GoctyD8/
Pz8ghSyHPz8/PxKIEIkHhy3FPz8/PxmIEM0BhiuHPz8/PwiGLckQiBJQPz8/PxmIKso/Pz8/GYgQiQmILco/Pz8/DokQyQyJLoc/
Pz8/FokSDwOHLcc/Pz8/GocsiD8/Pz8TiRHJB4ktyT8/Pz8TiBGKB4crij8/Pz8RhxFHCYYtyj8/Pz8OhxCKiCrJPz8/PxqIEMuG
Lck/Pz8/GYkSooguiD8/Pz8aiC3IPz8/PxqHLIk/Pz8/GoYtyD8/Pz8ZhiuIPz8/PxqHFIGHLcc/Pz8/GokUsYgqyD8/Pz8ahi3J
Pz8/PxqGLog/Pz8/GYYtyD8/Pz8ahyuIPz8/PxqHLcg/Pz8/GoYsCD8/Pz8Zhy3IPz8/PxqHEQiHLEk/Pz8/GocQiYYuCT8/Pz8a
hxJihy9IPz8/PxqGL8g/Pz8/GYcwCT8/Pz8ahi/JPz8/PxqHL0k/Pz8/GocUAoYuCD8/Pz8ZiBQahyxIPz8/PxqGLgk/Pz8/GoYv
SD8/Pz8ahy/JPz8/PxqGFIKHMAc/HIcUwz8whhSDPwyGFAeHL8g/Pz8/GocTiYcvST8/Pz8ahxMJhi4IPz8/PxqIEsiHLEg/Pz8/
GYcSSYYuCT8/Pz8ahxEshi9IPz8/PxqGL8c/Pz8/GoYwCD8/Pz8ahi/JPz8/PxmHL0g/Pz8/GocQiYYuCD8/Pz8ahxE0hixIPz8/
PxqGLgk/Pz8/GYYvRz8/Pz8ahS4IPz8/PxqGLE8/Pz8/Pz8/Pz8/Pz8/Pz8/PyiHEYmGLMs/Pz8/GocRSYUuiT8/Pz8ahhCKhi/I
Pz8/PxmHEYqGLok/Pz8/GogRSYYsyT8/Pz8ahxCJhi6JPz8/PxqIEYiHL8g/Pz8/GogRSYYuiD8/Pz8ZiBGKhyyHPz8/PxqHEUmG
Lkg/Pz8/GocQiYcviD8/Pz8aiBFchy5IPz8/PxmHLIk/Pz8/GoYuST8/Pz8ahy+JPz8/PxqGEUmHLkc/Pz8/GocRCoYsSj8/Pz8Z
hhCIhi4IPz8/PxqHEEmHL0g/Pz8/GocRCYUuCT8/Pz8ahxCIhixJPz8/PxmHEEiGLgo/Pz8/GocRCYcvRz8/Pz8ahxBIhS4HPz8/
PxqHEUqHLAo/Pz8/GocQiYctiD8/Pz8ZiA/Dhy8KPz8/PxqHEgmGLYk/Pz8/GocRSYcsCT8/Pz8ahxCJhy2IPz8/PxmIEsiHLwk/
Pz8/GogSB4ctiD8/Pz8aiBFJhywJPz8/PxqIE4qHLYg/Pz8/GogSx4cvCj8/Pz8ZhxIJhy2HPz8/PxqIFEmHLAk/Pz8/GocTiYct
iD8/Pz8ahxRIhy8HPz8/PxmIFQmHLYk/Pz8/GocV/Ycrij8/Pz8ahi1IPz8/PxqGLoc/Pz8/GoYtRz8/Pz8ZhiuLPz8/PxqGLUk/
Pz8/GoYuiT8/Pz8ahxWChi1IPz8/PxmKFauHK4k/Pz8/GoUtSD8/Pz8ahS6HPz8/PxqFLUg/Pz8/GocrjT8/Pz8/Pz8/Pz8/Pz8/
Pz8/KIgPSIcrkD8/Pz8ZiA+IPz8/PxqIEEmHLUOHLoM/Pz8/GogPSYgtRocuhT8/Pz8ahw+IiCuQPz8/PxqIEYk/Pz8/GYkPSYct
Qogugz8/Pz8ahw+JPz8/PxqJEMiHK5A/Pz8/GocPSj8/Pz8ZiA+Ihy1EiC6DPz8/PxqJEFOHLUOHLoM/Pz8/Gocrjz8/Pz8aiA/J
Pz8/PxqID4mHLUSILoQ/Pz8/GYcPCT8/Pz8aiA+MhirRPz8/PxqHD8g/Pz8/GokQyYgsg4ktwj8/Pz8Zhw+KhyyBiS3BPz8/PxqJ
D8mIKtE/Pz8/GogRiD8/Pz8aiA+JiCyBiC3BPz8/PxqHD8k/Pz8/GYkSSIkq0D8/Pz8ahw+JPz8/PxqJD8iILIGILcE/Pz8/GocS
k4csgoctwT8/Pz8ZiSrQPz8/PxqIEkg/Pz8/GokSB4gshIctxD8/Pz8ahxGJPz8/PxqHD0qIK5E/Pz8/GYYPiD8/Pz8aiRBLhy1B
hy6DPz8/PxqID0iHLUGHLoM/Pz8/GogPiogrkD8/Pz8ZhxGKPz8/PxqJD0iHLUSILoM/Pz8/GogPiD8/Pz8aiRDIhyuQPz8/PxqH
D0k/Pz8/GYgPiYctQYcugj8/Pz8aiRBUhy1Bhy6DPz8/PxqHK48/Pz8/GoYPyD8/Pz8ZiA+IiC1DiC6DPz8/PxqGDwk/Pz8/GogP
mogqzz8/Pz8/Pz8/NIgsgogtwT8/Pz8ZiA6bhyyBiC3BPz8/PxqGKtA/Pz8/Pz8/PzSHLIGILcI/Pz8/GYgOiD8/Pz8ahw5biCrS
Pz8/Pz8/Pz80iCyBiC3BPz8/PxqIDp6ILIGILcI/Pz8/GYgq0D8/Pz8/Pz8/NIgsgoktwT8/Pz8/Pz8/M4gPSIcrkD8/Pz8ahw+I
Pz8/PxqIEEmILUGHLoI/Pz8/GogPSYctQocugj8/Pz8aiA+JhyuNPz8/PxmHEYo/Pz8/GocPSIctQogugj8/Pz8ahg+IPz8/PxqJ
EMmIK5A/Pz8/GYcPST8/Pz8aiA+Ihy1BiC6CPz8/PxqJEFOHLUGHLoE/Pz8/GogrkD8/Pz8ahw/IPz8/PxmID4iHLUGILoM/Pz8/
GocPCD8/Pz8aiQ+LiCrQPz8/PxqGD8g/Pz8/GYkQyIgsgoctwT8/Pz8aiA+KhyyBhy3BPz8/PxqID8iIKtE/Pz8/GocRiD8/Pz8a
iA+JiCyBiC3BPz8/PxmHD8g/Pz8/GogSSIgq0D8/Pz8ahw+JPz8/PxqHD8iHLIGILcE/Pz8/GYoSlIcsgYYtwT8/Pz8aiSrPPz8/
PxqHEkg/Pz8/GogSCIcsgogtwT8/Pz8ahhGIPz8/PxmID0mHK5E/Pz8/GogPiD8/Pz8aiBBJhy1BiC6DPz8/PxqID0iHLUKGLoE/
Pz8/GYgPiogrjz8/Pz8ahxGJPz8/PxqID0iILUOILoM/Pz8/GogPiT8/Pz8aiRDKhyuQPz8/PxmHD0k/Pz8/GogPiIctQogugz8/
Pz8aiRBUhy1Bhi6DPz8/PxqIK48/Pz8/GYYPyD8/Pz8aiA+Jhy1BiC6GPz8/PxqHDwk/Pz8/GokPmogq0T8/Pz8/Pz8/M4gsgogt
wT8/Pz8ahw6biCyBhy3CPz8/PxqGKtA/Pz8/Pz8/PzOILIKJLcI/Pz8/GocOiT8/Pz8aiQ5aiCrRPz8/Pz8/Pz80hyyBiC3BPz8/
PxmIDpOILIGILcE/Pz8/Gocq0D8/Pz8/Pz8/NIgOkYcsg4ctxD8/Pz8/Pz8/M4gPG4gqUT8/Pz8ahiwIPz8/PxqHLUg/Pz8/GocO
U4YsCD8/Pz8ZhipKPz8/PxqGLAg/Pz8/GogOUYctRz8/Pz8ahSwHPz8/PxmJDcmHKf8/Pz8/GocOSj8/Pz8aiA6IPz8/PxKIDko/
Pz8/GYgOiT8/Pz8ihw8JPz8/PxqHDok/Pz8/GocPCT8/Pz8ahw+IPz8/PxmGDwg/Pz8/GocPiT8/Pz8ahg/HPz8/PxqIEIg/Pz8/
GocPwT8lhxCDPyGHD8M/EogPhj8/Pz8aiA8JPz8/PxqID4qIKow/Pz8/GocOiYgshz8/Pz8Zhw5Jhy2IPz8/PxqHD8mHLIk/Pz8/
GocOiYcqiz8/Pz8ahw5KhiyIPz8/PxqID4mHLYg/Pz8/GYcOiYYsiT8/Pz8aiA5JiCqIPz8/PxqHD8mHLIk/Pz8/GogOiYctiT8/
Pz8Zhw5KhyyIPz8/PxqID4mIKoo/Pz8/GocOiYYsiD8/Pz8aiA5Khy2JPz8/PxqHDomHLIc/Pz8/GYgPiYcqyj8/Pz8ahw6JhyyH
Pz8/PxqHDkqHLcc/Pz8/GocOiYcsgYUsgT8/Pz8Zhw+JhyrMPz8/PxqHDomGLIg/Pz8/GocOSYctxz8/Pz8ahw6JhyyIPz8/PxqI
DeKHKss/Pz8/GYcsiD8/Pz8aiC3JPz8/PxqGLIg/Pz8/Gocqyz8/Pz8ZhiyIPz8/PxqHLcg/Pz8/Gocshz8/Pz8aiA+JhyqJPz8/
PxqHDomHLIg/Pz8/GYgOSYcthz8/Pz8aiA/JhyyIPz8/PxqHDomHKog/Pz8/GogOSYYsiD8/Pz8ZiBCJhy2JPz8/PxqHDomGLIg/
Pz8/GocOSYcqiD8/Pz8aiRDKhyyJPz8/PxqHDoaHLY8/Pz8/GYYOSYYsiD8/Pz8aiBGJiCqKPz8/PxqID4iHLIk/Pz8/GogRSYct
ij8/Pz8ZiA+JhyyIPz8/PxqKEhyJKss/Pz8/GocsiD8/Pz8ahy3KPz8/PxqLEpyHLIg/Pz8/GYgqzz8/Pz8ahiyIPz8/PxqHLcoB
ihG2Pz8/PxmGLIg/Pz8/GYgqzj8/Pz8ahSyJPz8/PxqILck/Pz8/GocsiD8/Pz8aiCpQPz8/PxmILAk/Pz8/GooOiIsRiYgtST8/
Pz8ahiwJPz8/PxqKDxqLEhuIKdE/Pz8/GYcriT8/Pz8aiCzJPz8/PxqJD5qJEpqHK4k/Pz8/Gogpyj8/Pz8ahyuJPz8/PxmKDfOK
EPiILMo/Pz8/GocriD8/Pz8ahynJPz8/PxqHK4g/Pz8/GYcsyD8/Pz8ahSuJPz8/PxqHKc0/Pz8/GoYriD8/Pz8aiRDLhyzJPz8/
PxmGK4g/Pz8/GogRSIgqTT8/Pz8ahxBFhiwJPz8NiBFEPz8NiRIIhy1KPz8/PxmIEUSHLAc/Pw2HEgQ/Pw2KE0gKiCpOPz8/PxCI
EgSHLAg/Pw2JE0Q/Pw2KFEgIiC1LPz8/PxKHE0SHLAg/PwyGFEQ/Pw2KFR2IKk4/Pz8/GoYsCD8/Pz8ahy1LPz8/PxqHLAk/Pz8/
GYkVFYgqSz8/Pz8ahiwKPz8/PxqHLUk/Pz8/GoYsCT8/Pz8aiQ8SihITiSnQPz8/PxmHK4k/Pz8/GogsyT8/Pz8aig+SihKShyuJ
Pz8/PxqIKcs/Pz8/GYcriT8/Pz8aiQ3wiRDyiCzJPz8/PxqHK4g/Pz8/GoYpyT8/Pz8ahiuJPz8/PxmGLMg/Pz8/GoQriD8/Pz8a
hynLPz8/PxqFK4k/Pz8/GYkQ0oYsyD8/Pz8ahiuIPz8/PxqJEGyHKk0/Pz8/GoUsCD8/Pz8ahi1IPz8/PxmGLAg/Pz8/GoYqUD8/
Pz8ahSwIPz8/PxqIEE+HLUk/Pz8/GYYsCD8/Pz8aiA8/iSpKPz8/PxqGLAk/Pz8/GoctST8/Pz8ahSwIPz8/PxmHKkg/Pz8/GoYs
CD8/Pz8ahi1IPz8/PxqGLAg/Pz8/GQ)t0s21r3b(6+sA1gBWHwQE+joUAwCZAwD//wAA3wIAFgAyANIAGQUBkADIAgMAAQAABAAH//8ADUjT
ACQdywCeAAA)r39(6+sApABpHAFMAgCT3AIADv//AK+z3AAjBAAHAOwAGQBFABgALACDAE4BAAADAAv//wAlLlgAdAAA)r42(6+sAnQBXHwILCSJT
gbYAQQASAAMCpgQA//8BAOkAAABYAQAFA20BAAAEAAT//wALKe4AGg9yAHQAAAUHCAAyAhQA)r2f(6+sBRACLAQUBAAAEAAT//wAsMI0A
Mg09AOIAAAUCWAEsBQJYAMgICPwIB9ACUAA)r6d(6+sBqgCAFwIJD2fCAC8ACQAXA7MEAABBAgAfALoAigBOAQAABAAP//8AEzlhABgWEQBQ
AAAIC7gIC7gCAgAEAEbMM4CAAf//AgBC//8BaAAAAAEFAQAABAAE//8ACWaeABso0wCOAAAFA+gBLA)r24(6+sBdABpAQUBAAAEAAr/vgAi
IjQAMA09ARgAAAUEsADIAgcA)r31(6+sBBABEHACAAgD//wEAGWWEAC8CABQA5QAwACYBAAAEABP//wAnWnsATBywAH4AAA)r36(6+sAZwAmHgoY
8TYgWBQHAAAAA8ADAP//AAv4AAEAAAQAC///AAs2EQAmD3IAKwAACCMoAgUA)r31(6+sBBABEHACAAgD//wEAGWWEAC8CABMBUgAvADUB
AAAEABP//wAnWnsATBywAH4AAA)r46(6+sBCAAmHgoY8TYgWBQHAAAAA8AEAP//AAv4AAEAAAgABLhGAAj//wADncsACqRpAAfo0wALWEYA
ECe5AM0AAAgjKAIFAA)r2d(6+sA1ACAAQUFAKoAKAUAqgAoAhQAAQAABQAIz3IAE///ABNnuQAzJYQAcwAA)r54(6+sCTwAzHgoY8TYgWBQHAAAA
A8AHAP//ABEcAAEAAAMAC///ABEsIwAcAAAEABKAgIDmBAAZs4CAzAH//wQAMf//ADOo0wF8RYQAbwAACCMoAgUA)r2d(6+sA1ACAAQUF
AMgAKAUAyAAoAhQAAQAABQAIz3IAE///ABNnuQAzJYQAcwAA)r2d(6+sA1ACAAQUFAPoAKAUA/wAoAhQAAQAABQAIz3IAE///ABNnuQAz
JYQAcwAA)r4c(6+sElgCqFgfXAAAYAAAEAxkDAA5QAQLsD6YBAAAEAA///wBIO5YAUx3LAl4AAAQAObOAgMwEACtms4DMAf//AwHORYQB
N0RpAZEAAA)r2d(6+sA1ACAAQUFASwAKAUBNgAoAhQAAQAABQAIz3IAE///ABNnuQAzJYQAcwAA)r39(6+sCuwAoPgcGF8ZAEQQDAcUCmaaeAgDR
unsCTynuBdsABQAAFAEAAAQAC///ADMnuQA2E9wCRwAA)r4b(6+sDpACAFgoYAFIAAIQAfkEPAwADAAAmAAEAAAUABaRpABP//wAgTCMA
NhlhAjsAAAQAKZlmgLMEADWzZoCAAf//AgEj//8CgQAA)r32(6+sBUgA8Fgv2AD4AEQAAAAAAAAOzBAAIoAABAAAFAAngAAAL//8AI1T3
ADUhGgDmAAA)r76(6+sCbQCAHQQCJgQA//8BAG9PcgfjAAEAAAQACf//ACJGngAeEsIAjAAABAAogICAzAH//wIAuf//AX8AAAAWCCAAWgB4
k0MNAuMCAAv4AAEAAAQAB///AB43LAAxEsIA0AAABAA1gGaAswFQjQIA1VcsAZgAAA)r38(6+sBOwBcHwQJBqVwQBEEAwAIASYCAP//AAry
AAEAAAQAC///ACQkaQArDlgA4QAABR9AAfQCCgA)r31(6+sAoQBDFgb7AC4ADQABTwEAA6MCAAoBiAAFBHsBAAAEAAf//wATOnsAGxPcAGwA
AA)r5b(6+sDwwBDPwQM8SEIAgEAAAAAAAAAA9kEAP//AAc3AQBYBa8PAAAyAQAAAgAP//8ANgAABAAbgOaA5gQAFbNmgMwIF3ACCgAB//8E
AEP//wDBRGkBoT7lAR4AAA)r35(6+sBkgBXPgv5AEIAIAAMAAIAAAFMAYD//wAAUQAEAAlgAQAABAAE//8AEVlhACcjTwFWAAA)r38(6+sCJACAHgov
IzFIQiQAAAAAAwACAGjTAgAP//8B99PcCbgAAQAABAAW//8AHy5YADkPcgG2AAA)r32(6+sA5gCAFgf8ABYAAAgDAuYBAAHjAgAHAHcA6ACG
AQAABAAJ//8AEjGnABkNPQCyAAA)r32(6+sA5gCAFgf8ABYAAAgDAuYBAAHjAgAJAFYA5gBzAQAABAAO//8ADyjTABcNPQCyAAA)r3b(6+sBOwCANgf7
d0MoEggEAPUBAALIAgAWAHoBgQBeCAAAMgUAggBkAQAABAAk//8AMjCNAC4RpwC3AAA)r36(6+sBmwCANgf7d0MoEggEAPUBAALIAgAWAHoB
gQBeCAAAMgEAAAQAGf//ADEkaQA3DCMBGgAA)r36(6+sBmwCANgf7d0MoEggEAPUBAALIAgAXAEUBfQAzCAAAMgEAAAQAGf//ADEkaQA3
DCMBGgAA)r2e(6+sAgAAiFgc0l+JiMhcBAWYCAAAuAQCZCW8BAAAEAAn//wAYSNMAHBYRAEMAAA)r2e(6+sAgAAiFgc0l+JiMhcBAWYCAAAgAQCa
A6MBAAAEAAn//wAYSNMAHBYRAEMAAA)r2d(6+sAuwCAFgocM1FdTC4dDwgBAsUBAAy0AAEAAAQAD///ABQz3AAzB7kAZQAA)r2d(6+sAuwCAFgoc
M1FdTC4dDwgBAsUBAAlvAAEAAAQAD///ABQz3AAzB7kAZQAA)r30(6+sA0gCAAQUFG1gBkAEAAAcABv//AAsU9wAKFPcABnYRAA8gAAAZ
DCMAiQAAAgoA)r70(6+sCZABPAQUBAAADABb//wA6TT0A1gAABABjgEyAmQQAb4BMgGYB//8CAUz//wDlAAAAFgUHNmc7BwSAAQAAQwIA
Gi8XAX4bjgEAAAQAEv//AConuQAvCwgBEQAABAA/wECA5gH//wIBUf//ARMAAA)r2d(6+sBWgCAMgb4GQsABAEEewEBiwY3DAAAyAEAAAQA
Kv//AFVOWABBGWEAmgAA)r2d(6+sCgQCAMgb4GQsABAEEewECoQaZCAAAyAEAAAQAWv//AFZAAABbEacBdgAA)r85(6+sBxgBcPgcJNFcjGAAH
AMABAP//AQKmwAAA7AEB0gEKEAAAyAEAABcADf//AAYAAAAaAAAAFf//AAsAAAAeAAAADf//AA4AAAAiAAAAFJGnABgAAAAZAAAA
EEAAABAAAAAeAAAADi9yAAkAAAAmAAAADRywAA4AAAAgAAAAEBLCABMAAA)ra9(6+sClgBcPgcJNFcjGAAHAMABAP//AQKmwAAA7AECvAE+
EAAAyAEAACAADf//AAYAAAAaAAAAFf//AAsAAAAgAAAAEv//AAkAAAAgAAAAFf//AAoAAAAhAAAAEv//AA4AAAAcAAAAF7lhAAcA
AAAeAAAAF4nuAAoAAAAdAAAAGE9yAAsAAAAgAAAAFCjTAA4AAAAhAAAADhp7AAwAAAAfAAAAFBCNACUAAA)r29(6+sAqQBXAQUFBLAAMgUE
sAK8AhQAAQAABAAH//8ADUAAABMblgCCAAA)r4d(6+sA9QCbPwIN3QAvslCBAAA9HggAAAQAAwBhGgEAC///BQwBAAsOvgoAADIBAAAEAA79
ywAdVhEAMB3LAJoAAAUFFAGQBQUUAGQCBwA)r4d(6+sA9QCbPwIN3QAvslCBAAA9HggAAAQAAwBhGgEAC///BQwBAAsOvgoAADIBAAAEAA79
ywAdVhEAMB3LAJoAAAUDIAGQBQMgAGQCBwA)r38(6+sAuwC9HAdUBAD//wEAkgAAAMADAAgBGwASAIIAxgEjAQAABAAR//8AGEjTADISwgBg
AAAIArw)r3c(6+sBRwC9HAdUBADFhAIAVPp7AJIAAADAAwAMANgADgCCATwA7AEAAAQAEf//ABhI0wBcFywAwgAACAK8)r4c(6+sAWwDKHg3sRWcW
AE8ALxMEAAAAA2YCAK5YAgAM57kAQwAAAbgDAAUMtAAHBBkABgkoAQAABAAI//8AD1LCABwkaQAoAAAFE4gDIA)r42(6+sAgACpFg3sRWcW
AE8ALxMEAAAAA2YCAAG4AwAFDLQABwQZAAYJKAEAAAQACP//AA9SwgAiFywARwAACAu4CAnE)r47(6+sA6ADNPgz+bjgQBgAAAAAAAAAA
gAEAIjQCAEf//wDwJp4BrQEBRwEbCAAJYAEAAAQACv//ABs8sAAyEsIAkQAABQUUAyA)</egg-rom>
<script>
/* Webgl.js
 * Adapter that exposes GLES2 to the Wasm client, and implements in a WebGL context.
 */
 
class Webgl {
  constructor(egg, gl) {
    this.egg = egg;
    this.gl = gl;
    this.o = ["neverZero"]; // GL objects (mixed types), indexed by ID. Can be sparse.
    this.nextId = 1;
    this.glstrp = 0; // Storage for glGetString, set by Render.js.
    this.glstra = 0;
    this.locv = ["neverZero"]; // Uniform locations. TODO We never remove them. Will that be a problem?
  }
  
  generatePublicApi() {
    return {
      // Anything with no pointers or object names converts trivially.
      glActiveTexture: (a) => this.gl.activeTexture(a),
      glBlendColor: (a,b,c,d) => this.gl.blendColor(a,b,c,d),
      glBlendEquation: (a) => this.gl.blendEquation(a),
      glBlendEquationSeparate: (a,b) => this.gl.blendEquationSeparate(a,b),
      glBlendFunc: (a,b) => this.gl.blendFunc(a,b),
      glBlendFuncSeparate: (a,b,c,d) => this.gl.blendFuncSeparate(a,b,c,d),
      glCheckFramebufferStatus: (a) => this.gl.checkFramebufferStatus(a),
      glClear: (a) => this.gl.clear(a),
      glClearColor: (a,b,c,d) => this.gl.clearColor(a,b,c,d),
      glClearDepthf: (a) => this.gl.clearDepth(a),
      glClearStencil: (a) => this.gl.clearStencil(a),
      glColorMask: (a,b,c,d) => this.gl.colorMask(a,b,c,d),
      glCullFace: (a) => this.gl.cullFace(a),
      glDepthFunc: (a) => this.gl.depthFunc(a),
      glDepthMask: (a) => this.gl.depthMask(a),
      glDepthRangef: (a,b) => this.gl.depthRangef(a,b),
      glDisable: (a) => this.gl.disable(a),
      glDisableVertexAttribArray: (a) => this.gl.disableVertexAttribArray(a),
      glDrawArrays: (a,b,c) => this.gl.drawArrays(a,b,c),
      glDrawElements: (a,b,c,d) => this.gl.drawElements(a,b,c,d),
      glEnable: (a) => this.gl.enable(a),
      glEnableVertexAttribArray: (a) => this.gl.enableVertexAttribArray(a),
      glFinish: () => this.gl.finish(),
      glFlush: () => this.gl.flush(),
      glFrontFace: (a) => this.gl.frontFace(a),
      glGenerateMipmap: (a) => this.gl.generateMipmap(a),
      glGetError: () => this.gl.getError(),
      glHint: (a,b) => this.gl.hint(a,b),
      glIsEnabled: (a) => this.gl.isEnabled(a),
      glLineWidth: (a) => this.gl.lineWidth(a),
      glPixelStorei: (a,b) => this.gl.pixelStore(a,b),
      glPolygonOffset: (a,b) => this.gl.polygonOffset(a,b),
      glReleaseShaderCompiler: () => this.gl.releaseShaderCompiler(),
      glRenderbufferStorage: (a,b,c,d) => this.gl.renderbufferStorage(a,b,c,d),
      glSampleCoverage: (a,b) => this.gl.sampleCoverage(a,b),
      glScissor: (a,b,c,d) => this.gl.scissor(a,b,c,d),
      glStencilFunc: (a,b,c) => this.gl.stencilFunc(a,b,c),
      glStencilFuncSeparate: (a,b,c,d) => this.gl.stencilFuncSeparate(a,b,c,d),
      glStencilMask: (a) => this.gl.stencilMask(a),
      glStencilMaskSeparate: (a,b) => this.gl.stencilMaskSeparate(a,b),
      glStencilOp: (a,b,c) => this.gl.stencilOp(a,b,c),
      glStencilOpSeparate: (a,b,c,d) => this.gl.stencilOpSeparate(a,b,c,d),
      glTexParameterf: (a,b,c) => this.gl.texParameterf(a,b,c),
      glTexParameteri: (a,b,c) => this.gl.texParameteri(a,b,c),
      glUniform1f: (a,b) => this.gl.uniform1f(this.locv[a],b),
      glUniform1i: (a,b) => this.gl.uniform1i(this.locv[a],b),
      glUniform2f: (a,b,c) => this.gl.uniform2f(this.locv[a],b,c),
      glUniform2i: (a,b,c) => this.gl.uniform2i(this.locv[a],b,c),
      glUniform3f: (a,b,c,d) => this.gl.uniform3f(this.locv[a],b,c,d),
      glUniform3i: (a,b,c,d) => this.gl.uniform3i(this.locv[a],b,c,d),
      glUniform4f: (a,b,c,d,e) => this.gl.uniform4f(this.locv[a],b,c,d,e),
      glUniform4i: (a,b,c,d,e) => this.gl.uniform4i(this.locv[a],b,c,d,e),
      glVertexAttrib1f: (a,b) => this.gl.vertexAttrib1f(a,b),
      glVertexAttrib2f: (a,b,c) => this.gl.vertexAttrib2f(a,b,c),
      glVertexAttrib3f: (a,b,c,d) => this.gl.vertexAttrib3f(a,b,c,d),
      glVertexAttrib4f: (a,b,c,d,e) => this.gl.vertexAttrib4f(a,b,c,d,e),
      glViewport: (a,b,c,d) => this.gl.viewport(a,b,c,d),
      // All the rest are a little more interesting:
      glAttachShader: (a,b) => this.glAttachShader(a,b),
      glBindAttribLocation: (a,b,c) => this.glBindAttribLocation(a,b,c),
      glBindBuffer: (a,b) => this.glBindBuffer(a,b),
      glBindFramebuffer: (a,b) => this.glBindFramebuffer(a,b),
      glBindRenderbuffer: (a,b) => this.glBindRenderbuffer(a,b),
      glBindTexture: (a,b) => this.glBindTexture(a,b),
      glBufferData: (a,b,c,d) => this.glBufferData(a,b,c,d),
      glBufferSubData: (a,b,c,d) => this.glBufferSubData(a,b,c,d),
      glCompileShader: (a) => this.glCompileShader(a),
      glCompressedTexImage2D: (a,b,c,d,e,f,g,h) => this.glCompressedTexImage2D(a,b,c,d,e,f,g,h),
      glCompressedTexSubImage2D: (a,b,c,d,e,f,g,h,i) => this.glCompressedTexSubImage2D(a,b,c,d,e,f,g,h,i),
      glCopyTexImage2D: (a,b,c,d,e,f,g,h) => this.glCopyTexImage2D(a,b,c,d,e,f,g,h),
      glCopyTexSubImage2D: (a,b,c,d,e,f,g,h) => this.glCopyTexSubImage2D(a,b,c,d,e,f,g,h),
      glCreateProgram: () => this.glCreateProgram(),
      glCreateShader: (a) => this.glCreateShader(a),
      glDeleteBuffers: (a,b) => this.glDeleteBuffers(a,b),
      glDeleteFramebuffers: (a,b) => this.glDeleteFramebuffers(a,b),
      glDeleteProgram: (a) => this.glDeleteProgram(a),
      glDeleteRenderbuffers: (a,b) => this.glDeleteRenderbuffers(a,b),
      glDeleteShader: (a) => this.glDeleteShader(a),
      glDeleteTextures: (a,b) => this.glDeleteTextures(a,b),
      glDetachShader: (a,b) => this.glDetachShader(a,b),
      glFramebufferRenderbuffer: (a,b,c,d) => this.glFramebufferRenderbuffer(a,b,c,d),
      glFramebufferTexture2D: (a,b,c,d,e) => this.glFramebufferTexture2D(a,b,c,d,e),
      glGenBuffers: (a,b) => this.glGenBuffers(a,b),
      glGenFramebuffers: (a,b) => this.glGenFramebuffers(a,b),
      glGenRenderbuffers: (a,b) => this.glGenRenderbuffers(a,b),
      glGenTextures: (a,b) => this.glGenTextures(a,b),
      glGetActiveAttrib: (a,b,c,d,e,f,g) => this.glGetActiveAttrib(a,b,c,d,e,f,g),
      glGetActiveUniform: (a,b,c,d,e,f,g) => this.glGetActiveUniform(a,b,c,d,e,f,g),
      glGetAttachedShaders: (a,b,c,d) => this.glGetAttachedShaders(a,b,c,d),
      glGetAttribLocation: (a,b) => this.glGetAttribLocation(a,b),
      glGetBooleanv: (a,b) => this.glGetBooleanv(a,b),
      glGetBufferParameteriv: (a,b,c) => this.glGetBufferParameteriv(a,b,c),
      glGetFloatv: (a,b) => this.glGetFloatv(a,b),
      glGetFramebufferAttachmentParameteriv: (a,b,c,d) => this.glGetFramebufferAttachmentParameteriv(a,b,c,d),
      glGetIntegerv: (a,b) => this.glGetIntegerv(a,b),
      glGetProgramiv: (a,b,c) => this.glGetProgramiv(a,b,c),
      glGetProgramInfoLog: (a,b,c,d) => this.glGetProgramInfoLog(a,b,c,d),
      glGetRenderbufferParameteriv: (a,b,c) => this.glGetRenderbufferParameteriv(a,b,c),
      glGetShaderiv: (a,b,c) => this.glGetShaderiv(a,b,c),
      glGetShaderInfoLog: (a,b,c,d) => this.glGetShaderInfoLog(a,b,c,d),
      glGetShaderPrecisionFormat: (a,b,c,d) => this.glGetShaderPrecisionFormat(a,b,c,d),
      glGetShaderSource: (a,b,c,d) => this.glGetShaderSource(a,b,c,d),
      glGetString: (a) => this.glGetString(a),
      glGetTexParameterfv: (a,b,c) => this.glGetTexParameterfv(a,b,c),
      glGetTexParameteriv: (a,b,c) => this.glGetTexParameteriv(a,b,c),
      glGetUniformfv: (a,b,c) => this.glGetUniformfv(a,b,c),
      glGetUniformiv: (a,b,c) => this.glGetUniformiv(a,b,c),
      glGetUniformLocation: (a,b) => this.glGetUniformLocation(a,b),
      glGetVertexAttribfv: (a,b,c) => this.glGetVertexAttribfv(a,b,c),
      glGetVertexAttribiv: (a,b,c) => this.glGetVertexAttribiv(a,b,c),
      glGetVertexAttribPointerv: (a,b,c) => this.glGetVertexAttribPointerv(a,b,c),
      glIsBuffer: (a) => this.glIsBuffer(a),
      glIsFramebuffer: (a) => this.glIsFramebuffer(a),
      glIsProgram: (a) => this.glIsProgram(a),
      glIsRenderbuffer: (a) => this.glIsRenderbuffer(a),
      glIsShader: (a) => this.glIsShader(a),
      glIsTexture: (a) => this.glIsTexture(a),
      glLinkProgram: (a) => this.glLinkProgram(a),
      glReadPixels: (a,b,c,d,e,f,g) => this.glReadPixels(a,b,c,d,e,f,g),
      glShaderBinary: (a,b,c,d,e) => this.glShaderBinary(a,b,c,d,e),
      glShaderSource: (a,b,c,d) => this.glShaderSource(a,b,c,d),
      glTexImage2D: (a,b,c,d,e,f,g,h,i) => this.glTexImage2D(a,b,c,d,e,f,g,h,i),
      glTexParameterfv: (a,b,c) => this.glTexParameterfv(a,b,c),
      glTexParameteriv: (a,b,c) => this.glTexParameteriv(a,b,c),
      glTexSubImage2D: (a,b,c,d,e,f,g,h,i) => this.glTexSubImage2D(a,b,c,d,e,f,g,h,i),
      glUniform1fv: (a,b,c) => this.glUniform1fv(a,b,c),
      glUniform1iv: (a,b,c) => this.glUniform1iv(a,b,c),
      glUniform2fv: (a,b,c) => this.glUniform2fv(a,b,c),
      glUniform2iv: (a,b,c) => this.glUniform2iv(a,b,c),
      glUniform3fv: (a,b,c) => this.glUniform3fv(a,b,c),
      glUniform3iv: (a,b,c) => this.glUniform3iv(a,b,c),
      glUniform4fv: (a,b,c) => this.glUniform4fv(a,b,c),
      glUniform4iv: (a,b,c) => this.glUniform4iv(a,b,c),
      glUniformMatrix2fv: (a,b,c,d) => this.glUniformMatrix2fv(a,b,c,d),
      glUniformMatrix3fv: (a,b,c,d) => this.glUniformMatrix3fv(a,b,c,d),
      glUniformMatrix4fv: (a,b,c,d) => this.glUniformMatrix4fv(a,b,c,d),
      glUseProgram: (a) => this.glUseProgram(a),
      glValidateProgram: (a) => this.glValidateProgram(a),
      glVertexAttrib1fv: (a,b) => this.glVertexAttrib1fv(a,b),
      glVertexAttrib2fv: (a,b) => this.glVertexAttrib2fv(a,b),
      glVertexAttrib3fv: (a,b) => this.glVertexAttrib3fv(a,b),
      glVertexAttrib4fv: (a,b) => this.glVertexAttrib4fv(a,b),
      glVertexAttribPointer: (a,b,c,d,e,f) => this.glVertexAttribPointer(a,b,c,d,e,f),
    };
  }
  
  /* Create and delete objects.
   **********************************************************/
   
  objAlloc() {
    const p = this.o.indexOf(null);
    if (p >= 0) return p;
    return this.nextId++;
  }
  
  objDel(id) {
    if (id < 1) return;
    this.o[id] = null;
  }

  glCreateProgram() {
    const id = this.objAlloc();
    if (!(this.o[id] = this.gl.createProgram())) return 0;
    return id;
  }

  glCreateShader(a) {
    const id = this.objAlloc();
    if (!(this.o[id] = this.gl.createShader(a))) return 0;
    return id;
  }

  glGenBuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.objAlloc();
      this.o[id] = this.gl.createBuffer();
      this.egg.exec.mem32[p] = id;
    }
  }

  glGenFramebuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.objAlloc();
      this.o[id] = this.gl.createFramebuffer();
      this.egg.exec.mem32[p] = id;
    }
  }

  glGenRenderbuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.objAlloc();
      this.o[id] = this.gl.createRenderbuffer();
      this.egg.exec.mem32[p] = id;
    }
  }

  glGenTextures(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.objAlloc();
      this.o[id] = this.gl.createTexture();
      this.egg.exec.mem32[p] = id;
    }
  }

  glDeleteBuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.egg.exec.mem32[p];
      this.gl.deleteBuffer(this.o[id]);
      this.objDel(id);
    }
  }

  glDeleteFramebuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.egg.exec.mem32[p];
      this.gl.deleteFramebuffer(this.o[id]);
      this.objDel(id);
    }
  }

  glDeleteProgram(a) {
    this.gl.deleteProgram(this.o[a]);
    this.objDel(a);
  }

  glDeleteRenderbuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.egg.exec.mem32[p];
      this.gl.deleteRenderbuffer(this.o[id]);
      this.objDel(id);
    }
  }

  glDeleteShader(a) {
    this.gl.deleteShader(this.o[a]);
    this.objDel(a);
  }

  glDeleteTextures(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.egg.exec.mem32[p];
      this.gl.deleteTexture(this.o[id]);
      this.objDel(id);
    }
  }

  glIsBuffer(a) {
    return this.gl.isBuffer(this.o[a]);
  }

  glIsFramebuffer(a) {
    return this.gl.isFramebuffer(this.o[a]);
  }

  glIsProgram(a) {
    return this.gl.isProgram(this.o[a]);
  }

  glIsRenderbuffer(a) {
    return this.gl.isRenderbuffer(this.o[a]);
  }

  glIsShader(a) {
    return this.gl.isShader(this.o[a]);
  }

  glIsTexture(a) {
    return this.gl.isTexture(this.o[a]);
  }
   
  /* Miscellaneous.
   ***********************************************************/
  
  glAttachShader(pid, sid) {
    this.gl.attachShader(this.o[pid], this.o[sid]);
  }

  glBindAttribLocation(pid, index, namep) {
    const program = this.o[pid];
    const name = this.egg.exec.readCString(namep);
    this.gl.bindAttribLocation(program, index, name);
  }

  glBindBuffer(target, id) {
    const buffer = this.o[id];
    this.gl.bindBuffer(target, buffer);
  }

  glBindFramebuffer(target, id) {
    const fb = this.o[id];
    this.gl.bindFramebuffer(target, fb);
  }

  glBindRenderbuffer(target, id) {
    const rb = this.o[id];
    this.gl.bindRenderbuffer(target, rb);
  }

  glBindTexture(target, id) {
    const texture = this.o[id];
    this.gl.bindTexture(target, texture);
  }

  glBufferData(target, size, datap, usage) {
    if (datap) {
      const data = this.egg.exec.getView(datap, size);
      if (!data) return;
      this.gl.bufferData(target, data, usage);
    } else {
      this.gl.bufferData(target, size, usage);
    }
  }

  glBufferSubData(target, offset, size, datap) {
    const data = this.egg.exec.getView(datap, size);
    if (!data) return;
    this.gl.bufferSubData(target, offset, data);
  }

  glCompileShader(id) {
    const shader = this.o[id];
    this.gl.compileShader(shader);
  }

  glDetachShader(pid, sid) {
    const program = this.o[pid];
    const shader = this.o[sid];
    this.gl.detachShader(program, shader);
  }

  glFramebufferRenderbuffer(target, attachment, rbtarget, rbid) {
    const rb = this.o[rbid];
    this.gl.framebufferRenderbuffer(target, attachment, rbtarget, rb);
  }

  glFramebufferTexture2D(target, attachment, textarget, texid, level) {
    const texture = this.o[texid];
    this.gl.framebufferTexture2D(target, attachment, textarget, texture, level);
  }

  glGetActiveAttrib(pid, index, bufsize, lenp, sizep, typep, namep) {
    const program = this.o[pid];
    const attr = this.gl.getActiveAttrib(program, index);
    if (!attr) return;
    if (sizep) this.egg.exec.mem32[sizep >> 2] = attr.size;
    if (typep) this.egg.exec.mem32[typep >> 2] = attr.type;
    if (namep && (bufsize > 0)) {
      this.egg.exec.safeWrite(namep, bufsize, attr.name);
    }
  }

  glGetActiveUniform(pid, index, bufsize, lenp, sizep, typep, namep) {
    const program = this.o[pid];
    const attr = this.gl.getActiveUniform(program, index);
    if (!attr) return;
    if (sizep) this.egg.exec.mem32[sizep >> 2] = attr.size;
    if (typep) this.egg.exec.mem32[typep >> 2] = attr.type;
    if (namep && (bufsize > 0)) {
      this.egg.exec.safeWrite(namep, bufsize, attr.name);
    }
  }

  glGetAttachedShaders(pid, max, countp, dstp) {
    const program = this.o[pid];
    const shaders = this.gl.getAttachedShaders(program) || [];
    if (countp) this.egg.exec.mem32[countp >> 2] = shaders.length;
    const cpc = Math.min(shaders.length, max);
    for (let i=0; i<cpc; i++, dstp+=4) {
      let id = this.o.indexOf(shaders[i]);
      if (id < 0) id = 0;
      this.egg.exec.mem32[dstp >> 2] = id;
    }
  }

  glGetAttribLocation(pid, namep) {
    const program = this.o[pid];
    const name = this.egg.exec.readCString(namep);
    return this.gl.getAttribLocation(program, name);
  }

  glGetProgramInfoLog(pid, bufsize, lenp, dstp) {
    const program = this.o[pid];
    const src = this.gl.getProgramInfoLog(program) || "";
    this.egg.exec.mem32[lenp >> 2] = this.egg.exec.safeWrite(dstp, bufsize, src);
  }

  glGetShaderInfoLog(sid, bufsize, lenp, dstp) {
    const shader = this.o[sid];
    const src = this.gl.getShaderInfoLog(shader) || "";
    this.egg.exec.mem32[lenp >> 2] = this.egg.exec.safeWrite(dstp, bufsize, src);
  }

  glGetShaderPrecisionFormat(stype, ptype, rangep, precp) {
    const rsp = this.gl.getShaderPrecisionFormat(stype, ptype);
    if (!rsp) return;
    rangep >>= 2;
    this.egg.exec.mem32[rangep++] = rsp.rangeMin;
    this.egg.exec.mem32[rangep] = rsp.rangeMax;
    this.egg.exec.mem32[precp >> 2] = rsp.precision;
  }

  glGetShaderSource(sid, bufsize, lenp, dstp) {
    const shader = this.o[sid];
    const src = this.gl.getShaderSource(shader) || "";
    this.egg.exec.mem32[lenp >> 2] = this.egg.exec.safeWrite(dstp, bufsize, src);
  }

  glGetUniformLocation(pid, namep) {
    const program = this.o[pid];
    const name = this.egg.exec.readCString(namep);
    const loc = this.gl.getUniformLocation(program, name);
    if (!loc) return 0;
    const id = this.locv.length;
    this.locv.push(loc);
    return id;
  }

  glLinkProgram(pid) {
    const program = this.o[pid];
    this.gl.linkProgram(program);
  }

  glShaderBinary(count, dstp, bfmt, src, srcc) {
    // GL_APICALL void GL_APIENTRY glShaderBinary (GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length);
    // Evidently there is no such thing in WebGL.
  }

  glShaderSource(sid, count, stringsp, lensp) {
    const shader = this.o[sid];
    let glsl = "";
    stringsp >>= 2;
    lensp >>= 2;
    for (let i=0; i<count; i++, stringsp++, lensp++) {
      const srcp = this.egg.exec.mem32[stringsp];
      const srcc = this.egg.exec.mem32[lensp];
      const sub = this.egg.exec.readLimitedString(srcp, srcc);
      glsl += sub;
    }
    this.gl.shaderSource(shader, glsl);
  }

  glUseProgram(a) {
    this.gl.useProgram(this.o[a]);
  }

  glValidateProgram(a) {
    this.gl.validateProgram(this.o[a]);
  }
  
  /* Generic parameters.
   ******************************************************************************/
   
  paramAsInts(src) {
    if (!src) return [0];
    if (typeof(src) === "number") return [~~src];
    const p = this.o.indexOf(src);
    if (p > 0) return [p];
    if (src.length) return src.map(v => ~~v);
    return [0];
  }
  
  paramAsFloats(src) {
    if (!src) return [0];
    if (typeof(src) === "number") return [src];
    if (src.length) return src;
    return [0];
  }
  
  paramAsString(src) {
    if (!src) return "";
    if (typeof(src) === "string") return src;
    return "";
  }

  glGetBooleanv(pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getParameter(pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetIntegerv(pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getParameter(pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetFloatv(pname, dstp) {
    const rsp = this.paramAsFloats(this.gl.getParameter(pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.memf32[dstp] = rsp[i];
    }
  }
  
  glGetString(pname) {
    const rsp = this.paramAsString(this.gl.getParameter(pname));
    this.egg.exec.safeWrite(this.glstrp, this.glstra, rsp + "\0");
    return this.glstrp;
  }

  glGetBufferParameteriv(target, pname, dstp) {
    // Every defined field is a single int.
    const rsp = this.gl.getBufferParameter(target, pname);
    this.egg.exec.mem32[dstp >> 2] = rsp;
  }

  glGetFramebufferAttachmentParameteriv(target, attachment, pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getFramebufferAttachmentParameter(target, attachment, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetProgramiv(pid, pname, dstp) {
    // Every defined field is a single int.
    const program = this.o[pid];
    const rsp = this.gl.getProgramParameter(program, pname);
    this.egg.exec.mem32[dstp >> 2] = rsp;
  }

  glGetRenderbufferParameteriv(target, pname, dstp) {
    // Every defined field is a single int.
    const rsp = this.gl.getRenderbufferParameter(target, pname);
    this.egg.exec.mem32[dstp >> 2] = rsp;
  }

  glGetShaderiv(sid, pname, dstp) {
    // Every defined field is a single int.
    const shader = this.o[sid];
    const rsp = this.gl.getShaderParameter(shader, pname);
    this.egg.exec.mem32[dstp >> 2] = rsp;
  }

  glGetTexParameterfv(target, pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getTexParameter(target, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.memf32[dstp] = rsp[i];
    }
  }

  glGetTexParameteriv(target, pname, dstp) {
    const rsp = this.paramAsFloats(this.gl.getTexParameter(target, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetUniformfv(pid, id, dstp) {
    const program = this.o[pid];
    const rsp = this.paramAsFloats(this.gl.getUniform(program, this.locv[id]));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.memf32[dstp] = rsp[i];
    }
  }

  glGetUniformiv(pid, id, dstp) {
    const program = this.o[pid];
    const rsp = this.paramAsInts(this.gl.getUniform(program, this.locv[id]));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetVertexAttribfv(index, pname, dstp) {
    const rsp = this.paramAsFloats(this.gl.getVertexAttrib(index, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.memf32[dstp] = rsp[i];
    }
  }

  glGetVertexAttribiv(index, pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getVertexAttrib(index, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetVertexAttribPointerv(index, pname, dstp) {
    const offset = this.gl.getVertexAttribOffset(index, pname);
    this.egg.exec.mem32[dstp >> 2] = offset;
  }

  glTexParameterfv(target, pname, srcp) {
    // No defined texture field uses a vector.
    this.gl.texParameterf(target, pname, this.egg.exec.memf32[srcp >> 2]);
  }

  glTexParameteriv(target, pname, srcp) {
    // No defined texture field uses a vector.
    this.gl.texParameteri(target, pname, this.egg.exec.mem32[srcp >> 2]);
  }

  glUniform1fv(id, c, p) {
    this.gl.uniform1fv(this.locv[id], this.egg.exec.memf32.slice(p >> 2, c));
  }

  glUniform1iv(id, c, p) {
    this.gl.uniform1iv(this.locv[id], this.egg.exec.mem32.slice(p >> 2, c));
  }

  glUniform2fv(id, c, p) {
    this.gl.uniform2fv(this.locv[id], this.egg.exec.memf32.slice(p >> 2, c * 2)); 
  }

  glUniform2iv(id, c, p) {
    this.gl.uniform2iv(this.locv[id], this.egg.exec.mem32.slice(p >> 2, c * 2));
  }

  glUniform3fv(id, c, p) {
    this.gl.uniform3fv(this.locv[id], this.egg.exec.memf32.slice(p >> 2, c * 3)); 
  }

  glUniform3iv(id, c, p) {
    this.gl.uniform3iv(this.locv[id], this.egg.exec.mem32.slice(p >> 2, c * 3));
  }

  glUniform4fv(id, c, p) {
    this.gl.uniform4fv(this.locv[id], this.egg.exec.memf32.slice(p >> 2, c * 4)); 
  }

  glUniform4iv(id, c, p) {
    this.gl.uniform4iv(this.locv[id], this.egg.exec.mem32.slice(p >> 2, c * 4));
  }

  glUniformMatrix2fv(id, c, trans, p) {
    this.gl.uniformMatrix2fv(this.locv[id], trans, this.egg.exec.memf32.slice(p >> 2, c * 4));
  }

  glUniformMatrix3fv(id, c, trans, p) {
    this.gl.uniformMatrix3fv(this.locv[id], trans, this.egg.exec.memf32.slice(p >> 2, c * 9));
  }

  glUniformMatrix4fv(id, c, trans, p) {
    this.gl.uniformMatrix4fv(this.locv[id], trans, this.egg.exec.memf32.slice(p >> 2, c * 16));
  }

  glVertexAttrib1fv(index, p) {
    this.gl.vertexAttrib1fv(index, this.egg.exec.memf32.slice(p >> 2, 1));
  }

  glVertexAttrib2fv(index, p) {
    this.gl.vertexAttrib2fv(index, this.egg.exec.memf32.slice(p >> 2, 2));
  }

  glVertexAttrib3fv(index, p) {
    this.gl.vertexAttrib3fv(index, this.egg.exec.memf32.slice(p >> 2, 3));
  }

  glVertexAttrib4fv(index, p) {
    this.gl.vertexAttrib4fv(index, this.egg.exec.memf32.slice(p >> 2, 4));
  }

  glVertexAttribPointer(index, size, type, norm, stride, p) {
    //TODO WebGL (p) is an offset in the bound vbo. GLES2 it can be an absolute pointer in client memory.
    this.gl.vertexAttribPointer(index, size, type, norm, stride, p);
  }
  
  /* Image operations.
   ****************************************************************************/
   
  measureImage(w, h, fmt, type) {
    if ((w < 1) || (w > 4096)) return 0;
    if ((h < 1) || (h > 4096)) return 0;
    let chanc = 0;
    switch (fmt) {
      case this.gl.STENCIL_INDEX8:
      case this.gl.DEPTH_COMPONENT:
      case this.gl.LUMINANCE:
      case this.gl.ALPHA: chanc=1; break;
      case this.gl.LUMINANCE_ALPHA: chanc=2; break;
      case this.gl.RGB: chanc=3; break;
      case this.gl.RGBA: chanc=4; break;
    }
    if (chanc < 1) return 0;
    let wordlen = 0;
    switch (type) {
      case this.gl.UNSIGNED_BYTE:
      case this.gl.BYTE:
        wordlen=1;
        break;
      case this.gl.UNSIGNED_SHORT:
      case this.gl.SHORT:
      case this.gl.UNSIGNED_SHORT_5_6_5:
      case this.gl.UNSIGNED_SHORT_4_4_4_4:
      case this.gl.UNSIGNED_SHORT_5_5_5_1:
        wordlen=2;
        break;
      case this.gl.UNSIGNED_INT:
      case this.gl.INT:
      case this.gl.FLOAT:
        wordlen=4;
        break;
    }
    if (wordlen < 1) return 0;
    return wordlen * chanc * w * h;
  }

  glCompressedTexImage2D(target, level, ifmt, w, h, border, size, srcp) {
    const src = this.egg.exec.getView(srcp, size);
    if (!src) return;
    this.gl.compressedTexImage2D(target, level, ifmt, w, h, border, src);
  }

  glCompressedTexSubImage2D(target, level, xo, yo, w, h, fmt, size, srcp) {
    const src = this.egg.exec.getView(srcp, size);
    if (!src) return;
    this.gl.compressedTexImage2D(target, level, xo, yo, w, h, fmt, src);
  }

  glCopyTexImage2D(target, level, ifmt, x, y, w, h, border) {
    this.gl.copyTexImage2D(target, level, ifmt, x, y, w, h, border);
  }

  glCopyTexSubImage2D(target, level, xo, yo, x, y, w, h) {
    this.gl.copyTexSubImage2D(target, level, xo, yo, x, y, w, h);
  }

  glReadPixels(x, y, w, h, fmt, type, dstp) {
    const len = this.measureImage(w, h, fmt, type);
    if (len < 1) return;
    const dst = this.egg.exec.getView(dstp, len);
    if (!dst) return;
    this.gl.readPixels(x, y, w, h, fmt, type, dst);
  }

  glTexImage2D(target, level, ifmt, w, h, border, fmt, type, srcp) {
    const len = this.measureImage(w, h, fmt, type);
    if (len < 1) return;
    const src = this.egg.exec.getView(srcp, len);
    if (!src) return;
    this.gl.texImage2D(target, level, ifmt, w, h, border, fmt, type, src);
  }

  glTexSubImage2D(target, level, xo, yo, w, h, fmt, type, srcp) {
    const len = this.measureImage(w, h, fmt, type);
    if (len < 1) return;
    const src = this.egg.exec.getView(srcp, len);
    if (!src) return;
    this.gl.texSubImage2D(target, level, xo, yo, w, h, fmt, type, src);
  }

}
class Rom {
  constructor(src) {
    this.resv = []; // {tid,qual,rid,v:Uint8Array}, sorted
    this.decode(src);
  }
  
  getRes(tid, qual, rid) {
    let lo=0, hi=this.resv.length;
    while (lo < hi) {
      const ck = (lo + hi) >> 1;
      const q = this.resv[ck];
           if (tid < q.tid) hi = ck;
      else if (tid > q.tid) lo = ck + 1;
      else if (qual < q.qual) hi = ck;
      else if (qual > q.qual) lo = ck + 1;
      else if (rid < q.rid) hi = ck;
      else if (rid > q.rid) lo = ck + 1;
      else return q.v;
    }
    return this.empty;
  }
  
  decode(src) {
    let tid=1, qual=0, rid=1, i=0;
    const rdch = () => {
      let ch;
      for (;;) {
        ch = src.charCodeAt(i++);
        if (ch > 0x20) return ch;
        if (i >= src.length) return 0;
      }
    };
    const rdn = () => {
      let n=0;
      while (i < src.length) {
        const ch = rdch();
        if (!ch) break;
        if ((ch >= 0x30) && (ch <= 0x39)) { n <<= 4; n |= ch - 0x30; continue; }
        if ((ch >= 0x61) && (ch <= 0x66)) { n <<= 4; n |= ch - 0x61 + 10; continue; }
        if ((ch >= 0x41) && (ch <= 0x46)) { n <<= 4; n |= ch - 0x41 + 10; continue; }
        i--;
        break;
      }
      return n;
    };
    while (i < src.length) {
      const cmd = rdch();
      if (!cmd) break;
      switch (cmd) {
        case 0x74: tid += rdn() + 1; qual = 0; rid = 1; break;
        case 0x71: qual += rdn() + 1; rid = 1; break;
        case 0x73: rid += rdn() + 1; break;
        case 0x72: {
            if ((tid > 0x63) || (qual > 0x3ff) || (rid > 0xffff)) {
              throw new Error(`Invalid res id ${tid}:${qual}:${rid} around ${i}/${src.length} in ROM`);
            }
            const len = rdn();
            const body = new Uint8Array(len);
            let bodyp = 0;
            if (rdch() !== 0x28) throw new Error(`Expected '(' around ${i}/${src.length} in ROM`);
            const buf = [];
            for (;;) {
              const ch = rdch();
              if (ch === 0x29) break;
              if (!ch) throw new Error(`Unclosed resource body`);
                   if ((ch >= 0x41) && (ch <= 0x5a)) buf.push(ch - 0x41);
              else if ((ch >= 0x61) && (ch <= 0x7a)) buf.push(ch - 0x61 + 26);
              else if ((ch >= 0x30) && (ch <= 0x39)) buf.push(ch - 0x30 + 52);
              else if (ch === 0x2b) buf.push(62);
              else if (ch === 0x2f) buf.push(63);
              else throw new Error(`Expected ')' or base64 digit, found ${ch} (${i}/${src.length})`);
              if (buf.length >= 4) {
                body[bodyp++] = (buf[0] << 2) | (buf[1] >> 4);
                body[bodyp++] = (buf[1] << 4) | (buf[2] >> 2);
                body[bodyp++] = (buf[2] << 6) | buf[3];
                buf.splice(0, 4);
              }
            }
            body[bodyp++] = (buf[0] << 2) | (buf[1] >> 4);
            body[bodyp++] = (buf[1] << 4) | (buf[2] >> 2);
            body[bodyp++] = (buf[2] << 6) | buf[3];
            this.resv.push({ tid, qual, rid, v: body });
            rid++;
          } break;
        default: throw new Error(`Unexpected command '${cmd}' around ${i-1}/${src.length} in ROM`);
      }
    }
  }
}

Rom.RESTYPE_metadata = 1;
Rom.RESTYPE_wasm = 2;
Rom.RESTYPE_string = 3;
Rom.RESTYPE_image = 4;
Rom.RESTYPE_song = 5;
Rom.RESTYPE_sound = 6;
/* SfgPrinter.js
 * Produce PCM dumps from our tiny binary sound format.
 *
 * Unlike our C counterpart, we run completely synchronously.
 * That's because in WebAudio you don't get intimate access to the signal generator,
 * what we use to time and pay out printing in C.
 * Printing is not trivial. There's a real possibility of missing video frames due to sound effects being printed.
 *
 * It's written as a class to keep things flexible.
 * But typical usage is a one-shot kind of deal:
 *   const myPcm = new SfgPrinter(serial).print();
 * Uint8Array in, Float32Array out.
 */
 
class SfgPrinter {
  constructor(src, rate) {
    if (!(src instanceof Uint8Array)) throw new Error(`Expected Uint8Array`);
    if (!rate || (rate < 200) || (rate > 200000)) throw new Error(`Invalid rate for SfgPrinter`);
    this.src = src;
    this.rate = rate;
    this.dst = null; // Float32Array
  }
  
  print() {
    if (!this.dst) this._print();
    return this.dst;
  }
  
  /* Private below this point.
   */
  
  _print() {
    if (this.src.length < 6) throw new Error(`Invalid SFG`);
    if ((this.src[0] !== 0xeb) || (this.src[1] !== 0xeb)) throw new Error("Invalid SFG");
    const durms = (this.src[2] << 8) | this.src[3];
    const durframes = Math.max(1, Math.round(durms * this.rate / 1000));
    const master = this.src[4] + this.src[5] / 256.0;
    this.dst = new Float32Array(durframes);
    const tmp = new Float32Array(durframes);
    // Add one voice at a time to (this.dst).
    // Unlike the C implementation, we're synchronous, so we kind of process everything as we read it.
    for (let srcp=6; srcp<this.src.length; ) {
      const np = this._printVoice(tmp, srcp);
      if (!np || (np <= srcp)) throw new Error(`PCM print stalled at ${srcp}/${this.src.length}`);
      srcp = np;
      for (let i=durframes; i-->0; ) this.dst[i] += tmp[i];
    }
    // Apply master level.
    for (let i=durframes; i-->0; ) this.dst[i] *= master;
  }
  
  // Overwrite (dst), and return new (srcp).
  _printVoice(dst, srcp) {
    const waveSizeBits = 10;
    const waveSizeSamples = 1 << waveSizeBits;

    const features = this.src[srcp++];
    
    let wave = null; // Float32Array(waveSizeSamples) | "noise" | "silence"
    if (features & 0x01) { // shape
      switch (this.src[srcp++]) {
        case 0: wave = this._printSine(waveSizeSamples); break;
        case 1: wave = this._printSquare(waveSizeSamples); break;
        case 2: wave = this._printSawup(waveSizeSamples); break;
        case 3: wave = this._printSawdown(waveSizeSamples); break;
        case 4: wave = this._printTriangle(waveSizeSamples); break;
        case 5: wave = "noise"; break;
        case 6: wave = "silence"; break;
        default: throw new Error(`Unknown wave shape ${this.src[srcp-1]}`);
      }
    } else {
      wave = this._printSine(waveSizeSamples);
    }
    
    if (features & 0x02) { // harmonics
      const coefc = this.src[srcp++];
      if (wave instanceof Float32Array) {
        const nwave = new Float32Array(waveSizeSamples);
        for (let step=1; step<=coefc; step++) {
          this._printHarmonic(nwave, wave, step, this.src[srcp++] / 255.0);
        }
        wave = nwave;
      } else {
        // harmonics is meaningless for noise or silence, but it is technically legal. skip it.
        srcp += coefc;
      }
    }
    
    let fmrate = 0;
    let fmscale = 0;
    if (features & 0x04) { // fm
      fmrate = this.src[srcp] + this.src[srcp+1] / 256.0; srcp += 2;
      fmscale = this.src[srcp] + this.src[srcp+1] / 256.0; srcp += 2;
      fmrate *= Math.PI * 2;
    }
    
    const fmrange = {};
    if (features & 0x08) { // fmenv
      srcp = this._decodeEnv(fmrange, srcp, fmscale / 65535.0);
    } else {
      this._constantEnv(fmrange, fmscale);
    }
    
    const rate = {};
    if (features & 0x10) { // rate
      srcp = this._decodeEnv(rate, srcp, 1 / this.rate);
    } else {
      this._constantEnv(rate, 440 / this.rate);
    }
    
    let ratelforate = 0;
    let ratelfodepth = 0;
    if (features & 0x20) { // ratelfo
      const rate = this.src[srcp] + this.src[srcp+1] / 256.0; srcp += 2; // hz
      const depth = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2; // cents
      ratelforate = (rate * Math.PI * 2) / this.rate; // radians/frame
      ratelfodepth = depth / 1200; // power of 2
    }
    
    if (features & 0xc0) throw new Error(`Unknown features (0x${(features & 0xc0).toString(16)}) in voice`);
    
    /* We now have everything we need for the oscillator.
     * Run it to completion, overwriting (dst).
     */
    if (wave === "silence") {
      for (let i=dst.length; i-->0; ) dst[i] = 0;
    } else if (wave === "noise") {
      for (let i=dst.length; i-->0; ) dst[i] = Math.random() * 2 - 1;
    } else { //TODO Opportunities here to run simpler oscillators, eg if rate LFO or FM not in play. See sfg_update.c
      this._oscillateFull(
        dst, wave, rate, ratelforate, ratelfodepth, fmrate, fmrange
      );
    }
    
    /* Process all positional operations individually.
     */
    while (srcp < this.src.length) {
      const opcode = this.src[srcp++];
      if (!opcode) break; // End Of Voice
      switch (opcode) {
        case 0x01: srcp = this._printOpLevel(dst, srcp); break;
        case 0x02: srcp = this._printOpGain(dst, srcp); break;
        case 0x03: srcp = this._printOpClip(dst, srcp); break;
        case 0x04: srcp = this._printOpDelay(dst, srcp); break;
        case 0x05: srcp = this._printOpBandpass(dst, srcp); break;
        case 0x06: srcp = this._printOpNotch(dst, srcp); break;
        case 0x07: srcp = this._printOpLopass(dst, srcp); break;
        case 0x08: srcp = this._printOpHipass(dst, srcp); break;
        default: throw new Error(`Unknown voice op ${opcode}`);
      }
    }
  
    return srcp;
  }
  
  /* Oscillator.
   */
   
  _oscillateFull(dst, wave, rate, ratelforate, ratelfodepth, fmrate, fmrange) {
    for (let i=0, ratelfop=0, modp=0, carp=0; i<dst.length; i++) {
  
      // Acquire carrier rate.
      let crate = this._updateEnv(rate);
      crate *= Math.pow(2, Math.sin(ratelfop) * ratelfodepth);
      ratelfop += ratelforate;
      if (ratelfop >= Math.PI) ratelfop -= Math.PI * 2;
    
      // Acquire modulation.
      let mod = Math.sin(modp);
      mod *= this._updateEnv(fmrange);
      modp += crate * fmrate;
      if (modp >= Math.PI) modp -= Math.PI * 2;
    
      // Acquire sample and advance carrier.
      const sp = Math.floor(carp * wave.length);
      dst[i] = wave[sp] || 0;
      crate += crate * mod;
      carp += crate;
      while (carp >= 1) carp -= 1;
      while (carp < 0) carp += 1;
    }
  }
  
  /* Positional ops.
   * These all read from (this.src) and return the new position.
   */
  
  _printOpLevel(dst, srcp) {
    const env = {};
    srcp = this._decodeEnv(env, srcp, 1 / 65535.0);
    let lo=dst[0], hi=dst[0];
    for (let i=dst.length; i-->0; ) {
      if (dst[i]<lo) lo=dst[i];
      else if (dst[i]>hi) hi=dst[i];
    }
    for (let i=0; i<dst.length; i++) {
      dst[i] *= this._updateEnv(env);
    }
    return srcp;
  }
  
  _printOpGain(dst, srcp) {
    const gain = this.src[srcp] + this.src[srcp+1] / 256.0; srcp += 2;
    for (let i=dst.length; i-->0; ) {
      dst[i] *= gain;
    }
    return srcp;
  }
  
  _printOpClip(dst, srcp) {
    const hi = this.src[srcp++] / 255.0;
    const lo = -hi;
    for (let i=dst.length; i-->0; ) {
      const v = dst[i];
      if (v > hi) dst[i] = hi;
      else if (v < lo) dst[i] = lo;
    }
    return srcp;
  }
  
  _printOpDelay(dst, srcp) {
    const ms = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2;
    const period = Math.ceil((ms * this.rate) / 1000);
    if (isNaN(period) || (period < 1)) return srcp + 4;
    const buf = new Float32Array(period);
    let bufp = 0;
    const dry = this.src[srcp++] / 255.0;
    const wet = this.src[srcp++] / 255.0;
    const sto = this.src[srcp++] / 255.0;
    const fbk = this.src[srcp++] / 255.0;
    for (let i=0; i<dst.length; i++) {
      const next = dst[i];
      const prev = buf[bufp];
      dst[i] = next * dry + prev * wet;
      buf[bufp] = next * sto + prev * fbk;
      if (++bufp >= period) bufp = 0;
    }
    return srcp;
  }
  
  _printOpBandpass(dst, srcp) {
    const mid = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const wid = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const r = 1 - 3 * wid;
    const cosfreq = Math.cos(Math.PI * 2 * mid);
    const k = (1 - 2 * r * cosfreq + r * r) / (2 - 2 * cosfreq);
    const coefv = [
      1 - k,
      2 * (k - r) * cosfreq,
      r * r - k,
      2 * r * cosfreq,
      -r * r,
    ];
    this._applyIir(dst, coefv);
    return srcp;
  }
  
  _printOpNotch(dst, srcp) {
    const mid = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const wid = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const r = 1 - 3 * wid;
    const cosfreq = Math.cos(Math.PI * 2 * mid);
    const k = (1 - 2 * r * cosfreq + r * r) / (2 - 2 * cosfreq);
    const coefv = [
      k,
      -2 * k * cosfreq,
      k,
      2 * r * cosfreq,
      -r * r,
    ];
    this._applyIir(dst, coefv);
    return srcp;
  }
  
  _printOpLopass(dst, srcp) {
    const freq = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const rp = -Math.cos(Math.PI / 2);
    const ip = Math.sin(Math.PI / 2);
    const t = 2 * Math.tan(0.5);
    const w = 2 * Math.PI * freq;
    const m = rp * rp + ip * ip;
    const d = 4 - 4 * rp * t + m * t * t;
    const x0 = (t * t) / d;
    const x1 = (2 * t * t) / d;
    const x2 = (t * t) / d;
    const y1 = (8 - 2 * m * t * t) / d;
    const y2 = (-4 - 4 * rp * t - m * t * t) / d;
    const k = Math.sin(0.5 - w / 2) / Math.sin(0.5 + w / 2);
    const coefv = [
      (x0 - x1 * k + x2 * k * k) / d,
      (-2 * x0 * k + x1 + x1 * k * k - 2 * x2 * k) / d,
      (x0 * k * k - x1 * k + x2) / d,
      (2 * k + y1 + y1 * k * k - 2 * y2 * k) / d,
      (-k * k - y1 * k + y2) / d,
    ];
    this._applyIir(dst, coefv);
    return srcp;
  }
  
  _printOpHipass(dst, srcp) {
    const freq = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const rp = -Math.cos(Math.PI / 2);
    const ip = Math.sin(Math.PI / 2);
    const t = 2 * Math.tan(0.5);
    const w = 2 * Math.PI * freq;
    const m = rp * rp + ip * ip;
    const d = 4 - 4 * rp * t + m * t * t;
    const x0 = (t * t) / d;
    const x1 = (2 * t * t) / d;
    const x2 = (t * t) / d;
    const y1 = (8 - 2 * m * t * t) / d;
    const y2 = (-4 - 4 * rp * t - m * t * t) / d;
    const k = -Math.cos(w / 2 + 0.5) / Math.cos(w / 2 - 0.5);
    const coefv = [
      -(x0 - x1 * k + x2 * k * k) / d,
      (-2 * x0 * k + x1 + x1 * k * k - 2 * x2 * k) / d,
      (x0 * k * k - x1 * k + x2) / d,
      -(2 * k + y1 + y1 * k * k - 2 * y2 * k) / d,
      (-k * k - y1 * k + y2) / d,
    ];
    this._applyIir(dst, coefv);
    return srcp;
  }
  
  _applyIir(dst, coefv) {
    const statev = [0, 0, 0, 0, 0];
    for (let i=0; i<dst.length; i++) {
      statev[2]=statev[1];
      statev[1]=statev[0];
      statev[0]=dst[i];
      dst[i]=(
        statev[0]*coefv[0]+
        statev[1]*coefv[1]+
        statev[2]*coefv[2]+
        statev[3]*coefv[3]+
        statev[4]*coefv[4]
      );
      statev[4]=statev[3];
      statev[3]=dst[i];
    }
  }
  
  /* Envelopes.
   * Decode into a blank object.
   * Values are in 0..65535 if you don't scale. (eg 1/65535 to normalize)
   */
   
  _decodeEnv(env, srcp, scale) {
    env.v0 = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2;
    env.v0 *= scale;
    const pointc = this.src[srcp++];
    if (isNaN(pointc) || (srcp > this.src.length - pointc * 4)) throw new Error(`Envelope overruns EOF`);
    env.pointv = [];
    for (let i=pointc; i-->0; ) {
      const ms = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2;
      const t = Math.max(1, Math.round(ms * this.rate / 1000));
      let v = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2;
      v *= scale;
      env.pointv.push({ t, v });
    }
    env.pointp = 0;
    env.v = env.v0;
    if (pointc > 0) {
      env.ttl = env.pointv[0].t;
      env.dv = (env.pointv[0].v - env.v) / env.ttl;
    } else {
      env.ttl = 0x7fffffff;
      env.dv = 0;
    }
    return srcp;
  }
  
  _constantEnv(env, k) {
    env.v0 = k;
    env.v = k;
    env.ttl = 0x7fffffff;
    env.dv = 0;
    env.pointv = [];
    env.pointp = 0;
  }
  
  _updateEnv(env) {
    if (env.ttl-- > 0) {
      env.v += env.dv;
    } else {
      env.pointp++;
      if (env.pointp >= env.pointv.length) {
        env.pointp = env.pointv.length;
        env.dv = 0;
        env.ttl = 0x7fffffff;
        if (env.pointv.length) env.v = env.pointv[env.pointv.length-1].v;
        else env.v = env.v0;
      } else {
        env.v = env.pointv[env.pointp-1].v;
        env.ttl = env.pointv[env.pointp].t;
        env.dv = (env.pointv[env.pointp].v - env.v) / env.ttl;
      }
    }
    return env.v;
  }
  
  /* Wave generators.
   */
          
  _printSine(len) {
    const dst = new Float32Array(len);
    for (let i=0, p=0, dp=Math.PI*2/len; i<dst.length; i++, p+=dp) {
      dst[i] = Math.sin(p);
    }
    return dst;
  }
  
  _printSquare(len) {
    const dst = new Float32Array(len);
    const halflen = len >> 1;
    for (let i=halflen; i-->0; ) dst[i] = 1;
    for (let i=halflen; i<dst.length; i++) dst[i] = -1;
    return dst;
  }
  
  _printSawup(len) {
    const dst = new Float32Array(len);
    for (let i=0, p=-1, dp=2/len; i<dst.length; i++, p+=dp) {
      dst[i] = p;
    }
    return dst;
  }
  
  _printSawdown(len) {
    const dst = new Float32Array(len);
    for (let i=0, p=1, dp=-2/len; i<dst.length; i++, p+=dp) {
      dst[i] = p;
    }
    return dst;
  }
  
  _printTriangle(len) {
    const dst = new Float32Array(len);
    const halflen = len >> 1;
    for (let i=0, p=-1, dp=2/halflen; i<halflen; i++, p+=dp) {
      dst[i] = p;
    }
    for (let i=halflen, p=1, dp=-2/halflen; i<dst.length; i++, p+=dp) {
      dst[i] = p;
    }
    return dst;
  }
  
  _printHarmonic(dst, src, step, level) {
    if (level <= 0) return;
    for (let dstp=0, srcp=0; dstp<dst.length; dstp++, srcp+=step) {
      if (srcp >= src.length) srcp -= src.length;
      dst[dstp] += src[srcp] * level;
    }
  }
}
/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
// https://github.com/imaya/zlib.js
(function() {'use strict';var l=void 0,aa=window;function r(c,d){var a=c.split("."),b=aa;!(a[0]in b)&&b.execScript&&b.execScript("var "+a[0]);for(var e;a.length&&(e=a.shift());)!a.length&&d!==l?b[e]=d:b=b[e]?b[e]:b[e]={}};var t="undefined"!==typeof Uint8Array&&"undefined"!==typeof Uint16Array&&"undefined"!==typeof Uint32Array&&"undefined"!==typeof DataView;function v(c){var d=c.length,a=0,b=Number.POSITIVE_INFINITY,e,f,g,h,k,m,n,p,s,x;for(p=0;p<d;++p)c[p]>a&&(a=c[p]),c[p]<b&&(b=c[p]);e=1<<a;
f=new (t?Uint32Array:Array)(e);g=1;h=0;for(k=2;g<=a;){for(p=0;p<d;++p)if(c[p]===g){m=0;n=h;for(s=0;s<g;++s)m=m<<1|n&1,n>>=1;x=g<<16|p;for(s=m;s<e;s+=k)f[s]=x;++h}++g;h<<=1;k<<=1}return[f,a,b]};function w(c,d){this.g=[];this.h=32768;this.d=this.f=this.a=this.l=0;this.input=t?new Uint8Array(c):c;this.m=!1;this.i=y;this.r=!1;if(d||!(d={}))d.index&&(this.a=d.index),d.bufferSize&&(this.h=d.bufferSize),d.bufferType&&(this.i=d.bufferType),d.resize&&(this.r=d.resize);switch(this.i){case A:this.b=32768;
this.c=new (t?Uint8Array:Array)(32768+this.h+258);break;case y:this.b=0;this.c=new (t?Uint8Array:Array)(this.h);this.e=this.z;this.n=this.v;this.j=this.w;break;default:throw Error("invalid inflate mode");
}}var A=0,y=1,B={t:A,s:y};
w.prototype.k=function(){for(;!this.m;){var c=C(this,3);c&1&&(this.m=!0);c>>>=1;switch(c){case 0:var d=this.input,a=this.a,b=this.c,e=this.b,f=d.length,g=l,h=l,k=b.length,m=l;this.d=this.f=0;if(a+1>=f)throw Error("invalid uncompressed block header: LEN");g=d[a++]|d[a++]<<8;if(a+1>=f)throw Error("invalid uncompressed block header: NLEN");h=d[a++]|d[a++]<<8;if(g===~h)throw Error("invalid uncompressed block header: length verify");if(a+g>d.length)throw Error("input buffer is broken");switch(this.i){case A:for(;e+
g>b.length;){m=k-e;g-=m;if(t)b.set(d.subarray(a,a+m),e),e+=m,a+=m;else for(;m--;)b[e++]=d[a++];this.b=e;b=this.e();e=this.b}break;case y:for(;e+g>b.length;)b=this.e({p:2});break;default:throw Error("invalid inflate mode");}if(t)b.set(d.subarray(a,a+g),e),e+=g,a+=g;else for(;g--;)b[e++]=d[a++];this.a=a;this.b=e;this.c=b;break;case 1:this.j(ba,ca);break;case 2:for(var n=C(this,5)+257,p=C(this,5)+1,s=C(this,4)+4,x=new (t?Uint8Array:Array)(D.length),S=l,T=l,U=l,u=l,M=l,F=l,z=l,q=l,V=l,q=0;q<s;++q)x[D[q]]=
C(this,3);if(!t){q=s;for(s=x.length;q<s;++q)x[D[q]]=0}S=v(x);u=new (t?Uint8Array:Array)(n+p);q=0;for(V=n+p;q<V;)switch(M=E(this,S),M){case 16:for(z=3+C(this,2);z--;)u[q++]=F;break;case 17:for(z=3+C(this,3);z--;)u[q++]=0;F=0;break;case 18:for(z=11+C(this,7);z--;)u[q++]=0;F=0;break;default:F=u[q++]=M}T=t?v(u.subarray(0,n)):v(u.slice(0,n));U=t?v(u.subarray(n)):v(u.slice(n));this.j(T,U);break;default:throw Error("unknown BTYPE: "+c);}}return this.n()};
var G=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],D=t?new Uint16Array(G):G,H=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],I=t?new Uint16Array(H):H,J=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],K=t?new Uint8Array(J):J,L=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],da=t?new Uint16Array(L):L,ea=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,
13,13],N=t?new Uint8Array(ea):ea,O=new (t?Uint8Array:Array)(288),P,fa;P=0;for(fa=O.length;P<fa;++P)O[P]=143>=P?8:255>=P?9:279>=P?7:8;var ba=v(O),Q=new (t?Uint8Array:Array)(30),R,ga;R=0;for(ga=Q.length;R<ga;++R)Q[R]=5;var ca=v(Q);function C(c,d){for(var a=c.f,b=c.d,e=c.input,f=c.a,g=e.length,h;b<d;){if(f>=g)throw Error("input buffer is broken");a|=e[f++]<<b;b+=8}h=a&(1<<d)-1;c.f=a>>>d;c.d=b-d;c.a=f;return h}
function E(c,d){for(var a=c.f,b=c.d,e=c.input,f=c.a,g=e.length,h=d[0],k=d[1],m,n;b<k&&!(f>=g);)a|=e[f++]<<b,b+=8;m=h[a&(1<<k)-1];n=m>>>16;if(n>b)throw Error("invalid code length: "+n);c.f=a>>n;c.d=b-n;c.a=f;return m&65535}
w.prototype.j=function(c,d){var a=this.c,b=this.b;this.o=c;for(var e=a.length-258,f,g,h,k;256!==(f=E(this,c));)if(256>f)b>=e&&(this.b=b,a=this.e(),b=this.b),a[b++]=f;else{g=f-257;k=I[g];0<K[g]&&(k+=C(this,K[g]));f=E(this,d);h=da[f];0<N[f]&&(h+=C(this,N[f]));b>=e&&(this.b=b,a=this.e(),b=this.b);for(;k--;)a[b]=a[b++-h]}for(;8<=this.d;)this.d-=8,this.a--;this.b=b};
w.prototype.w=function(c,d){var a=this.c,b=this.b;this.o=c;for(var e=a.length,f,g,h,k;256!==(f=E(this,c));)if(256>f)b>=e&&(a=this.e(),e=a.length),a[b++]=f;else{g=f-257;k=I[g];0<K[g]&&(k+=C(this,K[g]));f=E(this,d);h=da[f];0<N[f]&&(h+=C(this,N[f]));b+k>e&&(a=this.e(),e=a.length);for(;k--;)a[b]=a[b++-h]}for(;8<=this.d;)this.d-=8,this.a--;this.b=b};
w.prototype.e=function(){var c=new (t?Uint8Array:Array)(this.b-32768),d=this.b-32768,a,b,e=this.c;if(t)c.set(e.subarray(32768,c.length));else{a=0;for(b=c.length;a<b;++a)c[a]=e[a+32768]}this.g.push(c);this.l+=c.length;if(t)e.set(e.subarray(d,d+32768));else for(a=0;32768>a;++a)e[a]=e[d+a];this.b=32768;return e};
w.prototype.z=function(c){var d,a=this.input.length/this.a+1|0,b,e,f,g=this.input,h=this.c;c&&("number"===typeof c.p&&(a=c.p),"number"===typeof c.u&&(a+=c.u));2>a?(b=(g.length-this.a)/this.o[2],f=258*(b/2)|0,e=f<h.length?h.length+f:h.length<<1):e=h.length*a;t?(d=new Uint8Array(e),d.set(h)):d=h;return this.c=d};
w.prototype.n=function(){var c=0,d=this.c,a=this.g,b,e=new (t?Uint8Array:Array)(this.l+(this.b-32768)),f,g,h,k;if(0===a.length)return t?this.c.subarray(32768,this.b):this.c.slice(32768,this.b);f=0;for(g=a.length;f<g;++f){b=a[f];h=0;for(k=b.length;h<k;++h)e[c++]=b[h]}f=32768;for(g=this.b;f<g;++f)e[c++]=d[f];this.g=[];return this.buffer=e};
w.prototype.v=function(){var c,d=this.b;t?this.r?(c=new Uint8Array(d),c.set(this.c.subarray(0,d))):c=this.c.subarray(0,d):(this.c.length>d&&(this.c.length=d),c=this.c);return this.buffer=c};function W(c,d){var a,b;this.input=c;this.a=0;if(d||!(d={}))d.index&&(this.a=d.index),d.verify&&(this.A=d.verify);a=c[this.a++];b=c[this.a++];switch(a&15){case ha:this.method=ha;break;default:throw Error("unsupported compression method");}if(0!==((a<<8)+b)%31)throw Error("invalid fcheck flag:"+((a<<8)+b)%31);if(b&32)throw Error("fdict flag is not supported");this.q=new w(c,{index:this.a,bufferSize:d.bufferSize,bufferType:d.bufferType,resize:d.resize})}
W.prototype.k=function(){var c=this.input,d,a;d=this.q.k();this.a=this.q.a;if(this.A){a=(c[this.a++]<<24|c[this.a++]<<16|c[this.a++]<<8|c[this.a++])>>>0;var b=d;if("string"===typeof b){var e=b.split(""),f,g;f=0;for(g=e.length;f<g;f++)e[f]=(e[f].charCodeAt(0)&255)>>>0;b=e}for(var h=1,k=0,m=b.length,n,p=0;0<m;){n=1024<m?1024:m;m-=n;do h+=b[p++],k+=h;while(--n);h%=65521;k%=65521}if(a!==(k<<16|h)>>>0)throw Error("invalid adler-32 checksum");}return d};var ha=8;r("Zlib.Inflate",W);r("Zlib.Inflate.prototype.decompress",W.prototype.k);var X={ADAPTIVE:B.s,BLOCK:B.t},Y,Z,$,ia;if(Object.keys)Y=Object.keys(X);else for(Z in Y=[],$=0,X)Y[$++]=Z;$=0;for(ia=Y.length;$<ia;++$)Z=Y[$],r("Zlib.Inflate.BufferType."+Z,X[Z]);}
).call(window);
/* Render.js
 */
 


 
class Render {
  constructor(egg) {
    this.canvas = egg.canvas;
    this.egg = egg;
    this.gl = this.canvas.getContext("webgl");
    this.webgl = new Webgl(this.egg, this.gl);
    
    // (texid) exposed to client is the index in this array, plus one.
    this.textures = []; // {texid,fbid,w,h,fmt}
  
    this.tint = 0;
    this.alpha = 1;
    this.tr = 0;
    this.tg = 0;
    this.tb = 0;
    this.ta = 0;
  
    this.pgm_raw = null;
    this.pgm_decal = null;
    this.pgm_tile = null;
  
    this.u_raw_screensize = 0;
    this.u_raw_alpha = 0;
    this.u_decal_screensize = 0;
    this.u_decal_sampler = 0;
    this.u_decal_alpha = 0;
    this.u_decal_tint = 0;
    this.u_tile_screensize = 0;
    this.u_tile_sampler = 0;
    this.u_tile_alpha = 0;
    this.u_tile_tint = 0;
    this.u_tile_pointsize = 0;
    
    // Storage for draw_rect, draw_decal, and draw_to_main.
    // Decal is larger, 4 vertices * 12 bytes each.
    this.vbuf = new ArrayBuffer(12 * 4);
    this.vbufu8 = new Uint8Array(this.vbuf);
    this.vbufs16 = new Int16Array(this.vbuf);
    this.vbuff32 = new Float32Array(this.vbuf);
    
    this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA);
    this.gl.enable(this.gl.BLEND);
    if (!(this.buffer = this.gl.createBuffer())) throw new Error(`Failed to create WebGL vertex buffer.`);
    
    if (
      (this.egg_texture_new() !== 1) ||
      (this.egg_texture_upload(1, this.canvas.width, this.canvas.height, this.canvas.width << 2, 1, 0, 0) < 0)
    ) throw new Error(`Failed to create main framebuffer.`);
    
    this.compileShaders();
    
    this.sizeDirty = false;
    this.resizeObserver = new ResizeObserver(e => this.sizeDirty = true);
    this.resizeObserver.observe(this.canvas);
  }
  
  /*---------------------------- Entry points for Egg platform ------------------------------*/
  
  // Notify that the runtime is shutting down.
  stop() {
    this.resizeObserver.disconnect();
    this.egg_draw_rect(1, 0, 0, this.canvas.width, this.canvas.height, 0x808080ff);
    this.end(true);
  }
  
  begin() {
    this.egg_render_tint(0x00000000);
    this.alpha = 1;
    if (this.sizeDirty) {
      this.sizeDirty = false;
      if (this.egg.directgl) {
        const bounds = this.canvas.getBoundingClientRect();
        this.canvas.width = bounds.width;
        this.canvas.height = bounds.height;
      }
    }
  }
  
  end(override) {
    if (this.egg.directgl && !override) return;
    const srctex = this.textures[0];
    if (!srctex) return;

    const dstx = 0, dsty = 0, dstw = this.canvas.width, dsth = this.canvas.height;
    const aposv = this.vbufs16;
    const tcv = this.vbuff32;
    aposv[ 0] = dstx;      aposv[ 1] = dsty;      tcv[ 1] = 0.0; tcv[ 2] = 1.0;
    aposv[ 6] = dstx;      aposv[ 7] = dsty+dsth; tcv[ 4] = 0.0; tcv[ 5] = 0.0;
    aposv[12] = dstx+dstw; aposv[13] = dsty;      tcv[ 7] = 1.0; tcv[ 8] = 1.0;
    aposv[18] = dstx+dstw; aposv[19] = dsty+dsth; tcv[10] = 1.0; tcv[11] = 0.0;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vbuf, this.gl.STREAM_DRAW);
    
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
    this.gl.useProgram(this.pgm_decal);
    this.gl.uniform2f(this.u_decal_screensize, this.canvas.width, this.canvas.height);
    this.gl.bindTexture(this.gl.TEXTURE_2D, srctex.texid);
    this.gl.uniform4f(this.u_decal_tint, 0.0, 0.0, 0.0, 0.0);
    this.gl.uniform1f(this.u_decal_alpha, 1.0);
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 12, 0);
    this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 12, 4);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  /*------------------------ Public API entry points ---------------------------------*/
  
  egg_video_set_string_buffer(vp, a) {
    this.webgl.glstrp = vp;
    this.webgl.glstra = a;
  }
  
  egg_video_get_size(wp, hp) {
    if (wp) this.egg.exec.mem32[wp >> 2] = this.canvas.width;
    if (hp) this.egg.exec.mem32[hp >> 2] = this.canvas.height;
  }
  
  egg_texture_del(texid) {
    if ((texid < 2) || (texid > this.textures.length)) return; // sic "<2". You can't delete the main framebuffer.
    const texture = this.textures[texid - 1];
    if (!texture) return;
    if (texture.texid) this.gl.deleteTexture(texture.texid);
    if (texture.fbid) this.gl.deleteFramebuffer(texture.fbid);
    this.textures[texid - 1] = null;
  }
  
  egg_texture_new() {
    const texture = {
      texid: this.gl.createTexture(),
      fbid: null,
      w: 0,
      h: 0,
      fmt: 0,
    };
    if (!texture.texid) return 0;
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture.texid);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
    const p = this.textures.indexOf(null);
    if (p >= 0) {
      this.textures[p] = texture;
      return p + 1;
    } else {
      this.textures.push(texture);
      return this.textures.length;
    }
  }
  
  egg_texture_get_header(wp, hp, fmtp, texid) {
    const texture = this.textures[texid - 1];
    if (!texture) return;
    if (wp) this.egg.exec.mem32[wp >> 2] = texture.w;
    if (hp) this.egg.exec.mem32[hp >> 2] = texture.h;
    if (fmtp) this.egg.exec.mem32[fmtp >> 2] = texture.fmt;
  }
  
  egg_texture_load_image(texid, qual, rid) {
    if ((texid < 2) || (texid > this.textures.length)) return -1;
    const texture = this.textures[texid - 1];
    if (!texture) return -1;
    const serial = this.egg.rom.getRes(Rom.RESTYPE_image, qual, rid);
    if (!serial || !serial.length) return -1;
    const image = this.egg.imageDecoder.decode(serial);
    if (!image) return -1;
    return this.loadTexture(texture, image);
  }
  
  egg_texture_upload(texid, w, h, stride, fmt, v, c) {
    if ((texid < 1) || (texid > this.textures.length)) return -1;
    const texture = this.textures[texid - 1];
    if (!texture) return -1;
    if (texid === 1) { // Allowed to upload to texid 1, but not allowed to resize it.
      if (texture.w && texture.h) {
        if ((w !== texture.w) || (h !== texture.h)) return -1;
      }
    }
    let mem = null;
    if (c) {
      if (!(mem = this.egg.exec.getView(v, c))) return -1;
    }
    return this.loadTexture(texture, {
      v: mem,
      w, h, stride, fmt,
    });
  }
  
  egg_texture_clear(texid) {
    const texture = this.textures[texid - 1];
    if (!texture) return;
    this.requireFramebuffer(texture);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.fbid);
    this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
  }
  
  egg_render_tint(tint) {
    this.tint = tint;
    this.tr = ((tint >> 24) & 0xff) / 255.0;
    this.tg = ((tint >> 16) & 0xff) / 255.0;
    this.tb = ((tint >> 8) & 0xff) / 255.0;
    this.ta = (tint & 0xff) / 255.0;
  }
  
  egg_render_alpha(a) {
    this.alpha = a / 255.0;
  }
  
  egg_draw_rect(dsttexid, x, y, w, h, rgba) {
    const texture = this.textures[dsttexid - 1];
    if (!texture) return;
    const r = (rgba >> 24) & 0xff;
    const g = (rgba >> 16) & 0xff;
    const b = (rgba >> 8) & 0xff;
    const a = rgba & 0xff;
    this.requireFramebuffer(texture);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.fbid);
    this.gl.useProgram(this.pgm_raw);
    this.gl.viewport(0, 0, texture.w, texture.h);
    this.gl.uniform2f(this.u_raw_screensize, texture.w, texture.h);
    this.gl.uniform1f(this.u_raw_alpha, this.alpha);
    
    const aposv = this.vbufs16;
    const colorv = this.vbufu8;
    aposv[ 0] = x;   aposv[ 1] = y;   colorv[ 4] = r; colorv[ 5] = g; colorv[ 6] = b; colorv[ 7] = a;
    aposv[ 4] = x;   aposv[ 5] = y+h; colorv[12] = r; colorv[13] = g; colorv[14] = b; colorv[15] = a;
    aposv[ 8] = x+w; aposv[ 9] = y;   colorv[20] = r; colorv[21] = g; colorv[22] = b; colorv[23] = a;
    aposv[12] = x+w; aposv[13] = y+h; colorv[28] = r; colorv[29] = g; colorv[30] = b; colorv[31] = a;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vbuf, this.gl.STREAM_DRAW);
    
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 8, 0);
    this.gl.vertexAttribPointer(1, 4, this.gl.UNSIGNED_BYTE, true, 8, 4);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  drawRaw(dsttexid, mode, v, c) {
    const texture = this.textures[dsttexid - 1];
    if (!texture) return;
    this.requireFramebuffer(texture);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.fbid);
    this.gl.useProgram(this.pgm_raw);
    this.gl.viewport(0, 0, texture.w, texture.h);
    this.gl.uniform2f(this.u_raw_screensize, texture.w, texture.h);
    this.gl.uniform1f(this.u_raw_alpha, this.alpha);
    
    const len = c * 8;
    const srcview = this.egg.exec.getView(v, len);
    if (!srcview) return;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, srcview, this.gl.STREAM_DRAW);
    
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 8, 0);
    this.gl.vertexAttribPointer(1, 4, this.gl.UNSIGNED_BYTE, true, 8, 4);
    this.gl.drawArrays(mode, 0, c);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  egg_draw_line(dsttexid, v, c) {
    this.drawRaw(dsttexid, this.gl.LINE_STRIP, v, c);
  }
  
  egg_draw_trig(dsttexid, v, c) {
    this.drawRaw(dsttexid, this.gl.TRIANGLE_STRIP, v, c);
  }
  
  egg_draw_decal(dsttexid, srctexid, dstx, dsty, srcx, srcy, w, h, xform) {
    if (dsttexid === srctexid) return;
    const dsttex = this.textures[dsttexid - 1];
    const srctex = this.textures[srctexid - 1];
    if (!dsttex || !srctex) return;
    this.requireFramebuffer(dsttex);
    
    let dstw = w, dsth = h;
    if (xform & 4) { // SWAP
      dstw = h;
      dsth = w;
    }
    const aposv = this.vbufs16;
    const tcv = this.vbuff32;
    aposv[ 0] = dstx;      aposv[ 1] = dsty;      tcv[ 1] = 0.0; tcv[ 2] = 0.0;
    aposv[ 6] = dstx;      aposv[ 7] = dsty+dsth; tcv[ 4] = 0.0; tcv[ 5] = 1.0;
    aposv[12] = dstx+dstw; aposv[13] = dsty;      tcv[ 7] = 1.0; tcv[ 8] = 0.0;
    aposv[18] = dstx+dstw; aposv[19] = dsty+dsth; tcv[10] = 1.0; tcv[11] = 1.0;
    if (xform & 4) { // SWAP
      for (let i=1; i<12; i+=3) {
        const tmp = tcv[i];
        tcv[i] = tcv[i + 1];
        tcv[i + 1] = tmp;
      }
    }
    if (xform & 1) { // XREV
      for (let i=1; i<12; i+=3) {
        tcv[i] = 1.0 - tcv[i];
      }
    }
    if (xform & 2) { // YREV
      for (let i=2; i<12; i+=3) {
        tcv[i] = 1.0 - tcv[i];
      }
    }
    const tx0 = srcx / srctex.w;
    const tx1 = w / srctex.w;
    const ty0 = srcy / srctex.h;
    const ty1 = h / srctex.h;
    for (let i=1; i<12; i+=3) {
      tcv[i] = tx0 + tx1 * tcv[i];
      tcv[i+1] = ty0 + ty1 * tcv[i+1];
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vbuf, this.gl.STREAM_DRAW);
    
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, dsttex.fbid);
    this.gl.viewport(0, 0, dsttex.w, dsttex.h);
    this.gl.useProgram(this.pgm_decal);
    this.gl.uniform2f(this.u_decal_screensize, dsttex.w, dsttex.h);
    this.gl.bindTexture(this.gl.TEXTURE_2D, srctex.texid);
    this.gl.uniform4f(this.u_decal_tint, this.tr, this.tg, this.tb, this.ta);
    this.gl.uniform1f(this.u_decal_alpha, this.alpha);
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 12, 0);
    this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 12, 4);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  egg_draw_decal_mode7(dsttexid, srctexid, dstx, dsty, srcx, srcy, w, h, rotation, xscale, yscale) {
    if (dsttexid === srctexid) return;
    const dsttex = this.textures[dsttexid - 1];
    const srctex = this.textures[srctexid - 1];
    if (!dsttex || !srctex) return;
    this.requireFramebuffer(dsttex);
    rotation /= 65536;
    xscale /= 65536;
    yscale /= 65536;
    
    const aposv = this.vbufs16;
    const tcv = this.vbuff32;
    const cost = Math.cos(-rotation);
    const sint = Math.sin(-rotation);
    const halfw = w * xscale * 0.5;
    const halfh = h * yscale * 0.5;
    const nwx = Math.round( cost * halfw + sint * halfh);
    const nwy = Math.round(-sint * halfw + cost * halfh);
    const swx = Math.round( cost * halfw - sint * halfh);
    const swy = Math.round(-sint * halfw - cost * halfh);
    aposv[ 0] = dstx - nwx; aposv[ 1] = dsty - nwy; tcv[ 1] = 0.0; tcv[ 2] = 0.0;
    aposv[ 6] = dstx - swx; aposv[ 7] = dsty - swy; tcv[ 4] = 0.0; tcv[ 5] = 1.0;
    aposv[12] = dstx + swx; aposv[13] = dsty + swy; tcv[ 7] = 1.0; tcv[ 8] = 0.0;
    aposv[18] = dstx + nwx; aposv[19] = dsty + nwy; tcv[10] = 1.0; tcv[11] = 1.0;
    const tx0 = (srcx + 0.5) / srctex.w;
    const tx1 = (w - 1) / srctex.w;
    const ty0 = (srcy + 0.5) / srctex.h;
    const ty1 = (h - 1) / srctex.h;
    for (let i=1; i<12; i+=3) {
      tcv[i] = tx0 + tx1 * tcv[i];
      tcv[i+1] = ty0 + ty1 * tcv[i+1];
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vbuf, this.gl.STREAM_DRAW);
    
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, dsttex.fbid);
    this.gl.viewport(0, 0, dsttex.w, dsttex.h);
    this.gl.useProgram(this.pgm_decal);
    this.gl.uniform2f(this.u_decal_screensize, dsttex.w, dsttex.h);
    this.gl.bindTexture(this.gl.TEXTURE_2D, srctex.texid);
    this.gl.uniform4f(this.u_decal_tint, this.tr, this.tg, this.tb, this.ta);
    this.gl.uniform1f(this.u_decal_alpha, this.alpha);
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 12, 0);
    this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 12, 4);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  egg_draw_tile(dsttexid, srctexid, v, c) {
    if (!v || (c < 1)) return;
    if (dsttexid === srctexid) return;
    const dsttex = this.textures[dsttexid - 1];
    const srctex = this.textures[srctexid - 1];
    if (!dsttex || !srctex) return;
    this.requireFramebuffer(dsttex);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, dsttex.fbid);
    this.gl.useProgram(this.pgm_tile);
    this.gl.viewport(0, 0, dsttex.w, dsttex.h);
    this.gl.uniform2f(this.u_tile_screensize, dsttex.w, dsttex.h);
    this.gl.bindTexture(this.gl.TEXTURE_2D, srctex.texid);
    
    const len = c * 6;
    const srcview = this.egg.exec.getView(v, len);
    if (!srcview) return;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, srcview, this.gl.STREAM_DRAW);
    
    this.gl.uniform4f(this.u_tile_tint, this.tr, this.tg, this.tb, this.ta);
    this.gl.uniform1f(this.u_tile_alpha, this.alpha);
    this.gl.uniform1f(this.u_tile_pointsize, srctex.w >> 4);
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.enableVertexAttribArray(2);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 6, 0);
    this.gl.vertexAttribPointer(1, 1, this.gl.UNSIGNED_BYTE, false, 6, 4);
    this.gl.vertexAttribPointer(2, 1, this.gl.UNSIGNED_BYTE, false, 6, 5);
    this.gl.drawArrays(this.gl.POINTS, 0, c);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
    this.gl.disableVertexAttribArray(2);
  }
  
  /*------------------------------ Private -----------------------------------*/
   
  /* (texture) is from our list.
   * (image) is {v,w,h,fmt,stride} where (v) is null or Uint8Array.
   */
  loadTexture(texture, image) {
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture.texid);
    let ifmt = this.gl.RGBA, fmt = this.gl.RGBA, type = this.gl.UNSIGNED_BYTE;
    switch (image.fmt) {
      case 1: break; // RGBA, already initted like that
      case 2: ifmt = this.gl.ALPHA; fmt = this.gl.ALPHA; break;
      case 3: image = this.expand1(image, 0x00000000, 0x000000ff); break; // a1
      default: return -1;
    }
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, ifmt, image.w, image.h, 0, fmt, type, image.v);
    texture.w = image.w;
    texture.h = image.h;
    texture.fmt = image.fmt;
    return 0;
  }
  
  // Return an RGBA image from something 1-bit.
  expand1(image, zero, one) {
    const dststride = image.w << 2;
    const dst = new Uint8Array(dststride * image.h);
    for (let dstp=0, srcp=0, yi=image.h; yi-->0; srcp+=image.stride) {
      for (let xi=image.w, srcmask=0x80, srcpp=srcp; xi-->0; ) {
        if (image.v[srcpp] & srcmask) {
          dst[dstp++] = one >> 24;
          dst[dstp++] = one >> 16;
          dst[dstp++] = one >> 8;
          dst[dstp++] = one;
        } else {
          dst[dstp++] = zero >> 24;
          dst[dstp++] = zero >> 16;
          dst[dstp++] = zero >> 8;
          dst[dstp++] = zero;
        }
        if (srcmask === 1) { srcmask = 0x80; srcpp++; }
        else srcmask >>= 1;
      }
    }
    return {
      v: dst,
      w: image.w,
      h: image.h,
      fmt: 1, // RGBA
      stride: dststride,
    };
  }
  
  requireFramebuffer(texture) {
    if (texture.fbid) return;
    if (!(texture.fbid = this.gl.createFramebuffer())) throw new Error(`Failed to create WebGL framebuffer object.`);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.fbid);
    this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, texture.texid, 0);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
  }
  
  compileShaders() {
  
    this.pgm_raw = this.compileShader("raw", Render.vsrc_raw, Render.fsrc_raw);
    this.gl.useProgram(this.pgm_raw);
    this.u_raw_screensize = this.gl.getUniformLocation(this.pgm_raw, "screensize");
    this.u_raw_alpha = this.gl.getUniformLocation(this.pgm_raw, "alpha");
    this.gl.bindAttribLocation(this.pgm_raw, 0, "apos");
    this.gl.bindAttribLocation(this.pgm_raw, 1, "acolor");
  
    this.pgm_decal = this.compileShader("decal", Render.vsrc_decal, Render.fsrc_decal);
    this.gl.useProgram(this.pgm_decal);
    this.u_decal_screensize = this.gl.getUniformLocation(this.pgm_decal, "screensize");
    this.u_decal_sampler = this.gl.getUniformLocation(this.pgm_decal, "sampler");
    this.u_decal_alpha = this.gl.getUniformLocation(this.pgm_decal, "alpha");
    this.u_decal_tint = this.gl.getUniformLocation(this.pgm_decal, "tint");
    this.gl.bindAttribLocation(this.pgm_decal, 0, "apos");
    this.gl.bindAttribLocation(this.pgm_decal, 1, "atexcoord");
  
    this.pgm_tile = this.compileShader("tile", Render.vsrc_tile, Render.fsrc_tile);
    this.gl.useProgram(this.pgm_tile);
    this.u_tile_screensize = this.gl.getUniformLocation(this.pgm_tile, "screensize");
    this.u_tile_sampler = this.gl.getUniformLocation(this.pgm_tile, "sampler");
    this.u_tile_alpha = this.gl.getUniformLocation(this.pgm_tile, "alpha");
    this.u_tile_tint = this.gl.getUniformLocation(this.pgm_tile, "tint");
    this.u_tile_pointsize = this.gl.getUniformLocation(this.pgm_tile, "pointsize");
    this.gl.bindAttribLocation(this.pgm_tile, 0, "apos");
    this.gl.bindAttribLocation(this.pgm_tile, 1, "atileid");
    this.gl.bindAttribLocation(this.pgm_tile, 2, "axform");
  }
  
  compileShader(name, vsrc, fsrc) {
    const pid = this.gl.createProgram();
    if (!pid) throw new Error(`Failed to create new WebGL program for ${JSON.stringify(name)}`);
    try {
      this.compileShader1(name, pid, this.gl.VERTEX_SHADER, vsrc);
      this.compileShader1(name, pid, this.gl.FRAGMENT_SHADER, fsrc);
      this.gl.linkProgram(pid);
      if (!this.gl.getProgramParameter(pid, this.gl.LINK_STATUS)) {
        const log = this.gl.getProgramInfoLog(pid);
        throw new Error(`Failed to link program ${JSON.stringify(name)}:\n${log}`);
      }
    } catch (e) {
      this.gl.deleteProgram(pid);
      throw e;
    }
    return pid;
  }
  
  compileShader1(name, pid, type, src) {
    const sid = this.gl.createShader(type);
    if (!sid) throw new Error(`Failed to create new WebGL shader for ${JSON.stringify(name)}`);
    try {
      this.gl.shaderSource(sid, src);
      this.gl.compileShader(sid);
      if (!this.gl.getShaderParameter(sid, this.gl.COMPILE_STATUS)) {
        const log = this.gl.getShaderInfoLog(sid);
        throw new Error(`Failed to link ${(type === this.gl.VERTEX_SHADER) ? "vertex" : "fragment"} shader for ${JSON.stringify(name)}:\n${log}`);
      }
      this.gl.attachShader(pid, sid);
    } finally {
      this.gl.deleteShader(sid);
    }
  }
}

/* GLSL
 * TODO These need a minification strategy separate from the general Javascript one.
 ***********************************************************/
 
Render.vsrc_raw = `
  #version 100
  precision mediump float;
  uniform vec2 screensize;
  attribute vec2 apos;
  attribute vec4 acolor;
  varying vec4 vcolor;
  void main() {
    vec2 npos=(apos*2.0)/screensize-1.0;
    gl_Position=vec4(npos,0.0,1.0);
    vcolor=acolor;
  }
`;

Render.fsrc_raw = `
  #version 100
  precision mediump float;
  uniform float alpha;
  varying vec4 vcolor;
  void main() {
    gl_FragColor=vec4(vcolor.rgb,vcolor.a*alpha);
  }
`;
 
Render.vsrc_decal = `
  #version 100
  precision mediump float;
  uniform vec2 screensize;
  attribute vec2 apos;
  attribute vec2 atexcoord;
  varying vec2 vtexcoord;
  void main() {
    vec2 npos=(apos*2.0)/screensize-1.0;
    gl_Position=vec4(npos,0.0,1.0);
    vtexcoord=atexcoord;
  }
`;

Render.fsrc_decal = `
  #version 100
  precision mediump float;
  uniform sampler2D sampler;
  uniform float alpha;
  uniform vec4 tint;
  varying vec2 vtexcoord;
  void main() {
    gl_FragColor=texture2D(sampler,vtexcoord);
    gl_FragColor=vec4(mix(gl_FragColor.rgb,tint.rgb,tint.a),gl_FragColor.a*alpha);
  }
`;
 
Render.vsrc_tile = `
  #version 100
  precision mediump float;
  uniform vec2 screensize;
  uniform float pointsize;
  attribute vec2 apos;
  attribute float atileid;
  attribute float axform;
  varying vec2 vsrcp;
  varying mat2 vmat;
  void main() {
    vec2 npos=(apos*2.0)/screensize-1.0;
    gl_Position=vec4(npos,0.0,1.0);
    vsrcp=vec2(
      mod(atileid,16.0),
      floor(atileid/16.0)
    )/16.0;
         if (axform<0.5) vmat=mat2( 1.0, 0.0, 0.0, 1.0); // no xform
    else if (axform<1.5) vmat=mat2(-1.0, 0.0, 0.0, 1.0); // XREV
    else if (axform<2.5) vmat=mat2( 1.0, 0.0, 0.0,-1.0); // YREV
    else if (axform<3.5) vmat=mat2(-1.0, 0.0, 0.0,-1.0); // XREV|YREV
    else if (axform<4.5) vmat=mat2( 0.0, 1.0, 1.0, 0.0); // SWAP
    else if (axform<5.5) vmat=mat2( 0.0, 1.0,-1.0, 0.0); // SWAP|XREV
    else if (axform<6.5) vmat=mat2( 0.0,-1.0, 1.0, 0.0); // SWAP|YREV
    else if (axform<7.5) vmat=mat2( 0.0,-1.0,-1.0, 0.0); // SWAP|XREV|YREV
                    else vmat=mat2( 1.0, 0.0, 0.0, 1.0); // invalid; use identity
    gl_PointSize=pointsize;
  }
`;

Render.fsrc_tile = `
  #version 100
  precision mediump float;
  uniform sampler2D sampler;
  uniform float alpha;
  uniform vec4 tint;
  varying vec2 vsrcp;
  varying mat2 vmat;
  void main() {
    vec2 texcoord=gl_PointCoord;
    texcoord.y=1.0-texcoord.y;
    texcoord=vmat*(texcoord-0.5)+0.5;
    texcoord=vsrcp+texcoord/16.0;
    gl_FragColor=texture2D(sampler,texcoord);
    gl_FragColor=vec4(mix(gl_FragColor.rgb,tint.rgb,tint.a),gl_FragColor.a*alpha);
  }
`;
/* Exec.js
 * Owns the WebAssembly context.
 */
 

 
class Exec {
  constructor(egg) {
    this.egg = egg;
    if (!window.WebAssembly) throw new Error("WebAssembly not supported");
    this.textDecoder = new TextDecoder("utf8");
    this.textEncoder = new TextEncoder("utf8");
    this.memory = null;
    this.egg_client_quit = () => {};
    this.egg_client_init = () => -1;
    this.egg_client_update = () => {};
    this.egg_client_render = () => {};
    this.mem8 = null;
    this.mem32 = null;
    this.memf64 = null;
    this.fntab = null;
  }
  
  load() {
    const serial = this.egg.rom.getRes(Rom.RESTYPE_wasm, 0, 1);
    const options = { env: {
      egg_log: (f, v) => this.egg.egg_log(f, v),
      egg_time_real: () => Date.now() / 1000,
      egg_time_local: (v, a) => this.egg.egg_time_local(v, a),
      egg_request_termination: () => this.egg.stop(),
      egg_get_user_languages: (v, a) => this.egg.egg_get_user_languages(v, a),
      egg_video_set_string_buffer: (v, a) => this.egg.render.egg_video_set_string_buffer(v, a),
      egg_video_get_size: (wp, hp) => this.egg.render.egg_video_get_size(wp, hp),
      egg_texture_del: (texid) => this.egg.render.egg_texture_del(texid),
      egg_texture_new: () => this.egg.render.egg_texture_new(),
      egg_texture_get_header: (w, h, fmt, texid) => this.egg.render.egg_texture_get_header(w, h, fmt, texid),
      egg_texture_load_image: (texid, qual, rid) => this.egg.render.egg_texture_load_image(texid, qual, rid),
      egg_texture_upload: (texid, w, h, stride, fmt, v, c) => this.egg.render.egg_texture_upload(texid, w, h, stride, fmt, v, c),
      egg_texture_clear: (texid) => this.egg.render.egg_texture_clear(texid),
      egg_render_tint: (rgba) => this.egg.render.egg_render_tint(rgba),
      egg_render_alpha: (a) => this.egg.render.egg_render_alpha(a),
      egg_draw_rect: (dt, x, y, w, h, c) => this.egg.render.egg_draw_rect(dt, x, y, w, h, c),
      egg_draw_line: (dt, v, c) => this.egg.render.egg_draw_line(dt, v, c),
      egg_draw_trig: (dt, v, c) => this.egg.render.egg_draw_trig(dt, v, c),
      egg_draw_decal: (dt, st, dx, dy, sx, sy, w, h, xf) => this.egg.render.egg_draw_decal(dt, st, dx, dy, sx, sy, w, h, xf),
      egg_draw_decal_mode7: (dt, st, dx, dy, sx, sy, w, h, r, xs, ys) => this.egg.render.egg_draw_decal_mode7(dt, st, dx, dy, sx, sy, w, h, r, xs, ys),
      egg_draw_tile: (dt, st, v, c) => this.egg.render.egg_draw_tile(dt, st, v, c),
      egg_image_get_header: (wp, hp, sp, fp, qual, rid) => this.egg.data.egg_image_get_header(wp, hp, sp, fp, qual, rid),
      egg_image_decode: (v, a, qual, rid) => this.egg.data.egg_image_decode(v, a, qual, rid),
      egg_res_get: (v, a, tid, qual, rid) => this.egg.egg_res_get(v, a, tid, qual, rid),
      egg_res_for_each: (cb, ctx) => this.egg.egg_res_for_each(cb, ctx),
      egg_store_get: (v, a, k, kc) => this.egg.data.egg_store_get(v, a, k, kc),
      egg_store_set: (k, kc, v, vc) => this.egg.data.egg_store_set(k, kc, v, vc),
      egg_store_key_by_index: (v, a, p) => this.egg.data.egg_store_key_by_index(v, a, p),
      egg_event_get: (v, a) => this.egg.input.egg_event_get(v, a),
      egg_event_enable: (t, e) => this.egg.input.egg_event_enable(t, e),
      egg_show_cursor: (s) => this.egg.input.egg_show_cursor(s),
      egg_lock_cursor: (l) => this.egg.input.egg_lock_cursor(l),
      egg_joystick_devid_by_index: (p) => this.egg.input.egg_joystick_devid_by_index(p),
      egg_joystick_get_ids: (vid, pid, ver, devid) => this.egg.input.egg_joystick_get_ids(vid, pid, ver, devid),
      egg_joystick_get_name: (v, a, devid) => this.egg.input.egg_joystick_get_name(v, a, devid),
      egg_joystick_for_each_button: (devid, cb, ctx) => this.egg.input.egg_joystick_for_each_button(devid, cb, ctx),
      egg_audio_play_song: (qual, rid, f, r) => this.egg.audio.egg_audio_play_song(qual, rid, f, r),
      egg_audio_play_sound: (qual, rid, t, p) => this.egg.audio.egg_audio_play_sound(qual, rid, t, p),
      egg_audio_event: (c, o, a, b) => this.egg.audio.egg_audio_event(c, o, a, b),
      egg_audio_get_playhead: () => this.egg.audio.egg_audio_get_playhead(),
      egg_audio_set_playhead: (b) => this.egg.audio.egg_audio_set_playhead(b),
      ...this.egg.render.webgl.generatePublicApi(),
    }};
    return WebAssembly.instantiate(serial, options).then(result => {
      const yoink = name => {
        if (!result.instance.exports[name]) {
          throw new Error(`ROM does not export required symbol '${name}'`);
        }
        this[name] = result.instance.exports[name];
      };
      yoink("memory");
      yoink("egg_client_quit");
      yoink("egg_client_init");
      yoink("egg_client_update");
      yoink("egg_client_render");
      this.mem8 = new Uint8Array(this.memory.buffer);
      this.mem32 = new Uint32Array(this.memory.buffer);
      this.memf64 = new Float64Array(this.memory.buffer);
      this.fntab = result.instance.exports.__indirect_function_table;
    });
  }
  
  readCString(p) {
    let z = p;
    while (this.mem8[z]) z++;
    return this.textDecoder.decode(this.mem8.slice(p, z));
  }
  
  readLimitedString(p, limit) {
    let z = p;
    while (this.mem8[z] && (limit-- > 0)) z++;
    return this.textDecoder.decode(this.mem8.slice(p, z));
  }
  
  // (src) must be string or Uint8Array
  safeWrite(dst, dsta, src) {
    if (typeof(src) === "string") {
      src = this.textEncoder.encode(src);
    }
    const cpc = Math.min(dsta, src.length);
    if (cpc === src.length) {
      const dstview = new Uint8Array(this.memory.buffer, dst, cpc);
      dstview.set(src);
    } else if (cpc > 0) {
      const dstview = new Uint8Array(this.memory.buffer, dst, cpc);
      const srcview = new Uint8Array(src.buffer, src.byteOffset, cpc);
      dstview.set(srcview);
    }
    return src.length;
  }
  
  // Offset Uint8Array, or null if OOB
  getView(p, c) {
    if ((p < 0) || (c < 0) || (p > this.memory.buffer.byteLength - c)) return null;
    return new Uint8Array(this.memory.buffer, p, c);
  }
}
/* DataService.js
 * Coordinates higher-level services around resources,
 * and the persistent storage.
 */
 

 
class DataService {
  constructor(egg) {
    this.egg = egg;
    this.rom = egg.rom;
    this.metadata = null; // {k:v} strings
    this.masterKey = "store-" + this.getMetadata("title").substring(0, 32);
    try {
      this.store = JSON.parse(window.localStorage.getItem(this.masterKey));
      if (!this.store || (typeof(this.store) !== "object") || (this.store instanceof Array)) this.store = {};
    } catch (e) {
      this.store = {};
    }
    this.storeSaveTimeout = null;
  }
  
  getMetadata(k) {
    if (!this.metadata) this.metadata = this.decodeMetadata(this.rom.getRes(Rom.RESTYPE_metadata, 0, 1));
    // TODO Look for "*String", if we know the language.
    return this.metadata[k] || "";
  }
  
  decodeMetadata(src) {
    if ((src.length < 2) || (src[0] !== 0xee) || (src[1] !== 0x4d)) return {};
    const decoder = new TextDecoder("utf8");
    const dst = {};
    for (let srcp=2; srcp<src.length; ) {
      const kc = src[srcp++] || 0;
      const vc = src[srcp++] || 0;
      if (srcp > src.length - vc - kc) break;
      const k = decoder.decode(src.slice(srcp, srcp + kc));
      srcp += kc;
      const v = decoder.decode(src.slice(srcp, srcp + vc));
      srcp += vc;
      dst[k] = v;
    }
    return dst;
  }
  
  storeDirty() {
    /* This debounce shouldn't be long, in fact zero would probably be OK.
     * The idea is that if the game sets a whole bunch of fields in one update cycle, don't write them out more than once.
     * No matter what we do here, fields written by the game available to it for immediate readback.
     */
    const saveDebounceTimeMs = 500;
    if (!this.storeSaveTimeout) this.storeSaveTimeout = window.setTimeout(() => {
      this.storeSaveTimeout = null;
      window.localStorage.setItem(this.masterKey, JSON.stringify(this.store));
    }, saveDebounceTimeMs);
  }
  
  /*--------------------------- Public API entry points ---------------------------------*/
  
  egg_image_get_header(wp, hp, stridep, fmtp, qual, rid) {
    const serial = this.rom.getRes(Rom.RESTYPE_image, qual, rid);
    if (serial.length < 1) return;
    try {
      const header = this.egg.imageDecoder.decodeHeader(serial);
      this.egg.exec.mem32[wp >> 2] = header.w;
      this.egg.exec.mem32[hp >> 2] = header.h;
      this.egg.exec.mem32[stridep >> 2] = header.stride;
      this.egg.exec.mem32[fmtp >> 2] = header.fmt;
    } catch (e) {}
  }
  
  egg_image_decode(dst, dsta, qual, rid) {
    const serial = this.rom.getRes(Rom.RESTYPE_image, qual, rid);
    if (serial.length < 1) return -1;
    try {
      const image = this.egg.imageDecoder.decode(serial);
      return this.egg.exec.safeWrite(dst, dsta, image.v);
    } catch (e) {
      console.error(e);
      return -1;
    }
  }
  
  egg_store_get(dst, dsta, k, kc) {
    k = this.egg.exec.readLimitedString(k, kc);
    const v = this.store[k] || "";
    return this.egg.exec.safeWrite(dst, dsta, v);
  }
  
  egg_store_set(k, kc, v, vc) {
    k = this.egg.exec.readLimitedString(k, kc);
    v = this.egg.exec.readLimitedString(v, vc);
    if (!k) return -1;
    //TODO Access control.
    if (v) {
      if (this.store[k] === v) return 0;
      if (!this.store[k]) {
        //TODO Confirm length<256 when encoded UTF-8.
      }
      this.store[k] = v;
    } else {
      if (!this.store[k]) return 0;
      delete this.store[k];
    }
    this.storeDirty();
    return 0;
  }
  
  egg_store_key_by_index(dst, dsta, p) {
    const keys = Object.keys(this.store);
    return this.egg.exec.safeWrite(dst, dsta, keys[p] || "");
  }
}



function startEgg(rom) {
  const egg = new Egg(rom);
  egg.attachToDom();
  egg.start().then(() => {
  }).catch(displayError);
}

function displayError(error) {
  document.body.innerHTML = "";
  const element = document.createElement("DIV");
  document.body.appendChild(element);
  element.classList.add("error");
  console.error(error);
  if (typeof(error) === "string") {
    element.innerText = error;
  } else if (!error) {
    element.innerText = "Unspecified error.";
  } else if (error.stack) {
    element.innerText = error.stack;
  } else if (error.message) {
    element.innerText = error.message;
  } else {
    element.innerText = JSON.stringify(error, null, 2);
  }
}

window.addEventListener("load", () => {
  let rom;
  const emb = document.querySelector("egg-rom");
  if (emb) startEgg(new Rom(emb.innerText));
  else {
    window.fetch("/api/roms").then(rsp => {
      if (!rsp.ok) throw rsp;
      return rsp.json();
    }).then(roms => {
      //TODO Should stop here and present these options to the user.
      // But maybe just load it, if there's exactly one.
      return window.fetch(roms[0]);
    }).then(rsp => {
      if (rsp.status === 599) {
        return rsp.text().then(msg => { throw msg; });
      }
      if (!rsp.ok) throw rsp;
      return rsp.arrayBuffer();
    }).then(serial => {
      startEgg(new Rom(serial));
    }).catch(error => {
      displayError(error);
    });
  }
});
/* Input.js
 */
 
class Input {
  constructor(egg) {
    this.egg = egg;
    
    this.evtq = []; // Each member is an array of 2..5 ints.
    this.evtmask = 
      (1 << Input.EGG_EVENT_JOY) |
      (1 << Input.EGG_EVENT_KEY) |
      (1 << Input.EGG_EVENT_TOUCH)|
      // MMOTION, MBUTTON, MWHEEL, TEXT, ACCEL: off by default
    0;
    // TODO Turn off JOY, KEY, and TOUCH if we can tell they aren't supported.
    
    this.cursorVisible = false;
    this.cursorDesired = true; // Should be visible when enabled. (egg_show_cursor())
    this.mouseEventListener = null;
    this.mouseButtonsDown = new Set();
    this.mouseX = 0;
    this.mouseY = 0;
    this.mouseLocked = false;
    
    this.keyListener = e => this.onKey(e);
    window.addEventListener("keydown", this.keyListener);
    window.addEventListener("keyup", this.keyListener);
    
    this.gamepads = []; // sparse
    this.gamepadListener = e => this.onGamepadConnection(e);
    window.addEventListener("gamepadconnected", this.gamepadListener);
    window.addEventListener("gamepaddisconnected", this.gamepadListener);
    
    this.touchListener = null;
    
    this.accel = null;
    this.accelListener = null;
    
    this.canvasChanged();
  }
  
  canvasChanged() {
    const canvas = this.egg.canvas;
    if (this.touchListener && (this.canvas !== canvas)) {
      this.canvas.removeEventListener("touchstart", this.touchListener);
      this.canvas.removeEventListener("touchend", this.touchListener);
      this.canvas.removeEventListener("touchcancel", this.touchListener);
      this.canvas.removeEventListener("touchmove", this.touchListener);
      this.touchListener = null;
    }
    if (canvas) {
      this.canvas = canvas;
      if (!this.touchListener) {
        this.touchListener = e => this.onTouch(e);
        canvas.addEventListener("touchstart", this.touchListener);
        canvas.addEventListener("touchend", this.touchListener);
        canvas.addEventListener("touchcancel", this.touchListener);
        canvas.addEventListener("touchmove", this.touchListener);
      }
    }
  }
  
  detach() {
    this._unlistenMouse();
    if (this.keyListener) {
      window.removeEventListener("keydown", this.keyListener);
      window.removeEventListener("keyup", this.keyListener);
      this.keyListener = null;
    }
    if (this.gamepadListener) {
      window.removeEventListener("gamepadconnected", this.gamepadListener);
      window.removeEventListener("gamepaddisconnected", this.gamepadListener);
      this.gamepadListener = null;
    }
    if (this.touchListener) {
      this.canvas.removeEventListener("touchstart", this.touchListener);
      this.canvas.removeEventListener("touchend", this.touchListener);
      this.canvas.removeEventListener("touchcancel", this.touchListener);
      this.canvas.removeEventListener("touchmove", this.touchListener);
      this.touchListener = null;
    }
    if (this.accel) {
      if (this.accelListener) {
        this.accel.removeEventListener("reading", this.accelListener);
        this.accelListener = null;
      }
      this.accel.stop();
    }
  }
  
  update() {
    this._updateGamepads();
  }
  
  // (v) is an array of 2..5 integers; see egg_input.h
  pushEvent(v) {
    if (!(this.evtmask & (1 << v[0]))) return;
    this.evtq.push(v);
  }
  
  reset() {
    this.evtq = [];
    const initialMask =
      (1 << Input.EGG_EVENT_JOY) |
      (1 << Input.EGG_EVENT_KEY) |
      (1 << Input.EGG_EVENT_TOUCH)|
    0;
    if (initialMask !== this.evtmask) {
      for (let i=0; i<30; i++) {
        if ((initialMask & (1 << i)) !== (this.evtmask & (1 << i))) {
          this.event_enable(i, initialMask & (1 << i));
        }
      }
    }
  }
  
  /* Touch.
   ********************************************************************/
   
  onTouch(e) {
    if (!e.changedTouches) return;
    if (!this.canvas) return;
    const bounds = this.canvas.getBoundingClientRect();
    let state;
    switch (e.type) {
      case "touchstart": state = 1; break;
      case "touchend":
      case "touchcancel": state = 0; break;
      case "touchmove": state = 2; break;
    }
    for (const touch of e.changedTouches) {
      const x = ((touch.clientX - bounds.x) * this.canvas.width) / bounds.width;
      const y = ((touch.clientY - bounds.y) * this.canvas.height) / bounds.height;
      this.pushEvent([Input.EGG_EVENT_TOUCH, this.eggSafeTouchId(touch.identifier), state, x, y]);
    }
  }
  
  // The spec doesn't constain Touch.identifier beyond saying it must be an integer.
  // For Egg, it must be a *positive* integer. I've seen zero.
  eggSafeTouchId(id) {
    return (id < 1) ? ((id & 0x7fffffff) | 0x00001000) : id;
  }
  
  /* Gamepad.
   * We will use (gamepad.index+1) as (devid) for reporting to the client.
   ******************************************************************************/
   
  _updateGamepads() {
    if (!window.navigator.getGamepads) return;
    for (const gamepad of window.navigator.getGamepads()) {
      if (!gamepad) continue;
      const local = this.gamepads[gamepad.index];
      if (!local) continue;
      
      for (let i=local.axes.length; i-->0; ) {
        const pv = local.axes[i];
        const nx = gamepad.axes[i] ? Math.floor(gamepad.axes[i] * 127) : 0;
        if (pv === nx) continue;
        local.axes[i] = nx;
        this.pushEvent([Input.EGG_EVENT_JOY, local.devid, local.axisBase + i, nx]);
      }
      
      for (let i=local.buttons.length; i-->0; ) {
        const pv = local.buttons[i];
        const nx = gamepad.buttons[i].value;
        if (pv === nx) continue;
        local.buttons[i] = nx;
        this.pushEvent([Input.EGG_EVENT_JOY, local.devid, local.buttonBase + i, nx]);
      }
    }
  }
  
  onGamepadConnection(e) {
    switch (e.type) {
    
      case "gamepadconnected": {
          let axisBase, buttonBase;
          if (e.gamepad.mapping === "standard") {
            axisBase = 0x40;
            buttonBase = 0x80;
          } else {
            axisBase = 0x100;
            buttonBase = 0x200;
          }
          this.gamepads[e.gamepad.index] = {
            devid: e.gamepad.index + 1,
            index: e.gamepad.index,
            id: e.gamepad.id,
            axes: (e.gamepad.axes || []).map(v => v),
            buttons: (e.gamepad.buttons || []).map(v => 0),
            mapping: e.gamepad.mapping,
            axisBase,
            buttonBase,
          };
          this.pushEvent([Input.EGG_EVENT_JOY, e.gamepad.index + 1, 0, 1]);
        } break;
        
      case "gamepaddisconnected": {
          const local = this.gamepads[e.gamepad.index];
          if (local) {
            delete this.gamepads[e.gamepad.index];
            this.pushEvent([Input.EGG_EVENT_JOY, local.devid, 0, 0]);
          }
        } break;
    }
  }
  
  /* Mouse.
   ********************************************************************************/
  
  _checkCursorVisibility(show) {
    const enableEvents = show;
    if (this.cursorDesired) show = !!show;
    else show = false;
    if (show !== this.cursorVisible) {
      this.cursorVisible = show;
      if (this.canvas) {
        if (show) {
          this.canvas.style.cursor = "pointer";
        } else {
          this.canvas.style.cursor = "none";
        }
      }
    }
    if (enableEvents) {
      if (!this.mouseListener) {
        this._listenMouse();
      }
    } else {
      if (this.mouseListener) {
        this._unlistenMouse();
      }
    }
  }
  
  _listenMouse() {
    if (this.mouseEventListener) return;
    this.mouseEventListener = e => this.onMouseEvent(e);
    window.addEventListener("mousewheel", this.mouseEventListener);
    window.addEventListener("mousemove", this.mouseEventListener);
    window.addEventListener("mouseup", this.mouseEventListener);
    if (this.canvas) {
      this.canvas.addEventListener("mousedown", this.mouseEventListener);
      this.canvas.addEventListener("contextmenu", this.mouseEventListener);
    }
  }
  
  _unlistenMouse() {
    if (this.mouseEventListener) {
      window.removeEventListener("mousewheel", this.mouseEventListener);
      window.removeEventListener("mousemove", this.mouseEventListener);
      window.removeEventListener("mouseup", this.mouseEventListener);
      if (this.canvas) {
        this.canvas.removeEventListener("mousedown", this.mouseEventListener);
        this.canvas.removeEventListener("contextmenu", this.mouseEventListener);
      }
      this.mouseEventListener = null;
    }
  }
  
  onMouseEvent(e) {
    if (!this.canvas) return;
    const bounds = this.canvas.getBoundingClientRect();
    const x = Math.floor(((e.x - bounds.x) * this.canvas.width) / bounds.width);
    const y = Math.floor(((e.y - bounds.y) * this.canvas.height) / bounds.height);
    switch (e.type) {
      case "mousemove": {
          if (this.mouseLocked) {
            if (e.movementX || e.movementY) {
              this.pushEvent([Input.EGG_EVENT_MMOTION, e.movementX, e.movementY]);
            }
          } else {
            if ((x === this.mouseX) && (y === this.mouseY)) return;
            this.mouseX = x;
            this.mouseY = y;
            this.pushEvent([Input.EGG_EVENT_MMOTION, x, y]);
          }
        } break;
      case "mousedown": {
          if (e.target !== this.canvas) return;
          let button;
          switch (e.button) {
            case 0: button = Input.EGG_MBUTTON_LEFT; break;
            case 1: button = Input.EGG_MBUTTON_MIDDLE; break;
            case 2: button = Input.EGG_MBUTTON_RIGHT; break;
            default: button = e.button;
          }
          if (this.mouseButtonsDown.has(button)) return;
          this.mouseButtonsDown.add(button);
          e.preventDefault();
          this.pushEvent([Input.EGG_EVENT_MBUTTON, x, y, button, 1]);
        } break;
      case "mouseup": {
          let button;
          switch (e.button) {
            case 0: button = Input.EGG_MBUTTON_LEFT; break;
            case 1: button = Input.EGG_MBUTTON_MIDDLE; break;
            case 2: button = Input.EGG_MBUTTON_RIGHT; break;
            default: button = e.button;
          }
          if (!this.mouseButtonsDown.has(button)) return;
          this.mouseButtonsDown.delete(button);
          this.pushEvent([Input.EGG_EVENT_MBUTTON, x, y, button, 0]);
        } break;
      case "contextmenu": e.preventDefault(); break;
      case "mousewheel": {
          if ((x < 0) || (y < 0) || (x >= bounds.width) || (y >= bounds.height)) return;
          let dx = e.deltaX, dy = e.deltaY;
          if (e.wheelDeltaX) dx /= Math.abs(e.wheelDeltaX);
          if (e.wheelDeltaY) dy /= Math.abs(e.wheelDeltaY);
          if (e.wheelDelta && !e.wheelDeltaX && !e.wheelDeltaY) {
            dx /= Math.abs(e.wheelDelta);
            dy /= Math.abs(e.wheelDelta);
          }
          if (e.shiftKey) { // I like Shift+Wheel to mean X instead of Y.
            let tmp = dx;
            dx = dy;
            dy = tmp;
          }
          if (dx || dy) {
            this.pushEvent([Input.EGG_EVENT_MWHEEL, x, y, dx, dy]);
          }
          //event.preventDefault(); // It's installed as passive... why is that? (Chrome Linux)
        } break;
    }
  }
  
  /* Keyboard.
   **************************************************************************/
  
  onKey(e) {
    
    // Ignore all keyboard events when Alt or Ctrl is held.
    if (e.ctrlKey || e.altKey) {
      return;
    }
    
    // TODO We might be too heavy-handed with event suppression. Bear in mind that we are listening on Window.
    
    // If we recognize the key and user wants key events, pass it on and suppress it in browser.
    if (this.evtmask & (1 << Input.EGG_EVENT_KEY)) {
      const usage = this.hidUsageByKeyCode(e.code);
      if (usage) {
        const v = (e.type === "keyup") ? 0 : e.repeat ? 2 : 1;
        this.pushEvent([Input.EGG_EVENT_KEY, usage, v]);
        e.preventDefault();
        e.stopPropagation();
      }
    }
    
    // Likewise, if user wants text and it looks like text. (but not for "keyup" of course).
    if (e.type !== "keyup") {
      if (this.evtmask & (1 << Input.EGG_EVENT_TEXT)) {
        switch (e.key) {
          case "Backspace": this.pushEvent([Input.EGG_EVENT_TEXT, 0x08]); e.preventDefault(); e.stopPropagation(); break;
          case "Tab":       this.pushEvent([Input.EGG_EVENT_TEXT, 0x09]); e.preventDefault(); e.stopPropagation(); break;
          case "Enter":     this.pushEvent([Input.EGG_EVENT_TEXT, 0x0a]); e.preventDefault(); e.stopPropagation(); break;
          case "Escape":    this.pushEvent([Input.EGG_EVENT_TEXT, 0x1b]); e.preventDefault(); e.stopPropagation(); break;
          default: if (e.key?.length === 1) {
              this.pushEvent([Input.EGG_EVENT_TEXT, e.key.charCodeAt(0)]);
              e.preventDefault();
              e.stopPropagation();
            } break;
        }
      }
    }
  }
  
  hidUsageByKeyCode(code) {
    if (!code) return 0;
  
    // "KeyA".."KeyZ" => 0x04..0x1d
    if ((code.length === 4) && code.startsWith("Key")) {
      const ch = code.charCodeAt(3);
      if ((ch >= 0x41) && (ch <= 0x5a)) return 0x00070004 + ch - 0x41;
    }
    
    // "Digit1".."Digit9" => 0x1e..0x25, some jackass put "0" on the right side... why...
    if ((code.length === 6) && code.startsWith("Digit")) {
      const ch = code.charCodeAt(5);
      if ((ch >= 0x31) && (ch <= 0x39)) return 0x0007001e + ch - 0x31;
      if (ch === 0x30) return 0x00070027; // zero
    }
    
    // "F1".."F12" => 0x3a..0x45
    // "F13".."F24" => 0x68..0x73
    if (((code.length === 2) || (code.length === 3)) && (code[0] === 'F')) {
      const v = +code.substring(1);
      if ((v >= 1) && (v <= 12)) return 0x0007003a + v - 1;
      if ((v >= 13) && (v <= 24)) return 0x00070068 + v - 13;
    }
    
    // "Numpad1".."Numpad9" => 0x59..0x61, again with zero on top because Jesus hates me.
    if ((code.length === 7) && code.startsWith("Numpad")) {
      const v = +code[7];
      if ((v >= 1) && (v <= 9)) return 0x00070059 + v - 1;
      if (v === 0) return 0x00070062;
    }
    
    // And finally a not-too-crazy set of one-off names.
    switch (code) {
      case "Enter":          return 0x00070028;
      case "Escape":         return 0x00070029;
      case "Backspace":      return 0x0007002a;
      case "Tab":            return 0x0007002b;
      case "Space":          return 0x0007002c;
      case "Minus":          return 0x0007002d;
      case "Equal":          return 0x0007002e;
      case "BracketLeft":    return 0x0007002f;
      case "BracketRight":   return 0x00070039;
      case "Backslash":      return 0x00070031;
      case "Semicolon":      return 0x00070033;
      case "Quote":          return 0x00070034;
      case "Backquote":      return 0x00070035;
      case "Comma":          return 0x00070036;
      case "Period":         return 0x00070037;
      case "Slash":          return 0x00070038;
      case "CapsLock":       return 0x00070039;
      case "Pause":          return 0x00070048;
      case "Insert":         return 0x00070049;
      case "Home":           return 0x0007004a;
      case "PageUp":         return 0x0007004b;
      case "Delete":         return 0x0007004c;
      case "PageDown":       return 0x0007004e;
      case "ArrowRight":     return 0x0007004f;
      case "ArrowLeft":      return 0x00070050;
      case "ArrowDown":      return 0x00070051;
      case "ArrowUp":        return 0x00070052;
      case "NumLock":        return 0x00070053;
      case "NumpadDivide":   return 0x00070054;
      case "NumpadMultiply": return 0x00070055;
      case "NumpadSubtract": return 0x00070056;
      case "NumpadAdd":      return 0x00070057;
      case "NumpadEnter":    return 0x00070058;
      case "NumpadDecimal":  return 0x00070063;
      case "ContextMenu":    return 0x00070076;
      case "ShiftLeft":      return 0x000700e1;
      case "ShiftRight":     return 0x000700e5;
      case "ControlLeft":    return 0x000700e0;
      case "ControlRight":   return 0x000700e4;
      case "AltLeft":        return 0x000700e2;
      case "AltRight":       return 0x000700e6;
    }
    return 0;
  }
  
  /* Accelerometer.
   **************************************************************************/
   
  accelerometerEnable() {
    this._accelerometerEnableInternal().then(() => {
      if (!this.accelListener) {
        this.accelListener = () => this.onAccelerometer();
        this.accel.addEventListener("reading", this.accelListener);
      }
      this.accel.start();
    }).catch(() => {});
  }
  
  _accelerometerEnableInternal() {
    if (this.accel) return Promise.resolve();
    if (!window.navigator.permissions) return Promise.reject();
    return window.navigator.permissions.query({ name: "accelerometer" }).then(result => {
      if (result.state === "denied") throw null;
      if (!this.accel) {
        this.accel = new Accelerometer({ referenceFrame: "device", frequency: 60 });
      }
    });
  }
  
  accelerometerDisable() {
    if (!this.accel) return;
    if (this.accelListener) {
      this.accel.removeEventListener("reading", this.accelListener);
      this.accelListener = null;
    }
    this.accel.stop();
  }
  
  onAccelerometer() {
    if (!this.accel) return;
    const x = ~~(this.accel.x * 65536.0);
    const y = ~~(this.accel.y * 65536.0);
    const z = ~~(this.accel.z * 65536.0);
    this.pushEvent([Input.EGG_EVENT_ACCEL, x, y, z]);
  }
  
  /*--------------------------- Public API entry points -----------------------------------*/
  
  egg_event_get(v, a) {
    const eventSizeWords = 5;//TODO Can we assert that this is sizeof(union egg_event)/sizeof(int)?
    const cpc = Math.min(a, this.evtq.length);
    if (cpc < 1) return 0;
    let dst = this.egg.exec.mem32;
    let dstp = v >> 2;
    for (let i=0; i<cpc; i++) {
      const e = this.evtq[i];
      for (let j=0; j<eventSizeWords; j++) {
        dst[dstp++] = e[j];
      }
    }
    this.evtq.splice(0, cpc);
    return cpc;
  }
  
  egg_event_enable(type, enable) {
    if (!type) return 0;
    const bit = 1 << type;
    if (enable) {
      if (this.evtmask & bit) return 1;
      this.evtmask |= bit;
    } else {
      if (!(this.evtmask & bit)) return 0;
      this.evtmask &= ~bit;
    }
    //TODO Reject changes if we can tell they aren't supported.
    switch (type) {
      case Input.EGG_EVENT_RAW: break;
      case Input.EGG_EVENT_JOY: break;
      case Input.EGG_EVENT_KEY: break;
      case Input.EGG_EVENT_TEXT: break;
      case Input.EGG_EVENT_MMOTION:
      case Input.EGG_EVENT_MBUTTON:
      case Input.EGG_EVENT_MWHEEL: {
          const mouseEvents = (1 << Input.EGG_EVENT_MMOTION) | (1 << Input.EGG_EVENT_MBUTTON) | (1 << Input.EGG_EVENT_MWHEEL);
          this._checkCursorVisibility(this.evtmask & mouseEvents);
        } break;
      case Input.EGG_EVENT_TOUCH: break;
      case Input.EGG_EVENT_ACCEL: {
          if (enable) {
            this.accelerometerEnable();
          } else {
            this.accelerometerDisable();
          }
        } break;
    }
    return enable ? 1 : 0;
  }
  
  egg_show_cursor(show) {
    this.cursorDesired = !!show;
    const mouseEvents = (1 << Input.EGG_EVENT_MMOTION) | (1 << Input.EGG_EVENT_MBUTTON) | (1 << Input.EGG_EVENT_MWHEEL);
    this._checkCursorVisibility(this.evtmask & mouseEvents);
  }
  
  egg_lock_cursor(lock) {
    if (!this.canvas || !this.canvas.requestPointerLock) return 0;
    if (lock) {
      if (this.mouseLocked) return 1;
      this.mouseLocked = true;
      this.canvas.requestPointerLock(/*{
        unadjustedMovement: true, // Not supported in Chrome/Linux, and the whole request gets rejected for it.
      }*/).then(rsp => {
      }).catch(e => {
        this.mouseLocked = false;
      });
    } else if (this.mouseLocked) {
      this.mouseLocked = false;
      document.exitPointerLock();
    }
    return 1;
  }
  
  egg_joystick_devid_by_index(p) {
    if (p < 0) return 0;
    for (let i=0; i<this.gamepads.length; i++) {
      if (!this.gamepads[i]) continue;
      if (!p--) return i + 1;
    }
    return 0;
  }
  
  egg_joystick_get_ids(vidp, pidp, verp, devid) {
    const local = this.gamepads[devid - 1];
    if (!local || (local.devid !== devid)) return;
    // Linux Chrome: Microsoft X-Box 360 pad (STANDARD GAMEPAD Vendor: 045e Product: 028e)
    // Not at all sure how standard that formatting is, but we don't have much else to go on...
    let vid=0, pid=0, version=0;
    let match;
    if (match = local.id.match(/Vendor: ([0-9a-fA-F]{4})/)) {
      vid = parseInt(match[1], 16);
    }
    if (match = local.id.match(/Product: ([0-9a-fA-F]{4})/)) {
      pid = parseInt(match[1], 16);
    }
    if (match = local.id.match(/Version: ([0-9a-fA-F]{4})/)) {
      // This one doesn't exist for me. And not sure whether they'd break it out as MAJOR.MINOR.REVISION.
      // 0xf000=MAJOR, 0x0f00=MINOR, 0x00ff=REVISION
      version = parseInt(match[1], 16);
    }
    if (vidp) this.egg.exec.mem32[vidp >> 2] = vid;
    if (pidp) this.egg.exec.mem32[pidp >> 2] = pid;
    if (verp) this.egg.exec.mem32[verp >> 2] = version;
  }
  
  egg_joystick_get_name(dst, dsta, devid) {
    const local = this.gamepads[devid - 1];
    if (!local || (local.devid !== devid)) return 0;
    const name = local.id.split('(')[0].trim();
    return name || local.id;
    return this.egg.exec.safeWrite(dst, dsta, name);
  }
  
  egg_joystick_for_each_button(devid, cb, ctx) {
    // int (*cb)(int btnid,int usage,int lo,int hi,int value,void *userdata)
    if (!(cb = this.egg.exec.fntab.get(cb))) return 0;

    const local = this.gamepads[devid - 1];
    if (!local || (local.devid !== devid)) return null;
    
    for (let i=0; i<local.axes.length; i++) {
      let hidusage = 0;
      if (local.mapping === "standard") {
        hidusage = Input.STANDARD_AXIS_USAGE[i] || 0;
      }
      const err = cb(local.axisBase + i, hidusage, -128, 127, 0, ctx);
      if (err) return err;
    }
    
    for (let i=0; i<local.buttons.length; i++) {
      let hidusage = 0x00090000 + i;
      if (local.mapping === "standard") {
        const alt = Input.STANDARD_BUTTON_USAGE[i];
        if (alt) hidusage = alt;
      }
      const err = cb(local.buttonBase + i, hidusage, 0, 1, 0, ctx);
    }
    
    return 0;
  }
}

Input.EGG_EVENT_JOY = 1;
Input.EGG_EVENT_KEY = 2;
Input.EGG_EVENT_TEXT = 3;
Input.EGG_EVENT_MMOTION = 4;
Input.EGG_EVENT_MBUTTON = 5;
Input.EGG_EVENT_MWHEEL = 6;
Input.EGG_EVENT_TOUCH = 7;
Input.EGG_EVENT_ACCEL = 8;
Input.EGG_EVENT_RAW = 9;

Input.EGG_JOYBTN_LX    = 0x40;
Input.EGG_JOYBTN_LY    = 0x41;
Input.EGG_JOYBTN_RX    = 0x42;
Input.EGG_JOYBTN_RY    = 0x43;
Input.EGG_JOYBTN_SOUTH = 0x80;
Input.EGG_JOYBTN_EAST  = 0x81;
Input.EGG_JOYBTN_WEST  = 0x82;
Input.EGG_JOYBTN_NORTH = 0x83;
Input.EGG_JOYBTN_L1    = 0x84;
Input.EGG_JOYBTN_R1    = 0x85;
Input.EGG_JOYBTN_L2    = 0x86;
Input.EGG_JOYBTN_R2    = 0x87;
Input.EGG_JOYBTN_AUX2  = 0x88;
Input.EGG_JOYBTN_AUX1  = 0x89;
Input.EGG_JOYBTN_LP    = 0x8a;
Input.EGG_JOYBTN_RP    = 0x8b;
Input.EGG_JOYBTN_UP    = 0x8c;
Input.EGG_JOYBTN_DOWN  = 0x8d;
Input.EGG_JOYBTN_LEFT  = 0x8e;
Input.EGG_JOYBTN_RIGHT = 0x8f;
Input.EGG_JOYBTN_AUX3  = 0x90;

Input.EGG_MBUTTON_LEFT = 1;
Input.EGG_MBUTTON_RIGHT = 2;
Input.EGG_MBUTTON_MIDDLE = 3;

Input.EGG_TOUCH_END = 0;
Input.EGG_TOUCH_BEGIN = 1;
Input.EGG_TOUCH_MOVE = 2;

Input.STANDARD_AXIS_USAGE = [
  0x00010030, // lx
  0x00010031, // ly
  0x00010033, // rx
  0x00010034, // ry
];

Input.STANDARD_BUTTON_USAGE = [
  0x00050037, // south
  0x00050037, // east
  0x00050037, // west
  0x00050037, // north
  0x00050039, // l1
  0x00050039, // r1
  0x00050039, // l2
  0x00050039, // r2
  0x0001003e, // select
  0x0001003d, // start
  0x00090000, // lp
  0x00090001, // rp
  0x00010090, // dup
  0x00010091, // ddown
  0x00010093, // dleft
  0x00010092, // dright
  0x00010085, // heart -- "System Main Menu", debatable.
];
// Do not edit! Generated from src/opt/synth/synth_builtin.c.
const Instruments = [
{"mode":"sub","subQ1":0,"subQ2":0,"subGain":1,"levelTiny":12},
0,
{"mode":"fmrel","fmRate":2,"fmRangeScale":4,"fmRangeEnv":36808,"levelTiny":132},
{"mode":"fmrel","fmRate":1.5,"fmRangeScale":4,"fmRangeEnv":65410,"levelTiny":139},
{"mode":"rock","wave":[0,0.5019607843137255,0.7529411764705882,0.25098039215686274,0.12549019607843137,0.03137254901960784],"mix":3968,"levelTiny":139},
{"mode":"fmabs","fmRate":128,"fmRangeScale":0.0625,"fmRangeEnv":3888,"levelTiny":84},
{"mode":"fmrel","fmRate":5,"fmRangeScale":5,"fmRangeEnv":65520,"levelTiny":5},
{"mode":"fmrel","fmRate":4,"fmRangeScale":5,"fmRangeEnv":36608,"levelTiny":69},
{"mode":"fmrel","fmRate":7.625,"fmRangeScale":8.4375,"fmRangeEnv":63610,"levelTiny":6},
{"mode":"fmrel","fmRate":3,"fmRangeScale":4,"fmRangeEnv":65524,"levelTiny":3},
{"mode":"fmrel","fmRate":6.125,"fmRangeScale":8,"fmRangeEnv":65412,"levelTiny":5},
{"mode":"fmrel","fmRate":4,"fmRangeScale":4,"fmRangeEnv":4084,"levelTiny":13},
{"mode":"fmrel","fmRate":8,"fmRangeScale":3,"fmRangeEnv":65524,"levelTiny":5},
null,
{"mode":"fmrel","fmRate":3.5,"fmRangeScale":6.4375,"fmRangeEnv":63743,"levelTiny":14},
{"mode":"fmrel","fmRate":6,"fmRangeScale":7,"fmRangeEnv":36740,"levelTiny":6},
{"mode":"rock","wave":[0,1,0.00784313725490196,0.3333333333333333,0.00392156862745098,0.2,0,0.06666666666666667],"mix":12172,"levelTiny":213},
{"mode":"rock","wave":[0,0,0.7529411764705882,0.01568627450980392,0.25098039215686274,0.00392156862745098],"mix":49908,"levelTiny":69},
{"mode":"rock","wave":[0,0.7529411764705882,0,0.3764705882352941,0,0.18823529411764706,0,0.09411764705882353],"mix":3972,"levelTiny":148},
{"mode":"rock","wave":[0,0.7529411764705882,0.6274509803921569,0.3764705882352941,0,0.18823529411764706,0,0.09411764705882353],"mix":65520,"levelTiny":158},
{"mode":"rock","wave":[0,0,0.48627450980392156,0.6470588235294118,0.5019607843137255,0.2,0.3764705882352941,0.06666666666666667,0],"mix":4080,"levelTiny":147},
16,
16,
16,
{"mode":"fmrel","fmRate":2,"fmRangeScale":1,"fmRangeEnv":20416,"levelTiny":5},
{"mode":"fx","fmRangeEnv":3968,"fmRangeLfo":0,"fmRangeLfoDepth":0,"fmRate":6,"fmRangeScale":7.5,"detuneRate":4,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.06274509803921569,"levelTiny":68},
{"mode":"fx","fmRangeEnv":4095,"fmRangeLfo":1,"fmRangeLfoDepth":0.5,"fmRate":2,"fmRangeScale":4,"detuneRate":4,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":0,"delayDepth":0,"levelTiny":68},
{"mode":"fx","fmRangeEnv":32644,"fmRangeLfo":2,"fmRangeLfoDepth":1,"fmRate":2,"fmRangeScale":4,"detuneRate":1,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":0.5,"delayDepth":0.25098039215686274,"levelTiny":76},
{"mode":"fx","fmRangeEnv":4080,"fmRangeLfo":2,"fmRangeLfoDepth":2,"fmRate":2,"fmRangeScale":4,"detuneRate":1,"detuneDepth":0.06274509803921569,"overdrive":0.06274509803921569,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":68},
{"mode":"fx","fmRangeEnv":65408,"fmRangeLfo":4,"fmRate":2,"fmRangeScale":3,"levelTiny":76,"detuneRate":4,"detuneDepth":0.00784313725490196,"overdrive":0.3764705882352941,"delayRate":1,"delayDepth":0.12549019607843137},
{"mode":"fx","fmRangeEnv":65348,"fmRangeLfo":2,"fmRangeLfoDepth":0.5,"fmRate":0.5,"fmRangeScale":3,"detuneRate":1,"detuneDepth":0.06274509803921569,"overdrive":0.8784313725490196,"delayRate":1,"delayDepth":0.06274509803921569,"levelTiny":93},
{"mode":"fx","fmRangeEnv":4080,"fmRangeLfo":0,"fmRangeLfoDepth":0,"fmRate":7.4375,"fmRangeScale":8,"detuneRate":1,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.06274509803921569,"levelTiny":93},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":4,"fmRangeEnv":63624,"levelTiny":221},
{"mode":"fx","fmRangeEnv":36804,"fmRangeLfo":2,"fmRangeLfoDepth":0.25,"fmRate":0.5,"fmRangeScale":2,"detuneRate":0,"detuneDepth":0,"overdrive":0,"delayRate":0,"delayDepth":0,"levelTiny":67},
{"mode":"wave","wave":[0,0.7529411764705882,0.7529411764705882,0.18823529411764706,0,0.06274509803921569,0.5019607843137255,0.25098039215686274,0.12549019607843137],"levelTiny":75},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":2,"fmRangeEnv":20352,"levelTiny":156},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":2.5,"fmRangeEnv":28513,"levelTiny":75},
{"mode":"rock","wave":[0,0.25098039215686274,1,0.7529411764705882,0.5019607843137255,0.25098039215686274,0.06274509803921569,0.03137254901960784,0.00784313725490196],"mix":3904,"levelTiny":84},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":3,"fmRangeEnv":20418,"levelTiny":82},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":5,"fmRangeEnv":36848,"levelTiny":76},
{"mode":"rock","wave":[0,0.12549019607843137,0.7529411764705882,0.4392156862745098,0.34509803921568627,0.25098039215686274,0.12549019607843137,0.03137254901960784],"mix":36800,"levelTiny":221},
{"mode":"rock","wave":[0,1,0.5019607843137255,0.3333333333333333,0.25098039215686274,0.2,0.12549019607843137,0.03137254901960784],"mix":36800,"levelTiny":221},
{"mode":"rock","wave":[0,0.25098039215686274,1,0.5019607843137255,0.3333333333333333,0.25098039215686274,0.2,0.12549019607843137,0.03137254901960784],"mix":36800,"levelTiny":220},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":4,"fmRangeEnv":63624,"levelTiny":221},
{"mode":"fx","fmRangeEnv":4036,"fmRangeLfo":0.5,"fmRangeLfoDepth":0.125,"fmRate":1,"fmRangeScale":2,"detuneRate":0,"detuneDepth":0,"overdrive":0,"delayRate":0,"delayDepth":0,"levelTiny":198},
{"mode":"fx","fmRangeEnv":4036,"fmRangeLfo":0.5,"fmRangeLfoDepth":0.5,"fmRate":1,"fmRangeScale":3,"detuneRate":0.25,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.06274509803921569,"levelTiny":5},
{"mode":"fx","fmRangeEnv":36804,"fmRangeLfo":0,"fmRangeLfoDepth":0,"fmRate":3,"fmRangeScale":3,"detuneRate":0.25,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":6},
{"mode":"sub","subQ1":83.33333333333333,"subQ2":96.66666666666667,"subGain":150,"levelTiny":11},
{"mode":"fx","fmRangeEnv":36804,"fmRangeLfo":4,"fmRangeLfoDepth":0.5,"fmRate":1.5,"fmRangeScale":2,"detuneRate":1,"detuneDepth":0.03137254901960784,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":213},
48,
{"mode":"fx","fmRangeEnv":53220,"fmRangeLfo":4,"fmRangeLfoDepth":0.5,"fmRate":0.5,"fmRangeScale":5,"detuneRate":1,"detuneDepth":0.03137254901960784,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":213},
48,
48,
48,
48,
48,
{"mode":"rock","wave":[0,0.12549019607843137,0.7529411764705882,0.3764705882352941,0.3137254901960784,0.25098039215686274,0.06274509803921569,0.03137254901960784,0.00784313725490196],"mix":61684,"levelTiny":219},
56,
56,
56,
56,
56,
56,
56,
{"mode":"fmrel","fmRate":4,"fmRangeScale":3,"fmRangeEnv":20418,"levelTiny":148},
64,
64,
64,
64,
64,
64,
{"mode":"rock","wave":[0,0.12549019607843137,0.5490196078431373,0.8784313725490196,0,0.45098039215686275,0,0.19215686274509805,0],"mix":255,"levelTiny":76},
"blip",
72,
{"mode":"wave","wave":[0,0.5019607843137255,0.06274509803921569,0.9607843137254902,0,0.2,0,0.06666666666666667,0.01568627450980392],"levelTiny":163},
72,
{"mode":"sub","subQ1":91.66666666666667,"subQ2":95,"subGain":45,"levelTiny":140},
{"mode":"fmrel","fmRate":4.1875,"fmRangeScale":1.5,"fmRangeEnv":3888,"levelTiny":84},
72,
{"mode":"fmrel","fmRate":2,"fmRangeScale":2.5,"fmRangeEnv":36608,"levelTiny":213},
{"mode":"wave","wave":[0,1,0,0.3333333333333333,0,0.2,0,0.06274509803921569],"levelTiny":139},
{"mode":"wave","wave":[0,1,0.5019607843137255,0.3333333333333333,0.25098039215686274,0.2,0.12549019607843137,0.06274509803921569,0.03137254901960784],"levelTiny":147},
{"mode":"rock","wave":[0,0,1,0.12549019607843137],"mix":3968,"levelTiny":141},
"blip",
{"mode":"rock","wave":[0,0,1,0.25098039215686274,0.12549019607843137,0.06274509803921569,0.03137254901960784],"mix":255,"levelTiny":140},
{"mode":"fmrel","fmRate":2.5,"fmRangeScale":2,"fmRangeEnv":63684,"levelTiny":220},
{"mode":"fmrel","fmRate":1.5,"fmRangeScale":4,"fmRangeEnv":36804,"levelTiny":156},
{"mode":"rock","wave":[0,0,0,0,1],"mix":52992,"levelTiny":148},
{"mode":"fx","fmRangeEnv":65535,"fmRangeLfo":8,"fmRangeLfoDepth":2,"fmRate":1,"fmRangeScale":1,"detuneRate":1,"detuneDepth":0.09411764705882353,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":199},
{"mode":"wave","wave":[0,1,0.06274509803921569,0.03137254901960784,0.00784313725490196],"levelTiny":195},
{"mode":"fx","fmRangeEnv":53056,"fmRangeLfo":4,"fmRangeLfoDepth":1,"fmRate":1,"fmRangeScale":4,"detuneRate":4,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":213},
{"mode":"sub","subQ1":86.66666666666667,"subQ2":91.66666666666667,"subGain":40,"levelTiny":220},
{"mode":"sub","subQ1":93.33333333333333,"subQ2":86.66666666666667,"subGain":30,"levelTiny":213},
{"mode":"fx","fmRangeEnv":65520,"fmRangeLfo":4,"fmRangeLfoDepth":0.25,"fmRate":7.375,"fmRangeScale":3,"detuneRate":8,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.03137254901960784,"levelTiny":214},
{"mode":"rock","wave":[0,0,1,0.12549019607843137,0.06274509803921569,0.03137254901960784,0.01568627450980392,0.00784313725490196,0.00392156862745098],"mix":1264,"levelTiny":222},
{"mode":"fx","fmRangeEnv":65535,"fmRangeLfo":4,"fmRangeLfoDepth":2,"fmRate":4,"fmRangeScale":3,"detuneRate":4,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.03137254901960784,"levelTiny":214},
{"mode":"fx","fmRangeEnv":36848,"fmRangeLfo":8,"fmRangeLfoDepth":8,"fmRate":3.5,"fmRangeScale":6,"detuneRate":0,"detuneDepth":0,"overdrive":0,"delayRate":0.5,"delayDepth":0.6274509803921569,"levelTiny":19},
96,
96,
96,
96,
{"mode":"fx","fmRangeEnv":36848,"fmRangeLfo":4,"fmRangeLfoDepth":4,"fmRate":0.5,"fmRangeScale":4,"detuneRate":0,"detuneDepth":0,"overdrive":0.25098039215686274,"delayRate":1,"delayDepth":0.5019607843137255,"levelTiny":83},
{"mode":"fx","fmRangeEnv":61695,"fmRangeLfo":4,"fmRangeLfoDepth":8,"fmRate":2,"fmRangeScale":1,"detuneRate":1,"detuneDepth":0.12549019607843137,"overdrive":0,"delayRate":0.5,"delayDepth":0.6274509803921569,"levelTiny":83},
{"mode":"fx","fmRangeEnv":4095,"fmRangeLfo":8,"fmRangeLfoDepth":1.5,"fmRate":2,"fmRangeScale":6,"detuneRate":1,"detuneDepth":0.03137254901960784,"overdrive":0.03137254901960784,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":205},
"blip",
104,
104,
104,
104,
104,
104,
104,
{"mode":"fmrel","fmRate":9,"fmRangeScale":10,"fmRangeEnv":65423,"levelTiny":6},
{"mode":"fmrel","fmRate":5.4375,"fmRangeScale":4,"fmRangeEnv":65535,"levelTiny":5},
{"mode":"fmrel","fmRate":5.5,"fmRangeScale":4,"fmRangeEnv":61695,"levelTiny":13},
{"mode":"fmrel","fmRate":1.5,"fmRangeScale":2,"fmRangeEnv":4095,"levelTiny":2},
{"mode":"fmrel","fmRate":0.25,"fmRangeScale":3,"fmRangeEnv":61695,"levelTiny":13},
{"mode":"fmrel","fmRate":1.5,"fmRangeScale":3.5,"fmRangeEnv":63728,"levelTiny":11},
{"mode":"fx","fmRangeLfo":0.625,"fmRangeLfoDepth":2,"fmRate":0.5,"fmRangeScale":2,"fmRangeEnv":65408,"detuneRate":0.5,"detuneDepth":0.01568627450980392,"levelTiny":3},
112,
{"mode":"fmrel","fmRate":5.5,"fmRangeScale":10,"fmRangeEnv":63631,"levelTiny":28},
{"mode":"sub","subQ1":86.66666666666667,"subQ2":86.66666666666667,"subGain":30,"levelTiny":91},
{"mode":"sub","subQ1":33.33333333333333,"subQ2":66.66666666666666,"subGain":5,"levelTiny":223},
{"mode":"fmabs","fmRate":128,"fmRangeScale":1.125,"fmRangeEnv":62464,"levelTiny":77},
{"mode":"fmabs","fmRate":256,"fmRangeScale":0.5,"fmRangeEnv":53184,"levelTiny":27},
{"mode":"fmabs","fmRate":128,"fmRangeScale":1,"fmRangeEnv":4080,"levelTiny":141},
"blip",
null,
];
/* ImageDecoder.js
 * Would be awesome if we could use browser facilities for this but alas
 * that is not possible because we have to be synchronous.
 * We could add image formats. But I think we'll advise devs to use PNG exclusively.
 */
 

 
class ImageDecoder {
  constructor() {
  }
  
  /* Returns {w,h,stride,fmt} or throws.
   * We reject images larger than 32767 on either axis, even if otherwise valid.
   */
  decodeHeader(src) {
    if (this.isPng(src)) return this.decodeHeaderPng(src);
    throw new Error(`Image format unknown`);
  }
  
  /* Returns {w,h,stride,fmt,v:Uint8Array} or throws.
   * We reject images larger than 32767 on either axis, even if otherwise valid.
   */
  decode(src) {
    if (this.isPng(src)) return this.decodePng(src);
    throw new Error(`Image format unknown`);
  }
  
  /* PNG.
   ***************************************************************************/
   
  isPng(src) {
    return (
      (src.length >= 8) &&
      (src[0] === 0x89) &&
      (src[1] === 0x50) &&
      (src[2] === 0x4e) &&
      (src[3] === 0x47) &&
      (src[4] === 0x0d) &&
      (src[5] === 0x0a) &&
      (src[6] === 0x1a) &&
      (src[7] === 0x0a)
    );
  }
   
  decodeHeaderPng(src) {
    // We require IHDR to be the first chunk.
    // The spec does say that, but I've seen violations before.
    if (src.length < 26) throw new Error("Invalid PNG");
    const w = (src[16] << 24) | (src[17] << 16) | (src[18] << 8) | src[19];
    const h = (src[20] << 24) | (src[21] << 16) | (src[22] << 8) | src[23];
    if ((w < 1) || (h < 1) || (w > 0x7fff) || (h > 0x7fff)) throw new Error("Invalid PNG");
    let depth = src[24];
    const colortype = src[25];
    switch (colortype) {
      case 0: break;
      case 2: depth *= 3; break;
      case 3: break;
      case 4: depth *= 2; break;
      case 6: depth *= 4; break;
      default: throw new Error("Invalid PNG");
    }
    let fmt;
    switch (depth) {
      case 1: fmt = 3; break;
      case 8: fmt = 2; break;
      case 32: fmt = 1; break;
      // Anything that isn't 1, 8, or 32 bits/pixel, we coerce to 32 at decode.
      case 2: case 4: case 16: case 24: case 48: case 64: fmt = 1; depth = 32; break;
      default: throw new Error("Invalid PNG");
    }
    const stride = (w * depth + 7) >> 3;
    return {w, h, stride, fmt};
  }
  
  decodePng(src) {
    const chunks = this.dechunkPng(src);
    const ihdr = this.decodePngIhdr(chunks.ihdr);
    let fmt;
    switch (ihdr.pixelsize) {
      case 32: fmt = 1; break;
      case 8: fmt = 2; break;
      case 1: fmt = 3; break;
      default: fmt = 0; // force RGBA after preliminary decode
    }
    const filtered = new Zlib.Inflate(chunks.idat).decompress();
    let dst = new Uint8Array(ihdr.stride * ihdr.h);
    this.unfilterPng(dst, filtered, ihdr.stride, ihdr.xstride);
    if (!fmt) {
      const rgbastride = ihdr.w << 2;
      const rgba = new Uint8Array(rgbastride * ihdr.h);
      this.forceRgba(rgba, rgbastride, dst, ihdr, chunks.plte);
      dst = rgba;
      ihdr.stride = rgbastride;
      fmt = 1;
    }
    return {
      w: ihdr.w,
      h: ihdr.h,
      stride: ihdr.stride,
      fmt,
      v: dst,
    };
  }
  
  dechunkPng(src) {
    const chunks = {};
    for (let srcp=8; srcp<src.length; ) {
      const len = (src[srcp] << 24) | (src[srcp+1] << 16) | (src[srcp+2] << 8) | src[srcp+3];
      srcp += 4;
      const cid = (src[srcp] << 24) | (src[srcp+1] << 16) | (src[srcp+2] << 8) | src[srcp+3];
      srcp += 4;
      switch (cid) {
        case 0x49484452: chunks.ihdr = src.slice(srcp, srcp + len); break;
        case 0x504c5445: chunks.plte = src.slice(srcp, srcp + len); break;
        case 0x49444154: { // IDAT
            if (chunks.idat) {
              const nv = new Uint8Array(chunks.idat.length + len);
              nv.set(chunks.idat);
              const dstview = new Uint8Array(nv.buffer, chunks.idat.length, len);
              dstview.set(src.slice(srcp, srcp + len));
              chunks.idat = nv;
            } else {
              chunks.idat = src.slice(srcp, srcp + len);
            }
          } break;
      }
      srcp += len;
      srcp += 4;
    }
    return chunks;
  }
  
  decodePngIhdr(src) {
    if (!src || (src.length < 13)) throw new Error("Invalid PNG");
    const w = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
    const h = (src[4] << 24) | (src[5] << 16) | (src[6] << 8) | src[7];
    if ((w < 1) || (h < 1) || (w > 0x7fff) || (h > 0x7fff)) throw new Error("Invalid PNG");
    const depth = src[8];
    const colortype = src[9];
    if (src[10] || src[11] || src[12]) {
      // We're not supporting interlaced PNG. Compression and filter, there's only one defined for each.
      throw new Error(`Unsupported PNG compression, filter, or interlace (${src[10]}, ${src[11]}, ${src[12]}`);
    }
    let pixelsize = depth;
    switch (colortype) {
      case 0: break;
      case 2: pixelsize *= 3; break;
      case 3: break;
      case 4: pixelsize *= 2; break;
      case 6: pixelsize *= 4; break;
      default: throw new Error("Invalid PNG");
    }
    const xstride = Math.max(1, pixelsize >> 3);
    const stride = (pixelsize * w + 7) >> 3;
    return { w, h, stride, depth, colortype, pixelsize, xstride };
  }
  
  unfilterPng(dst, src, dststride, xstride) {
    const srcstride = 1 + dststride;
    let dstp=0, srcp=0, dstppv=0;
    const paeth = (a, b, c) => {
      const p = a + b - c;
      const pa = Math.abs(p - a);
      const pb = Math.abs(p - b);
      const pc = Math.abs(p - c);
      if ((pa <= pb) && (pa <= pc)) return a;
      if (pb <= pc) return b;
      return c;
    };
    while (dstp < dst.length) {
      const filter = src[srcp++];
      if (dstp) dstppv = dstp - dststride;
      switch (filter) {
        case 0: {
            for (let i=dststride; i-->0; dstp++, srcp++) dst[dstp] = src[srcp];
          } break;
        case 1: {
            let i=0;
            for (; i<xstride; i++, dstp++, srcp++) dst[dstp] = src[srcp];
            for (; i<dststride; i++, dstp++, srcp++) dst[dstp] = src[srcp] + dst[dstp-xstride];
          } break;
        case 2: {
            if (dstp) {
              for (let i=dststride; i-->0; dstp++, dstppv++, srcp++) dst[dstp] = src[srcp] + dst[dstppv];
            } else {
              for (let i=dststride; i-->0; dstp++, srcp++) dst[dstp] = src[srcp];
            }
          } break;
        case 3: {
            let i=0;
            if (dstp) {
              for (; i<xstride; i++, dstp++, srcp++, dstppv++) dst[dstp] = src[srcp] + (dst[dstppv] >> 1);
              for (; i<dststride; i++, dstp++, srcp++, dstppv++) dst[dstp] = src[srcp] + ((dst[dstp-xstride] + dst[dstppv]) >> 1);
            } else {
              for (; i<xstride; i++, dstp++, srcp++) dst[dstp] = src[srcp];
              for (; i<dststride; i++, dstp++, srcp++) dst[dstp] = src[srcp] + (dst[dstp-xstride] >> 1);
            }
          } break;
        case 4: {
            let i=0;
            if (dstp) {
              for (; i<xstride; i++, dstp++, srcp++, dstppv++) dst[dstp] = src[srcp] + dst[dstppv];
              for (; i<dststride; i++, dstp++, srcp++, dstppv++) dst[dstp] = src[srcp] + paeth(dst[dstp-xstride], dst[dstppv], dst[dstppv-xstride]);
            } else { // PAETH is exactly SUB on the first row, but it is legal.
              for (; i<xstride; i++, dstp++, srcp++) dst[dstp] = src[srcp];
              for (; i<dststride; i++, dstp++, srcp++) dst[dstp] = src[srcp] + dst[dstp-xstride];
            }
          } break;
      }
    }
  }
  
  forceRgba(dst, dststride, src, ihdr, plte) {
    for (
      let dstrowp=0, yi=ihdr.h, srciter=this.iteratePng(src, ihdr, plte);
      yi-->0;
      dstrowp+=dststride
    ) {
      for (let dstp=dstrowp, xi=ihdr.w; xi-->0; ) {
        const rgba = srciter();
        dst[dstp++] = rgba >> 24;
        dst[dstp++] = rgba >> 16;
        dst[dstp++] = rgba >> 8;
        dst[dstp++] = rgba;
      }
    }
  }
  
  // Returns a function that returns every pixel LRTB as 32-bit big-endian RGBA.
  // TODO We're not accepting tRNS chunks. Should we?
  iteratePng(src, ihdr, plte) {
    let rowp=0, p=0, xi=ihdr.w, yi=ihdr.h, mask=0x80, shift;
    
    if (plte && (ihdr.colortype === 3)) { // INDEX
      switch (ihdr.depth) {
        case 1: return () => {
            if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; mask = 0x80; } xi--;
            let ix = (src[p] & mask) ? 1 : 0;
            ix *= 3;
            if (mask === 1) { mask = 0x80; p++; }
            else mask >>= 1;
            return (plte[ix] << 24) | (plte[ix+1] << 16) | (plte[ix+2] << 8) | 0xff;
          };
        case 2: shift = 6; return () => {
            if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; shift = 6; } xi--;
            let ix = (src[p] >> shift) & 3;
            ix *= 3;
            if (shift) shift -= 2;
            else { shift = 6; p++; }
            return (plte[ix] << 24) | (plte[ix+1] << 16) | (plte[ix+2] << 8) | 0xff;
          };
        case 4: shift = 4; return () => {
            if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; shift = 4; } xi--;
            let ix = (src[p] >> shift) & 15;
            ix *= 3;
            if (shift) shift = 0;
            else { shift = 6; p++; }
            return (plte[ix] << 24) | (plte[ix+1] << 16) | (plte[ix+2] << 8) | 0xff;
          };
        case 8: return () => {
            if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
            let ix = src[p++];
            ix *= 3;
            return (plte[ix] << 24) | (plte[ix+1] << 16) | (plte[ix+2] << 8) | 0xff;
          };
      }
      
    } else switch (ihdr.colortype) {
      case 0: case 3: switch (ihdr.depth) { // GRAY (or INDEX with missing PLTE)
          case 1: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; mask = 0x80; } xi--;
              const luma = (src[p] & mask) ? 0xff : 0;
              if (mask === 1) { mask = 0x80; p++; }
              else mask >>= 1;
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
          case 2: shift = 6; return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; shift = 6; } xi--;
              let luma = (src[p] >> shift) & 3;
              luma |= luma << 2;
              luma |= luma << 4;
              if (shift) shift -= 2;
              else { shift = 6; p++; }
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
          case 4: shift = 4; return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; shift = 4; } xi--;
              let luma = (src[p] >> shift) & 15;
              luma |= luma << 4;
              if (shift) shift = 0;
              else { shift = 6; p++; }
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
          case 8: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const luma = src[p++];
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
          case 16: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const luma = src[p];
              p += 2;
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
        } break;
      case 2: switch (ihdr.depth) { // RGB
          case 8: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const r = src[p++];
              const g = src[p++];
              const b = src[p++];
              return (r << 24) | (g << 16) | (b << 8) | 0xff;
            };
          case 16: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const r = src[p++]; p++;
              const g = src[p++]; p++;
              const b = src[p++]; p++;
              return (r << 24) | (g << 16) | (b << 8) | 0xff;
            };
        } break;
      case 4: switch (ihdr.depth) { // YA
          case 8: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const luma = src[p++];
              const alpha = src[p++];
              return (luma << 24) | (luma << 16) | (luma << 8) | alpha;
            };
          case 16: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const luma = src[p++]; p++;
              const alpha = src[p++]; p++;
              return (luma << 24) | (luma << 16) | (luma << 8) | alpha;
            };
        } break;
      case 6: switch (ihdr.depth) { // RGBA
          case 8: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const r = src[p++];
              const g = src[p++];
              const b = src[p++];
              const a = src[p++];
              return (r << 24) | (g << 16) | (b << 8) | a;
            };
          case 16: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const r = src[p++]; p++;
              const g = src[p++]; p++;
              const b = src[p++]; p++;
              const a = src[p++]; p++;
              return (r << 24) | (g << 16) | (b << 8) | a;
            };
        } break;
    }
    return () => 0;
  }
}
 /* Audio.js
 * Implements our synthesizer and exposes the public API.
 */




 
class Audio {
  constructor(egg) {
    this.egg = egg;
    
    this.rate = 44100; // TODO configurable?
    this.context = null;
    this.song = null;
    this.channels = [
      null, null, null, null,
      null, null, null, null,
      null, null, null, null,
      null, null, null, null,
    ];
    this.voices = [];
    this.sounds = {}; // key:"QUAL.RID", value:AudioBuffer
    this.soundEffects = [];
    this.noise = null; // AudioBuffer, null until we need it.
    
    this.hzByNoteid = [];
    for (let noteid=0; noteid<0x80; noteid++) {
      this.hzByNoteid.push(440 * Math.pow(2, (noteid - 69) / 12));
    }
  }
  
  start() {
    if (!window.AudioContext) return;
    this.context = new window.AudioContext({
      sampleRate: this.rate,
      latencyHint: "interactive",
    });
    if (this.context.state === "suspended") {
      this.context.resume();
    }
  }
  
  stop() {
    this.endSong();
    //TODO
  }
  
  update() {
    for (let i=this.voices.length; i-->0; ) {
      const voice = this.voices[i];
      if (!voice.isFinished()) continue;
      voice.terminate();
      this.voices.splice(i, 1);
    }
    if (this.song) {
      this.song.update();
    }
  }
  
  /* Public API.
   *****************************************************************/
  
  egg_audio_play_song(qual, songid, force, repeat) {
    if (!force && this.song && this.song.isResource(qual, songid)) return;
    this.endSong();
    const serial = this.egg.rom.getRes(Rom.RESTYPE_song, qual, songid);
    if (!serial || !serial.length) return;
    try {
      this.song = new Song(serial, this, repeat, qual, songid);
    } catch (e) {
      console.error(`Failed to play song:${qual}:${songid}.`, e);
      return;
    }
    this.beginSong();
  }
  
  egg_audio_play_sound(qual, soundid, trim, pan, when) {
    if (!this.context) return;
    trim /= 65536;
    pan /= 65536;
    if (!when) when = this.context.currentTime;
    const pcm = this.acquireSound(qual, soundid);
    if (!pcm) return;
    const node = new AudioBufferSourceNode(this.context, {
      buffer: pcm,
      channelCount: 1,
    });
    const gain = new GainNode(this.context, { gain: trim });
    node.connect(gain);
    gain.connect(this.context.destination);
    node.start(when);
    this.soundEffects.push(node);
    node.onended = () => {
      const p = this.soundEffects.indexOf(node);
      if (p >= 0) this.soundEffects.splice(p, 1);
    };
  }
  
  egg_audio_event(chid, opcode, a, b) {
    console.log(`TODO egg_audio_event`, { chid, opcode, a, b });
  }
  
  egg_audio_get_playhead() {//TODO
    return -1;
  }
  
  egg_audio_set_playhead(beat) {//TODO
  }
  
  /* Internals.
   ******************************************************************/
   
  endSong() {
    if (!this.song) return;
    this.song = null;
    for (const voice of this.voices) voice.release();
    for (let chid=0; chid<8; chid++) {
      if (this.channels[chid]) {
        this.channels[chid].stop();
        this.channels[chid] = null;
      }
    }
    //TODO Cancel scheduled notes.
  }
  
  beginSong() {
    if (!this.song) return;
    for (let i=0; i<8; i++) {
      this.channels[i] = null;
      const src = this.song.channels[i];
      if (!src.volume) continue;
      this.channels[i] = new Channel(this, src.pid, src.volume, src.pan);
    }
  }
  
  acquireSound(qual, rid) {
    if (!this.context) return null;
    const key = `${qual}.${rid}`;
    if (key in this.sounds) return this.sounds[key];
    let v = null;
    const serial = this.egg.rom.getRes(Rom.RESTYPE_sound, qual, rid);
    if (serial && serial.length) {
      const fv = new SfgPrinter(serial, this.rate).print();
      if (fv && fv.length) {
        v = new AudioBuffer({
          length: fv.length,
          numberOfChannels: 1,
          sampleRate: this.rate,
          channelCount: 1,
        });
        v.copyToChannel(fv, 0);
      }
    }
    this.sounds[key] = v;
    return v;
  }
  
  // (velocity) in 0..127 like MIDI. (when) in AudioContext time.
  playNote(chid, noteid, velocity, durs, when) {
    const channel = this.channels[chid];
    //console.log(`Audio.playNote`, { chid, noteid, velocity, durs, when, channel });
    if (!channel) return;
    channel.playNote(this, noteid, velocity / 127.0, durs, when);
  }
  
  // (v) in 0..0x3fff like MIDI. (when) in AudioContext time.
  changeWheel(chid, v, when) {
    const channel = this.channels[chid];
    if (!channel) return;
    if (!channel.wheelRange) return;
    if (v === channel.wheel) return;
    channel.wheel = v;
    channel.wheelCents = ((v - 0x2000) * channel.wheelRange) / 0x2000;
    //TODO Apply to in-flight voices. Must respect (when) too!
  }
  
  requireNoise() {
    if (this.noise) return;
    const fv = new Float32Array(this.rate);
    for (let i=fv.length; i-->0; ) fv[i] = Math.random() * 2 - 1;
    this.noise = new AudioBuffer({
      length: fv.length,
      numberOfChannels: 1,
      sampleRate: this.rate,
      channelCount: 1,
    });
    this.noise.copyToChannel(fv, 0);
  }
}

/* Song.
 **********************************************************************/
 
const SONG_READAHEAD_WINDOW_S = 0.500;
 
class Song {
  constructor(src, audio, repeat, qual, songid) {
    this.audio = audio;
    this.repeat = repeat;
    this.qual = qual;
    this.songid = songid;
    if (!(src instanceof Uint8Array)) throw new Error(`Expected Uint8Array`);
    if (src.length < 42) throw new Error(`Invalid song`);
    if ((src[0] !== 0xbe) || (src[1] !== 0xee) || (src[2] !== 0xee) || (src[3] !== 0x50)) throw new Error(`Invalid song`);
    this.msperqnote = (src[4] << 8) | src[5];
    this.startp = (src[6] << 8) | src[7];
    this.loopp = (src[8] << 8) | src[9];
    if ((this.startp < 42) || (this.loopp < this.startp) || (this.loopp >= src.length)) throw new Error(`Invalid song`);
    this.src = src;
    this.channels = [];
    for (let srcp=10; srcp<42; srcp+=4) {
      this.channels.push({
        pid: src[srcp],
        volume: src[srcp+1],
        pan: src[srcp+2],
        rsv: src[srcp+3],
      });
    }
    this.startTime = audio.context.currentTime;
    this.readp = this.startp;
    this.readTime = this.startTime;
  }
  
  isResource(qual, songid) {
    return ((qual === this.qual) && (songid === this.songid));
  }
  
  update() {
    const now = this.audio.context.currentTime;
    const later = now + SONG_READAHEAD_WINDOW_S;
    while (this.readTime < later) {
      const event = this.readEvent();
      
      // End of song?
      if (!event) {
        this.audio.endSong();
        return;
      }
      
      // Delay?
      if (typeof(event) === "number") {
        this.readTime += event;
        continue;
      }
      
      // Anything else, readEvent() dispatched it. Carry on.
    }
  }
  
  /* Advance readp and return one event:
   *  - null: EOF and not repeating.
   *  - number: Delay, seconds. Never zero.
   *  - "ok": Processed one event (we dispatch it from here).
   */
  readEvent() {
    const lead = this.src[this.readp++];
    
    // Zero or end of input is End of Song.
    if (!lead) {
      if (!this.repeat) return null;
      this.readp = this.loopp;
      // Must delay a little, in case the song has no explicit delays, so we don't loop forever.
      // Note that if this happens, it's a disaster no matter what.
      return 0.010;
    }
    
    // High bit unset is a delay in ms.
    if (!(lead & 0x80)) {
      return lead / 1000;
    }

    // 1000vvvv cccnnnnn nntttttt : NOTE. duration=(t<<5)ms (~2s max)
    if ((lead & 0xf0) === 0x80) {
      const a = this.src[this.readp++] || 0;
      const b = this.src[this.readp++] || 0;
      let velocity = (lead & 0x0f) << 3;
      velocity |= velocity >> 4;
      const chid = a >> 5;
      const noteid = ((a & 0x1f) << 2) | (b >> 6);
      const durms = ((b & 0x3f) << 5);
      this.audio.playNote(chid, noteid, velocity, durms / 1000, this.readTime);
      return "ok";
    }
    
    // 1001vvcc cnnnnnnn : FIREFORGET. Same as NOTE but duration zero (and coarser velocity).
    if ((lead & 0xf0) === 0x90) {
      const a = this.src[this.readp++] || 0;
      let velocity = ((lead & 0x0c) << 2);
      velocity |= velocity >> 2;
      velocity |= velocity >> 4;
      const chid = ((lead & 0x03) << 1) | (a >> 7);
      const noteid = (a & 0x7f);
      this.audio.playNote(chid, noteid, velocity, 0, this.readTime);
      return "ok";
    }
    
    // 10100ccc wwwwwwww : WHEEL. 8 bits unsigned. 0x40 by default.
    if ((lead & 0xf8) === 0xa0) {
      const a = this.src[this.readp++] || 0;
      const chid = lead & 0x07;
      const v = (a << 6) | (a >> 2);
      this.audio.changeWheel(chid, v, this.readTime);
      return "ok";
    }
    
    // Anything else is reserved and illegal. End the song.
    console.log(`Illegal song command ${lead}.`);
    return null;
  }
}

/* Channel.
 *********************************************************************/
 
class Channel {
  constructor(audio, pid, volume, pan) {
    this.audio = audio;
    this.pid = pid;
    this.volume = volume / 255.0;
    this.master = 0.250;
    this.pan = (pan - 0x80) / 128.0;
    this.mode = "noop";
    this.wheelRange = 200; // cents
    this.wheel = 0; // Last value, 0..0x3fff
    this.wheelCents = 0;
    
    if (this.pid < 0x00) this._initNoop();
    else if (this.pid < 0x80) this._initBuiltin(audio);
    else if (this.pid < 0x100) this._initDrum();
    else this._initNoop();
  }
  
  _initNoop() {
    this.mode = "noop";
    this.wheelRange = 0;
  }
  
  _initDrum() {
    this.mode = "drum";
    this.wheelRange = 0;
    this.drumBase = (this.pid - 0x80) * 0x80;
  }
  
  _initBuiltin(audio) {
    let cfg = Instruments[this.pid];
    if (typeof(cfg) === "number") {
      cfg = Instruments[cfg];
    }
    if (!cfg) return this._initNoop();
    if (typeof(cfg) === "string") {
      this.mode = cfg;
      return;
    }
    for (const k of Object.keys(cfg)) {
      this[k] = cfg[k];
    }
    if (this.wave) {
      this.wave = new PeriodicWave(audio.context, { real: this.wave });
    }
    if (this.mode === "fx") {
      this.fxBegin(audio);
    }
  }
  
  // (velocity) normalized
  playNote(audio, noteid, velocity, durs, when) {
    switch (this.mode) {
      case "noop": break;
      
      case "drum": {
          const soundid = this.drumBase + noteid;
          const trim = 0.200 + (this.volume * this.master * velocity) * 0.900;
          audio.egg_audio_play_sound(0, soundid, trim * 65536.0, this.pan, when);
        } break;
        
      case "blip": {
          const attackTime = 0.010;
          const releaseTime = 0.050;
          const level = this.volume * this.master * (velocity + 0.079) * 0.400;
          const voice = new Voice(audio);
          voice.oscillateShape("square", audio.hzByNoteid[noteid], this.wheelCents);
          voice.plateauLevel(when, attackTime, level, durs, releaseTime);
          voice.begin();
        } break;
        
      case "wave": {
          const voice = new Voice(audio);
          voice.oscillateWave(this.wave, audio.hzByNoteid[noteid], this.wheelCents);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
        } break;
        
      case "rock": {
          const voice = new Voice(audio);
          voice.oscillateMix(this.wave, this.mix, audio.hzByNoteid[noteid], this.wheelCents);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
        } break;
        
      case "fmrel": {
          const voice = new Voice(audio);
          voice.oscillateFmRelative(audio.hzByNoteid[noteid], this.wheelCents, this.fmRate, this.fmRangeScale, this.fmRangeEnv);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
        } break;
        
      case "fmabs": {
          const voice = new Voice(audio);
          voice.oscillateFmAbsolute(audio.hzByNoteid[noteid], this.wheelCents, this.fmRate, this.fmRangeScale, this.fmRangeEnv);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
        } break;
        
      case "sub": {
          const voice = new Voice(audio);
          voice.oscillateSubtractive(audio.hzByNoteid[noteid], this.wheelCents, this.subQ1, this.subQ2, this.subGain);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
        } break;
        
      case "fx": {
          this.fxNote(audio, when, noteid, velocity, durs);
        } break;
    }
  }
  
  stop() {
    switch (this.mode) {
      case "fx": this.fxStop(); break;
    }
  }
  
  fxBegin(audio) {
    this.audio = audio;
    this.fxMaster = new GainNode(audio.context);
    this.fxMaster.gain.setValueAtTime(this.volume * this.master, 0);
    this.fxMaster.connect(audio.context.destination);
    this.fxVoices = [];
    this.fxAttach = this.fxMaster;
    
    //TODO detune. Can't do it in post like the C implementation, but I think we can vary the voice's frequencies.
    
    if ((this.fmRangeLfo > 0) && (this.fmRangeLfoDepth > 0)) {
      let beatRate = 2;
      if (this.audio.song && (this.audio.song.msperqnote > 0)) {
        beatRate = 1000 / this.audio.song.msperqnote;
      }
      const osc = new OscillatorNode(this.audio.context, {
        type: "sine",
        frequency: beatRate / this.fmRangeLfo,
      });
      const gain = new GainNode(this.audio.context, {
        gain: this.fmRangeLfoDepth * 100, // TODO No idea why this *100 is needed.
      });
      osc.connect(gain);
      osc.start();
      this.fmLfo = osc;
      this.fmLfoOut = gain;
    }
    
    if ((this.delayRate > 0) && (this.delayDepth > 0) && this.audio.song && (this.audio.song.msperqnote > 0)) {
      const wetLevel = this.delayDepth * 0.500;
      const dryLevel = 1 - wetLevel;
      const period = (this.delayRate * this.audio.song.msperqnote) / 1000;
      const delay = new DelayNode(this.audio.context, { delayTime: period });
      
      const intake = new GainNode(this.audio.context, { gain: 1 });
      const output = new GainNode(this.audio.context, { gain: 1 });
      const dryGain = new GainNode(this.audio.context, { gain: dryLevel });
      const wetGain = new GainNode(this.audio.context, { gain: wetLevel });
      intake.connect(dryGain);
      dryGain.connect(output);
      intake.connect(delay);
      delay.connect(wetGain);
      wetGain.connect(delay);
      wetGain.connect(output);
      output.connect(this.fxAttach);
      this.fxAttach = intake;
    }
    
    if (this.overdrive > 0) {
      const len = 99;
      const odrange = 8;
      const midp = len >> 1;
      const odscaled = 0.5 + this.overdrive * (odrange - 0.5);
      const odcurved = 1 / odscaled; // Now in (1/odrange)..2
      const odnormed = (odcurved - 1 / odrange) / (2 - 1 / odrange);
      const ramplen = midp * odnormed;
      const vv = new Float32Array(len);
      for (let i=0; i<ramplen; i++) {
        vv[midp + i + 1] = Math.sin((i * Math.PI / 2) / ramplen);
      }
      for (let i=midp+ramplen+1; i<len; i++) {
        vv[i] = 1;
      }
      for (let dst=midp, src=midp+1; dst-->0; src++) {
        vv[dst] = -vv[src];
      }
      const shaper = new WaveShaperNode(this.audio.context, {
        curve: vv,
      });
      // Also some attenuation, after the wave-shape, since we're raising its average level.
      if (this.overdrive >= 0.25) {
        const drop = new GainNode(this.audio.context, {
          gain: 1 - (this.overdrive - 0.25) * 0.8,
        });
        shaper.connect(drop);
        drop.connect(this.fxAttach);
      } else {
        shaper.connect(this.fxAttach);
      }
      this.fxAttach = shaper;
    }
  }
  
  fxStop() {
    if (this.fxMaster) {
      this.fxMaster.disconnect();
      this.fxMaster = null;
    }
    if (this.fmLfo) {
      this.fmLfo.stop();
      this.fmLfo.disconnect();
      this.fmLfo = null;
    }
    if (this.fmLfoOut) {
      this.fmLfoOut.disconnect();
      this.fmLfoOut = null;
    }
  }
  
  fxNote(audio, when, noteid, velocity, durs) {
    const voice = new Voice(this.audio);
    voice.oscillateFmRelative(this.audio.hzByNoteid[noteid], this.wheelCents, this.fmRate, this.fmRangeScale, this.fmRangeEnv, this.fmLfoOut);
    voice.tinyEnv(when, this.levelTiny, durs, velocity, 1);
    voice.begin(this.fxAttach);
  }
}

/* Voice.
 *******************************************************************/
 
class Voice {
  constructor(audio) {
    this.audio = audio;
    this.osc = null;
    this.env = null;
    this.endTime = 0;
  }
  
  isFinished() {
    if (!this.audio || !this.audio.context || !this.env) return true;
    return (this.audio.context.currentTime > this.endTime);
  }
  
  terminate() {
    if (this.env) {
      this.env.disconnect();
      this.env = null;
    }
    if (this.osc) {
      if (this.osc.stop) this.osc.stop();
      this.osc.disconnect();
      this.osc = null;
    }
    if (this.oscDry) {
      this.oscDry.stop();
      this.oscDry.disconnect();
      this.oscDry = null;
    }
    if (this.oscWet) {
      this.oscWet.stop();
      this.oscWet.disconnect();
      this.oscWet = null;
    }
    if (this.modosc) {
      this.modosc.stop();
      this.modosc.disconnect();
      this.modosc = null;
    }
    if (this.noiseNode) {
      this.noiseNode.stop();
      this.noiseNode.disconnect();
      this.noiseNode = null;
    }
    if (this.post) {
      this.post.disconnect();
      this.post = null;
    }
  }
  
  release() {
  }
  
  begin(dst) {
    if (!this.audio || !this.env) return;
    if (!dst) dst = this.audio.context.destination;
    if (this.osc) {
      this.osc.connect(this.env);
      if (this.osc.start) this.osc.start();
    } else if (this.gainDry) {
      this.gainDry.connect(this.env);
      this.gainWet.connect(this.env);
      this.oscDry.start();
      this.oscWet.start();
    } else {
      return;
    }
    if (this.post) this.post.connect(dst);
    else this.env.connect(dst);
    this.audio.voices.push(this);
  }
  
  oscillateShape(type, frequency, detune) {
    this.osc = new OscillatorNode(this.audio.context, {
      type,
      frequency,
      detune,
    });
  }
  
  oscillateWave(periodicWave, frequency, detune) {
    this.osc = new OscillatorNode(this.audio.context, {
      periodicWave,
      frequency,
      detune,
    });
  }
  
  // (mix) is 4 levels, 4 bits each, big-endian. eg 0xf842 = [1.0, 0.5, 0.25, 0.125]
  oscillateMix(periodicWave, mix, frequency, detune) {
    this.oscDry = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency,
      detune,
    });
    this.oscWet = new OscillatorNode(this.audio.context, {
      periodicWave,
      frequency,
      detune,
    });
    this.gainDry = new GainNode(this.audio.context);
    this.gainWet = new GainNode(this.audio.context);
    this.oscDry.connect(this.gainDry);
    this.oscWet.connect(this.gainWet);
    this.mix = mix;
  }
  
  oscillateFmRelative(frequency, detune, rate, scale, env, lfo) {
    this.osc = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency,
      detune,
    });
    this.modosc = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency: frequency * rate * Math.pow(2, detune / 1200),
    });
    this.modgain = new GainNode(this.audio.context);
    if (lfo) {
      this.fmGainLfo = lfo;
      this.fmGainLfo.connect(this.modgain.gain);
      this.modgain.gain.setValueAtTime(1, 0);
      this.modgain.connect(this.osc.frequency);
    } else {
      this.modgain.connect(this.osc.frequency);
    }
    this.modgainPeak = scale * frequency;
    this.fmRangeEnv = env;
    this.modosc.connect(this.modgain);
    this.modosc.start();
  }
  
  oscillateFmAbsolute(frequency, detune, rate, scale, env) {
    this.osc = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency,
      detune,
    });
    this.modosc = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency: rate,
    });
    this.modgain = new GainNode(this.audio.context);
    this.modgainPeak = scale * frequency;
    this.fmRangeEnv = env;
    this.modgain.connect(this.osc.frequency);
    this.modosc.connect(this.modgain);
    this.modosc.start();
  }
  
  oscillateSubtractive(frequency, detune, q1, q2, gain) {
    this.audio.requireNoise();
    this.noiseNode = new AudioBufferSourceNode(this.audio.context, {
      buffer: this.audio.noise,
      channelCount: 1,
      loop: true,
      loopStart: 0,
      loopEnd: this.audio.noise.duration,
    });
    const filter1 = new BiquadFilterNode(this.audio.context, {
      type: "bandpass",
      Q: q1,
      frequency,
    });
    const filter2 = new BiquadFilterNode(this.audio.context, {
      type: "bandpass",
      Q: q2,
      frequency,
    });
    const gainNode = new GainNode(this.audio.context);
    gainNode.gain.setValueAtTime(gain, 0);
    this.noiseNode.connect(filter1);
    filter1.connect(filter2);
    filter2.connect(gainNode);
    this.osc = gainNode;
    this.noiseNode.start();
  }
  
  plateauLevel(when, attackTimeRel, peakLevel, sustainTimeRel, releaseTimeRel) {
    this.endTime = when + attackTimeRel + sustainTimeRel + releaseTimeRel;
    this.env = new GainNode(this.audio.context);
    this.env.gain.setValueAtTime(0, 0);
    this.env.gain.setValueAtTime(0, when);
    this.env.gain.linearRampToValueAtTime(peakLevel, when + attackTimeRel);
    this.env.gain.setValueAtTime(peakLevel, when + attackTimeRel + sustainTimeRel);
    this.env.gain.linearRampToValueAtTime(0, this.endTime);
  }
  
  /* A format I use in the C implementation for single-byte level envelopes:
   *   0xc0 Decay relative to attack:
   *         0x00 IMPULSE: Do not sustain.
   *         0x40 PLUCK: Heavy loss after attack.
   *         0x80 TONE: Attack noticeably louder than sustain.
   *         0xc0 BOW: No appreciable attack.
   *   0x38 Attack time: 0x00=Fast .. 0x38=Slow
   *   0x07 Release time: 0x00=Short .. 0x07=Long
   */
  tinyEnv(when, v, durs, velocity, trim) {
    let attackTimeHi;
    switch (v & 0x38) {
      case 0x00: attackTimeHi = 0.005; break;
      case 0x08: attackTimeHi = 0.008; break;
      case 0x10: attackTimeHi = 0.012; break;
      case 0x18: attackTimeHi = 0.018; break;
      case 0x20: attackTimeHi = 0.030; break;
      case 0x28: attackTimeHi = 0.045; break;
      case 0x30: attackTimeHi = 0.060; break;
      case 0x38: attackTimeHi = 0.080; break;
    }
    let releaseTimeHi;
    switch (v & 0x07) {
      case 0x00: releaseTimeHi = 0.040; break;
      case 0x01: releaseTimeHi = 0.060; break;
      case 0x02: releaseTimeHi = 0.100; break;
      case 0x03: releaseTimeHi = 0.200; break;
      case 0x04: releaseTimeHi = 0.400; break;
      case 0x05: releaseTimeHi = 0.600; break;
      case 0x06: releaseTimeHi = 0.800; break;
      case 0x07: releaseTimeHi = 1.200; break;
    }
    let sustain = true;
    let attackValueHi = 1;
    let sustainValueHi;
    switch (v & 0xc0) {
      case 0x00: { // IMPULSE
          sustain = false;
          sustainValueHi = 0.250;
        } break;
      case 0x40: { // PLUCK
          sustainValueHi = 0.200;
        } break;
      case 0x80: { // TONE
          attackValueHi = 0.750;
          sustainValueHi = 0.400;
        } break;
      case 0xc0: { // BOW
          attackValueHi = 0.400;
          sustainValueHi = 0.400;
        } break;
    }
    let decayTimeHi = (attackTimeHi * 3) / 2;
    const attackTimeLo = attackTimeHi * 2;
    const decayTimeLo = decayTimeHi * 2;
    const releaseTimeLo = releaseTimeHi * 0.5;
    const attackValueLo = attackValueHi * 0.333;
    const sustainValueLo = sustainValueHi * 0.500;
    let a, b;
    if (velocity <= 0) { a=1; b=0; }
    else if (velocity >= 1) { a=0; b=1; }
    else { a = 1 - velocity; b = velocity; }
    const attackTime = attackTimeLo * a + attackTimeHi * b;
    const attackValue = (attackValueLo * a + attackValueHi * b) * trim;
    const decayTime = decayTimeLo * a + decayTimeHi * b;
    const sustainValue = (sustainValueLo * a + sustainValueHi * b) * trim;
    if (!sustain) durs = 0;
    const releaseTime = releaseTimeLo * a + releaseTimeHi * b;
    this.endTime = when + attackTime + decayTime + durs + releaseTime;
    
    this.env = new GainNode(this.audio.context);
    this.env.gain.setValueAtTime(0, 0);
    this.env.gain.setValueAtTime(0, when);
    this.env.gain.linearRampToValueAtTime(attackValue, when + attackTime);
    this.env.gain.linearRampToValueAtTime(sustainValue, when + attackTime + decayTime);
    this.env.gain.setValueAtTime(sustainValue, when + attackTime + decayTime + durs);
    this.env.gain.linearRampToValueAtTime(0, this.endTime);
    
    if (this.gainDry && this.gainWet) {
      const v0 = (this.mix >> 12) / 15.0;
      const v1 = ((this.mix >> 8) & 15) / 15.0;
      const v2 = ((this.mix >> 4) & 15) / 15.0;
      const v3 = (this.mix & 15) / 15.0;
      this.gainDry.gain.setValueAtTime(0, 0);
      this.gainDry.gain.setValueAtTime(1 - v0, when);
      this.gainDry.gain.linearRampToValueAtTime(1 - v1, when + attackTime);
      this.gainDry.gain.linearRampToValueAtTime(1 - v2, when + attackTime + decayTime);
      this.gainDry.gain.linearRampToValueAtTime(1 - v2, when + attackTime + decayTime + durs);
      this.gainDry.gain.linearRampToValueAtTime(1 - v3, this.endTime);
      this.gainWet.gain.setValueAtTime(0, 0);
      this.gainWet.gain.setValueAtTime(v0, when);
      this.gainWet.gain.linearRampToValueAtTime(v1, when + attackTime);
      this.gainWet.gain.linearRampToValueAtTime(v2, when + attackTime + decayTime);
      this.gainWet.gain.linearRampToValueAtTime(v2, when + attackTime + decayTime + durs);
      this.gainWet.gain.linearRampToValueAtTime(v3, this.endTime);
    }
    
    if (this.fmRangeEnv && !this.fmRangeLfo) {
      if (this.fmRangeEnv === 0xffff) {
        this.modgain.gain.setValueAtTime(this.modgainPeak, 0);
      } else {
        const v0hi = (this.modgainPeak * (this.fmRangeEnv >> 12)) / 15.0;
        const v1hi = (this.modgainPeak * ((this.fmRangeEnv >> 8) & 15)) / 15.0;
        const v2hi = (this.modgainPeak * ((this.fmRangeEnv >> 4) & 15)) / 15.0;
        const v3hi = (this.modgainPeak * (this.fmRangeEnv & 15)) / 15.0;
        const avg = (v0hi + v1hi + v2hi + v3hi) / 4;
        const v0lo = (v0hi + avg) / 2;
        const v1lo = (v1hi + avg) / 2;
        const v2lo = (v2hi + avg) / 2;
        const v3lo = (v3hi + avg) / 2;
        const v0 = v0lo * (1 - velocity) + v0hi * velocity;
        const v1 = v1lo * (1 - velocity) + v1hi * velocity;
        const v2 = v2lo * (1 - velocity) + v2hi * velocity;
        const v3 = v3lo * (1 - velocity) + v3hi * velocity;
        this.modgain.gain.setValueAtTime(v0, 0);
        this.modgain.gain.setValueAtTime(v0, when);
        this.modgain.gain.linearRampToValueAtTime(v1, when + attackTime);
        this.modgain.gain.linearRampToValueAtTime(v2, when + attackTime + decayTime);
        this.modgain.gain.setValueAtTime(v2, when + attackTime + decayTime + durs);
        this.modgain.gain.linearRampToValueAtTime(v3, this.endTime);
      }
    }
  }
}
/* SysExtra.js
 * Little helpers for the public API. Log, date, language...
 */
 
class SysExtra {
  constructor(window) {
    this.window = window;
    this.storage = null;
    this.storageKey = "egg"; // Set before the first access.
  }
  
  /* Returns:
   * {
   *   srcc: Length of (src) consumed.
   *   align: -1|0|1.
   *   fill: ' ' or '0'.
   *   len: integer or "*" to read from vargs.
   *   prec: integer or "*" to read from vargs, <0 if unspecified.
   *   value: null, you fill in from vargs.
   *   spec: Single character.
   * }
   * Or null if malformed.
   */
  parseLogFormatUnit(src, srcp) {
    const srcp0 = srcp;
    if (srcp >= src.length) return null;
    if (src[srcp++] !== '%') return null;
    
    let align = 1;
    if (src[srcp] === '-') {
      align = -1;
      srcp++;
    } else if (src[srcp] === '+') {
      align = 1;
      srcp++;
    } else if (src[srcp] === '=') {
      align = 0;
      srcp++;
    }
    
    let fill = ' ';
    if (src[srcp] === '0') {
      fill = '0';
      srcp++;
    }
    
    let len = 0;
    if (src[srcp] === '*') {
      len = '*';
      srcp++;
    } else while ((src[srcp] >= '0') && (src[srcp] <= '9')) {
      len *= 10;
      len += src.charCodeAt(srcp) - 0x30;
      srcp++;
    }
    
    let prec = -1;
    if (src[srcp] === '.') {
      srcp++;
      if (src[srcp] === '*') {
        prec = '*';
        srcp++;
      } else {
        prec = 0;
        while ((src[srcp] >= '0') && (src[srcp] <= '9')) {
          prec *= 10;
          prec += src.charCodeAt(srcp) - 0x30;
          srcp++;
        }
      }
    }
    
    let spec;
    switch (src[srcp]) {
      case 'd':
      case 'x':
      case 'p':
      case 'l':
      case 'f':
      case 's':
      case 'c': {
          spec = src[srcp];
          srcp++;
        } break;
      default: return null;
    }
    return { srcc: srcp - srcp0, fill, align, len, prec, spec, value: null };
  }
  
  applyLogFormatUnit(unit) {
    let pre = "";
    switch (unit.spec) {
      case 'u': pre = (~~unit.value || 0).toString(); break;
      case 'd': pre = (~~unit.value || 0).toString(); break;
      case 'x': pre = (~~unit.value || 0).toString(16); break;
      case 'p': pre = (~~unit.value || 0).toString(16); break;
      case 'l': pre = (~~unit.value || 0).toString(); break;
      case 'f': pre = (+unit.value).toString(); break; // TODO prec
      case 's': pre = (unit.value || "").toString(); if (unit.prec >= 0) pre = pre.substring(0, unit.prec); break;
      case 'c': pre = String.fromCharCode(~~unit.value || 0x3f); break;
    }
    let spaces = "                              ";
    if (unit.fill === '0') {
      spaces = "0000000000000000000000000000000000";
    }
    if (pre.length < unit.len) switch (unit.align) {
      case -1: pre += spaces.substring(0, unit.len - pre.length); break;
      case 0: {
          const addc = unit.len - pre.length;
          const each = addc >> 1;
          const more = addc & 1;
          pre = spaces.substring(0, each) + pre +spaces.substring(0, each + more);
        } break;
      case 1: pre = spaces.substring(0, unit.len - pre.length) + pre; break;
    }
    return pre;
  }
  
  /* (vargs) can be an array of values or an iterator function: (spec:[udxplfsc],prec) => any
   */
  applyLogFormat(fmt, vargs) {
    if (!fmt) return "";
    if (!vargs) return fmt;
    let fmtp=0, vargsp=0, dst="";
    while (fmtp < fmt.length) {
      let nextp = fmt.indexOf('%', fmtp);
      if (nextp < 0) nextp = fmt.length;
      if (nextp > fmtp) {
        dst += fmt.substring(fmtp, nextp);
        fmtp = nextp;
        if (fmtp >= fmt.length) break;
      }
      if (fmt[fmtp + 1] === '%') {
        dst += "%";
        fmtp += 2;
        continue;
      }
      const unit = this.parseLogFormatUnit(fmt, fmtp);
      if (!unit) {
        dst += fmt[fmtp++];
        continue;
      }
      fmtp += unit.srcc;
      if (typeof(vargs) === "function") {
        if (unit.len === "*") unit.len = vargs('u');
        if (unit.prec === "*") unit.prec = vargs('u');
        unit.value = vargs(unit.spec, unit.prec);
      } else {
        if (unit.len === "*") unit.len = vargs[vargsp++] || 0;
        if (unit.prec === "*") unit.prec = vargs[vargsp++] || 0;
        unit.value = vargs[vargsp++];
      }
      dst += this.applyLogFormatUnit(unit);
    }
    return dst;
  }
  
  getUserLanguages() {
    let list = this.window.navigator.languages;
    if (list && (list.length > 0)) {
      list = Array.from(new Set(list.map(l => this.evalLang(l)).filter(v => v)));
    }
    if (!list) list = [];
    if (!list.length) {
      const code = this.evalLang(this.window.navigator.language);
      if (code) list.push(code);
    }
    return list;
  }
  
  evalLang(src) {
    if (!src) return 0;
    if (src.length >= 2) {
      let a = src.charCodeAt(0);
      let b = src.charCodeAt(1);
      if ((a >= 0x61) && (a <= 0x7a)) a = a - 0x61 + 6;
      else if ((a >= 0x30) && (a <= 0x35)) a = a - 0x30;
      else return 0;
      if ((b >= 0x61) && (b <= 0x7a)) b = b - 0x61 + 6;
      else if ((b >= 0x30) && (b <= 0x35)) b = b - 0x30;
      else return 0;
      return (a << 5) | b;
    }
    return 0;
  }
}
/* Egg.js
 * Top level coordinator for the Egg Web Runtime.
 * You must provide a valid Rom at construction.
 */
 








 
class Egg {
  constructor(rom) {
    this.rom = rom;
    this.data = new DataService(this);
    this.sysExtra = new SysExtra(window);
    this.input = new Input(this);
    this.audio = new Audio(this);
    this.imageDecoder = new ImageDecoder();
    this.canvas = null;
    this.render = null;
    this.exec = null;
    this.running = false;
    this.loaded = false;
    this.pvtime = 0;
    this.pendingFrame = null;
    this.restoreTitle = document.title;
    this.directgl = false;
  }
  
  attachToDom() {
    const body = document.body;
    body.innerHTML = "";
    
    // Optional "terminate" button. XXX This shouldn't be in the final product; whoever embeds us should provide this.
    const terminate = document.createElement("INPUT");
    terminate.setAttribute("type", "button");
    terminate.setAttribute("value", "Terminate");
    terminate.addEventListener("click", () => this.stop());
    terminate.style.display = "block";
    body.appendChild(terminate);
    
    this.canvas = document.createElement("CANVAS");
    this.setCanvasSize();
    body.appendChild(this.canvas);
    this.render = new Render(this);
    this.exec = new Exec(this);
    this.retitlePerRom();
  }
  
  setCanvasSize() {
    const match = this.data.getMetadata("framebuffer").match(/^(\d+)x(\d+)\s?(.*)/);
    if (!match) throw new Error("ROM does not declare its framebuffer size.");
    this.canvas.width = +match[1];
    this.canvas.height = +match[2];
    this.directgl = false;
    for (const token of match[3].split(/\s+/)) {
      if (token === "gl") this.directgl = true;
    }
    this.input.canvasChanged();
  }
  
  retitlePerRom() {
    document.title = this.data.getMetadata("title");
    let url = "";
    const iconImageId = +this.data.getMetadata("iconImage");
    if (iconImageId) {
      const serial = this.rom.getRes(Rom.RESTYPE_image, 0, iconImageId);
      if (serial.length > 0) {
        const crop = new Uint8Array(serial.length);
        crop.set(serial);
        const blob = new Blob([crop.buffer], { type: "image/png" });
        url = URL.createObjectURL(blob);
      }
    }
    for (const link of window.document.querySelectorAll("link[rel='icon']")) link.remove();
    if (url) {
      const link = window.document.createElement("LINK");
      link.setAttribute("data-egg-favicon", "");
      link.setAttribute("rel", "icon");
      link.setAttribute("type", "image/png");
      link.setAttribute("href", url);
      window.document.head.appendChild(link);
    }
  }
  
  retitleDefault() {
    document.title = this.restoreTitle;
    for (const link of window.document.querySelectorAll("link[rel='icon']")) link.remove();
  }
  
  start() {
    if (this.running) return;
    this.running = true;
    this.loaded = false;
    this.pvtime = 0;
    this.audio.start();
    return this.exec.load().then(() => {
      this.loaded = true;
      if (this.exec.egg_client_init() < 0) {
        throw new Error("Game aborted during startup.");
      }
      this.exec.egg_client_init = () => -1;
      this.pendingFrame = window.requestAnimationFrame(() => this.update());
    });
  }
  
  stop() {
    if (!this.running) return;
    this.audio.stop();
    this.input.detach();
    this.running = false;
    if (this.loaded) {
      this.exec.egg_client_quit();
      this.exec.egg_client_quit = () => {};
      this.loaded = false;
    }
    if (this.pendingFrame) {
      window.cancelAnimationFrame(this.pendingFrame);
      this.pendingFrame = null;
    }
    if (this.render) this.render.stop();
    this.retitleDefault();
  }
  
  update() {
    this.pendingFrame = null;
    if (!this.running) return;
    this.audio.update();
    this.input.update();
    const elapsed = this.tick();
    if (elapsed >= 0) {
      this.exec.egg_client_update(elapsed);
      if (!this.running) return;
      this.render.begin();
      this.exec.egg_client_render();
      this.render.end();
    }
    this.pendingFrame = window.requestAnimationFrame(() => this.update());
  }
  
  tick() {
    if (!this.pvtime) { // Very first update only, we update with zero time elapsed.
      this.pvtime = Date.now();
      return 0;
    }
    const now = Date.now();
    let elapsed = (now - this.pvtime) / 1000;
    if (elapsed < 0.015) return -1; // skip a frame (eg high-frequency monitors, don't let us run at 200 Hz or whatever)
    this.pvtime = now;
    return Math.min(0.050, elapsed); // Very long elapsed time, clamp at 50 ms.
  }
  
  /*------------------------ Public API entry points ------------------------*/
  
  egg_log(fmt, vargs) {
    const msg = this.sysExtra.applyLogFormat(
      this.exec.readCString(fmt),
      (spec, prec) => { // udxplfsc
        switch (spec) {
          case 'u': case 'd': case 'x': case 'c': case 'p': {
              const v = this.exec.mem32[vargs >> 2] || 0;
              vargs += 4;
              return v;
            }
          case 'l': {
              const v = this.exec.mem32[vargs >> 2] | (this.exec.mem32[(vargs+4) >> 2] * 4294967296);
              vargs += 8;
              return v;
            }
          case 'f': {
              if (vargs & 7) vargs = (vargs + 8) & ~7;
              const v = this.exec.memf64[vargs >> 3];
              vargs += 8;
              return v;
            }
          case 's': {
              let v;
              const p = this.exec.mem32[vargs >> 2];
              if (prec >= 0) v = this.exec.readLimitedString(p, prec);
              else v = this.exec.readCString(p);
              vargs += 4;
              return v;
            }
        }
      }
    );
    console.log(`GAME: ${msg}`);
  }
  
  egg_time_local(v, a) {
    if (a < 1) return;
    v >>= 2;
    const now = new Date();
    this.exec.mem32[v++] = now.getFullYear();
    if (a < 2) return;
    this.exec.mem32[v++] = 1 + now.getMonth();
    if (a < 3) return;
    this.exec.mem32[v++] = now.getDate();
    if (a < 4) return;
    this.exec.mem32[v++] = now.getHours();
    if (a < 5) return;
    this.exec.mem32[v++] = now.getMinutes();
    if (a < 6) return;
    this.exec.mem32[v++] = now.getSeconds();
    if (a < 7) return;
    this.exec.mem32[v++] = now.getMilliseconds();
  }
  
  egg_get_user_languages(v, a) {
    const src = this.sysExtra.getUserLanguages();
    const cpc = Math.min(a, src.length);
    for (let i=0, dstp=v>>2; i<cpc; i++, dstp++) {
      this.exec.mem32[dstp] = src[i];
    }
    return src.length;
  }
  
  egg_res_get(dst, dsta, tid, qual, rid) {
    const serial = this.rom.getRes(tid, qual, rid);
    return this.exec.safeWrite(dst, dsta, serial);
  }
  
  egg_res_for_each(cb, ctx) {
    if (!(cb = this.exec.fntab.get(cb))) return 0;
    for (const { tid, qual, rid, v } of this.rom.resv) {
      const err = cb(tid, qual, rid, v.length, ctx);
      if (err) return err;
    }
    return 0;
  }
}
</script>
</head>
<body>
</body>
</html>

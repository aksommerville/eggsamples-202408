<!DOCTYPE html>
<html>
<head>
<style>
canvas {
width: 1280px;
image-rendering: pixelated;
background-color: #000;
}
</style>
<egg-rom style="display:none">
r74(7k0FCXRpdGxlTGlnaHRzIE9uCAF0aXRsZVN0cjIGDmF1dGhvckFLIFNvbW1lcnZpbGxlCQp0aW1lc3RhbXAyMDI0LTA1LTEyCwdm
cmFtZWJ1ZmZlcjMyMHgxODAJAWljb25JbWFnZTEIAmxhbmd1YWdlZW4)t0r10c46(AGFzbQEAAAAB2AEdYAJ/fwF/YAF/AGACf38AYAJ/fABgBn9/
f39/fwBgBH9/f38Bf2AHf39/f39/fwF/YAABf2AEf39/fwBgBX9/f39/AX9gAAF8YAN/f38AYAl/f39/f39/f38AYAt/f39/f39/
f39/fwBgAX8Bf2ADf39/AX9gAXwAYAAAYAZ/f39/f38Bf2AKf39/f39/f39/fwF/YAl/f39/f39/f38Bf2AIf39/f39/f38Bf2AF
f39/f38AYAF8AXxgAnx8AXxgAnx/AXxgAXwBf2ACf38BfGADf398AX8CgQclA2VudhRlZ2dfaW1hZ2VfZ2V0X2hlYWRlcgAEA2Vu
dhBlZ2dfaW1hZ2VfZGVjb2RlAAUDZW52EmVnZ190ZXh0dXJlX3VwbG9hZAAGA2Vudg9lZ2dfdGV4dHVyZV9uZXcABwNlbnYPZWdn
X3RleHR1cmVfZGVsAAEDZW52FmVnZ190ZXh0dXJlX2dldF9oZWFkZXIACANlbnYPZWdnX3JlbmRlcl90aW50AAEDZW52EGVnZ19y
ZW5kZXJfYWxwaGEAAQNlbnYNZWdnX2RyYXdfdGlsZQAIA2VudhBlZ2dfcmVzX2Zvcl9lYWNoAAADZW52FmVnZ19nZXRfdXNlcl9s
YW5ndWFnZXMAAANlbnYLZWdnX3Jlc19nZXQACQNlbnYNZWdnX3RpbWVfcmVhbAAKA2VudgdlZ2dfbG9nAAIDZW52DWVnZ19kcmF3
X3JlY3QABANlbnYNZWdnX2RyYXdfbGluZQALA2Vudg1lZ2dfZHJhd190cmlnAAsDZW52DmVnZ19kcmF3X2RlY2FsAAwDZW52FGVn
Z19kcmF3X2RlY2FsX21vZGU3AA0DZW52G2VnZ19qb3lzdGlja19kZXZpZF9ieV9pbmRleAAOA2VudhBlZ2dfZXZlbnRfZW5hYmxl
AAADZW52FGVnZ19qb3lzdGlja19nZXRfaWRzAAgDZW52HGVnZ19qb3lzdGlja19mb3JfZWFjaF9idXR0b24ADwNlbnYVZWdnX2pv
eXN0aWNrX2dldF9uYW1lAA8DZW52D2VnZ19sb2NrX2N1cnNvcgAOA2Vudg5lZ2dfdGltZV9sb2NhbAACA2VudhZlZ2dfdGV4dHVy
ZV9sb2FkX2ltYWdlAA8DZW52DWVnZ19zdG9yZV9nZXQABQNlbnYNZWdnX3N0b3JlX3NldAAFA2VudhZlZ2dfc3RvcmVfa2V5X2J5
X2luZGV4AA8DZW52D2VnZ19hdWRpb19ldmVudAAIA2VudhZlZ2dfYXVkaW9fZ2V0X3BsYXloZWFkAAoDZW52E2VnZ19hdWRpb19w
bGF5X3NvbmcACANlbnYUZWdnX2F1ZGlvX3BsYXlfc291bmQACANlbnYWZWdnX2F1ZGlvX3NldF9wbGF5aGVhZAAQA2VudhdlZ2df
cmVxdWVzdF90ZXJtaW5hdGlvbgARA2Vudg1lZ2dfZXZlbnRfZ2V0AAADrQGrAREBDg8ODg4SEg8TCQAUFBUIARYWDw8HCQUAAAcB
Dw8PDw4PFxcXGBkYGBcXGRkXFxoOAQAABwERDgEDAgsOAQMCAQ4BAQACAwEPAgMBBQAbBQ8cDgEDAgEJAQ4BAwIBAgcBDgEDAgES
Cw4BDgEDAgEOARwOAQMCAQ4BAwIBDgEBDgEDAQgOAQEDDgEDAgEJCQ4BDgEDAgEOAgEBAgEJDgEDAgEOAREBBxEQEQQFAXABSEgF
BAEAwQIGCQF/AUGApYAKCwd2BgZtZW1vcnkCABlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQAPZWdnX2NsaWVudF9xdWl0AMoB
D2VnZ19jbGllbnRfaW5pdADMARFlZ2dfY2xpZW50X3VwZGF0ZQDOARFlZ2dfY2xpZW50X3JlbmRlcgDPAQmDAQEAQQELRzxeX2Bj
ZGVmaHl6e3x9gAGBAYIBgwGGAXFwb4gBiQGKAYsBjAGPAZEBkgGTAZQBlgGZAZoBmwGcAZ4BnwGgAaEBowGkAaYBpwGoAasBrAGt
Aa8BsAGxAbIBswG0AbYBuAG5AboBuwG9Ab4BvwHAAcEBwgHEAcUBxgHHAckBCqXfA6sBAgALpAEBA38CQCAARQ0AAkAgACgCCCIB
RQ0AIAAgACgCDCICQX9qIgM2AgwCQCACQQFIDQADQAJAIAEgA0EcbGoiASgCFCIDRQ0AIAMQ14CAgAALAkAgASgCGCIBRQ0AIAEQ
14CAgAALIAAgACgCDCIBQX9qIgM2AgwCQCABQQFIDQAgACgCCCEBDAELCyAAKAIIIQELIAEQ14CAgAALIAAQ14CAgAALCzgBAn9B
ACEBAkAgAEEBSA0AQQFBFBDZgICAACICRQ0AIAIgADYCACACIABBAXY2AgQgAiEBCyABC7wJARp/I4CAgIAAQRBrIgMkgICAgAAC
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
DQADQCADQQJ0QbSYgIAAaiIFKAIAIgBFDQECQAJAIABBAUgNACAAIANqIQYMAQsCQCACQQAgAGsiAEgNAANAIAAgA2oiBkECdEG0
mICAAGooAgAiB0F/Sg0CIAAgB2siACACTA0ACwsgBSAANgIAQQAgACADajYCsJiAgAAgBUEEaiEBDAMLIAYhAyAGIARIDQALCyAE
Qf///wFKDQBBgICAAiAEayACTA0AIARBAnRBtJiAgABqIAJBAWoiADYCAEEAQQAoAqyYgIAAIgcgAGoiADYCrJiAgAAgB0ECdEG4
mICAAGohASAAQf///wFKDQAgAEECdEG0mICAAGpBADYCACABDwsgAQtlAQN/AkAgAEG0mICAAGsiAEGDgIB4akGHgIB4SQ0AIABB
AnYiAEF/aiIBQQJ0QbSYgIAAaiICKAIAIgNBAUgNACACQQAgA2s2AgAgAEEAKAKwmICAAEoNAEEAIAE2ArCYgIAACwueBwEKfwJA
AkAgAA0AQQAhAiABQf///wdLDQEgAUEDakECdiEDQQAhAgJAQQAoArCYgIAAIgRBACgCrJiAgAAiBU4NAANAIARBAnRBtJiAgABq
IgYoAgAiAEUNAQJAAkAgAEEBSA0AIAAgBGohBwwBCwJAIANBACAAayIASA0AA0AgACAEaiIHQQJ0QbSYgIAAaigCACIBQX9KDQIg
ACABayIAIANMDQALCyAGIAA2AgBBACAAIARqNgKwmICAACAGQQRqDwsgByEEIAcgBUgNAAsLIAVB////AUoNAUGAgIACIAVrIANM
DQEgBUECdEG0mICAAGogA0EBaiIANgIAQQBBACgCrJiAgAAiASAAaiIANgKsmICAACABQQJ0QbiYgIAAaiECIABB////AUoNASAA
QQJ0QbSYgIAAakEANgIAIAIPC0EAIQIgAUH///8HSw0AIABBtJiAgABrIgRBg4CAeGpBh4CAeEkNACAEQQJ1IghBf2oiBUECdEG0
mICAAGoiBigCACIEQQFIDQACQCABQQNqQQJ2IgMgBE8NACAADwsCQAJAA0AgBCAFaiIHQf///wFKDQIgB0ECdEG0mICAAGooAgAi
B0EASg0CIAdFDQEgBiAEIAdrIgQ2AgAgAyAETg0ACyAADwtBgYCAAiAIayADTA0AIAYgA0EBajYCAEEAIAggA2oiATYCrJiAgAAC
QCABQf///wFMDQAgAA8LIAFBAnRBtJiAgABqQQA2AgAgAA8LQQAhAiABQfz//wdLDQBBACECAkACQEEAKAKwmICAACIHQQAoAqyY
gIAAIglODQADQCAHQQJ0QbSYgIAAaiIKKAIAIgFFDQECQAJAIAFBAUgNACABIAdqIQsMAQsCQCADQQAgAWsiAUgNAANAIAEgB2oi
C0ECdEG0mICAAGooAgAiBEF/Sg0CIAEgBGsiASADTA0ACwsgCiABNgIAQQAgASAHajYCsJiAgAAMAwsgCyEHIAsgCUgNAAsLIAlB
////AUoNAUGAgIACIAlrIANMDQEgCUECdEG0mICAAGogA0EBaiIBNgIAQQBBACgCrJiAgAAiByABaiIBNgKsmICAACABQf///wFK
DQAgAUECdEG0mICAAGpBADYCAAsgB0ECdEG4mICAAGoiAiAAIAYoAgBBAnRBfGoQwoCAgAAaIAZBACAGKAIAazYCACAIQQAoArCY
gIAASg0AQQAgBTYCsJiAgAALIAILwAQBB39BACECAkACQCABIAByQQBIDQACQAJAIABFDQAgAQ0BC0EAIQICQEEAKAKwmICAACIA
QQAoAqyYgIAAIgNODQADQCAAQQJ0QbSYgIAAaiIEKAIAIgFFDQEgAUEBSA0EIAEgAGoiACADSA0ACwsgA0H///8BSg0BIANBAnRB
tJiAgABqQQE2AgBBAEEAKAKsmICAACIAQQFqIgE2AqyYgIAAIABBAnRBuJiAgABqIQIgAEH+//8BSg0BIAFBAnRBtJiAgABqQQA2
AgAgAg8LQYCAgAggAW0gAEgNACABIABsIgVB////B0sNACAFQQNqQQJ2IQZBACECAkACQEEAKAKwmICAACIDQQAoAqyYgIAAIgdO
DQADQCADQQJ0QbSYgIAAaiIIKAIAIgBFDQECQAJAIABBAUgNACAAIANqIQQMAQsCQCAGQQAgAGsiAEgNAANAIAAgA2oiBEECdEG0
mICAAGooAgAiAUF/Sg0CIAAgAWsiACAGTA0ACwsgCCAANgIAQQAgACADajYCsJiAgAAMAwsgBCEDIAQgB0gNAAsLIAdB////AUoN
AUGAgIACIAdrIAZMDQEgB0ECdEG0mICAAGogBkEBaiIANgIAQQBBACgCrJiAgAAiAyAAaiIANgKsmICAACAAQf///wFKDQAgAEEC
dEG0mICAAGpBADYCAAsgA0ECdEG4mICAAGoiAkEAIAUQx4CAgAAaCyACDwsgBEEAIAFrNgIAQQAgACABazYCsJiAgAAgBEEEags5
AQF/QQBBACgCtJiAiAAiAEENdCAAcyIAQRF2IABzIgBBBXQgAHMiADYCtJiAiAAgAEH/////B3ELDQBBACAANgK0mICIAAudAQIB
fAV/AkACQBCMgICAAEQAAAAAAECPQKIiAJlEAAAAAAAA4EFjRQ0AIACqIQEMAQtBgICAgHghAQtB8f8DIQICQANAAkAgAUUNAEEA
IQMgASEEA0AgBEEBcSADaiEDIARBAUshBSAEQQF2IQQgBQ0ACyADQXZqQQtJDQILIAIgAXMhASACQfH/A2ohAgwACwtBACABNgK0
mICIAAtIAAJAQdgAIAAQ6oCAgAAiAEUNACAAQYKAgIAANgIkIABBg4CAgAA2AiAgAEGEgICAADYCHCAAQcgAakKAgICA8B83AwAL
IAAL0AcCBX8BfCOAgICAAEEwayIBJICAgIAAIABByABqIgIoAgAQhoCAgAAgAEHMAGoiAy0AABCHgICAAEEBQQpBCkEUQQpB/4GA
eBCOgICAAEEBQRRBD0EUQRRBgIH8BxCOgICAACABQSBqQQApA9CWgIAANwMAIAFBGGoiBEEAKQPIloCAADcDACABQRBqIgVBACkD
wJaAgAA3AwAgAUEAKQO4loCAADcDCCABQQApA7CWgIAANwMAQQEgAUEFEI+AgIAAIARBACkD+JaAgAA3AwAgBUEAKQPwloCAADcD
ACABQQApA+iWgIAANwMIIAFBACkD4JaAgAA3AwBBASABQQQQkICAgABBAUEAKAK4mICIAEEKQTJBwABBEEEQQRBBABCRgICAAEEB
QQAoAriYgIgAQSZBOkHAAEEQQRBBEEEAQYCABEGAgAQQkoCAgAACQAJAIABB0ABqKwMARAAAAAAAAPBAoiIGmUQAAAAAAADgQWNF
DQAgBqohBAwBC0GAgICAeCEEC0EBQQAoAriYgIgAQcQAQcQAQcAAQRBBEEEQIARBgIAIQYCACBCSgICAACABQQAvAYSXgIAAOwEE
IAFBACgBgJeAgAA2AgBBAUEAKAK4mICIACABQQEQiICAgABBABCGgICAAEH/ARCHgICAACABIAIoAgAiAkEPcUHGi4CAAGotAAA6
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
IBogAWpBEHRBEHUiGiAUQYQBQQEQt4CAgAAgACgCDCANIAxBhgFBABC3gICAACAAKAIMELaAgIAAIAMgBkEDdGoiASgCBEUNACAB
QQRqIQkgACgCDCAAKAIQQf+BfEH/ARC1gICAAEEBIQEDQAJAIAkoAgAgAXFFDQACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJA
AkACQAJAAkACQCABQf8fSg0AAkAgAUH/AEoNACABQX9qDkACAxQEFBQUBRQUFBQUFBQGFBQUFBQUFBQUFBQUFBQUBxQUFBQUFBQU
FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQIFAsCQCABQf8DSg0AIAFBgAFGDQkgAUGAAkcNFCACKAIAIA0gD0GLAUEAELeAgIAADBQL
IAFBgARGDQkgAUGACEYNCiABQYAQRw0TIAIoAgAgFSALQYkBQQAQt4CAgAAMEwsCQCABQf//D0oNAAJAIAFB//8BSg0AIAFBgCBG
DQwgAUGAwABGDQ0gAUGAgAFHDRQgAigCACAYIBRBhQFBABC3gICAAAwUCyABQYCAAkYNDSABQYCABEYNDiABQYCACEcNEyACKAIA
IBsgC0GIAUEAELeAgIAADBMLAkAgAUH///8ASg0AIAFBgIAQRg0PIAFBgIAgRg0QIAFBgIDAAEcNEyACKAIAIBsgC0GIAUEFELeA
gIAADBMLAkAgAUH///8DSg0AIAFBgICAAUYNESABQYCAgAJHDRMgAigCACAVIAtBiAFBARC3gICAAAwTCyABQYCAgARGDREgAUGA
gIAIRw0SIAIoAgAgFSALQYgBQQUQt4CAgAAMEgsgAigCACAOIBBBhwFBABC3gICAAAwRCyACKAIAIBIgFEGHAUEAELeAgIAADBAL
IAIoAgAgFiAUQYcBQQAQt4CAgAAMDwsgAigCACAOIBdBhwFBABC3gICAAAwOCyACKAIAIBkgCkGWAUEAELeAgIAAIAIoAgAgGyAK
QZcBQQAQt4CAgAAMDQsgAigCACAVIApBlwFBARC3gICAACACKAIAIBwgCkGWAUEBELeAgIAADAwLIAIoAgAgHSAKQZkBQQAQt4CA
gAAMCwsgAigCACARIApBmQFBARC3gICAAAwKCyACKAIAIA0gD0GLAUEBELeAgIAADAkLIAIoAgAgGyALQYkBQQAQt4CAgAAMCAsg
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
gIAAC2YAAkBB2AAgABDqgICAACIARQ0AIABBr4CAgAA2AjwgAEGwgICAADYCJCAAQbGAgIAANgIgIABBloCAgAA2AhwCQCAAQbCK
gIAAQRIQ7oCAgABBf0wNACAADwsgABDpgICAAAtBAAvFAQEBfyOAgICAAEEwayIBJICAgIAAAkAgACgCNA0AQYiQgIAAQQAQjYCA
gAAgAUHIAzYCKCABQaWKgIAANgIkIAFB+wA2AiBBz42AgAAgAUEgahCNgICAAEG0kICAAEEAEI2AgIAAIAFClYaAgPANNwIMIAFB
pYqAgAA2AgggAUL7gICAgDk3AwBBlY+AgAAgARCNgICAACAAQcgAakKAgICAgICA+D83AwAgAEHQAGpBgICChHg2AgALIAFBMGok
gICAgAALmwECAXwCfwJAIABByABqKwMAIgFEAAAAAAAAAABkRQ0AAkACQCABRAAAAAAA4G9AoiIBmUQAAAAAAADgQWNFDQAgAaoh
AgwBC0GAgICAeCECCyAAQdAAaiIDIAMoAgBBgH5xIAJB/wEgAkH/AUgbIgJBACACQQBKG3IiAjYCAEEBQQBBAEHoB0HoByACEI6A
gIAACyAAEPGAgIAAC0cBAX8gACABEPCAgIAAIABByABqIgIgAisDACABoSIBOQMAAkAgAUQAAAAAAAAAAGVFDQAgAEIANwNIIABB
0ABqQQA2AgALC10AAkBB3AAgABDqgICAACIARQ0AIABBsoCAgAA2AiQgAEGzgICAADYCICAAQbSAgIAANgIcIABBtYCAgAA2Ahgg
AEHUAGpBATYCAEG2gICAACAAEImAgIAAGgsgAAugAwEGfyOAgICAAEEQayIBJICAgIAAAkAgAEHUAGooAgBFDQAgAEEANgJUIABB
0ABqKAIAIgJBAEgNACACIABByABqKAIATg0AIAAoAgQiA0ECdCIEIAAoAggiBRDZgICAACIGRQ0AIAEgACgCRCACQQJ0aigCACIC
QR9xQYCIgIAAai0AADoADyABIAJBBXZBH3FBgIiAgABqLQAAOgAOIAYgAyAFIARBCkEBIAAoAgAgAUEOakECQYD+/wcQr4CAgAAa
IAYgACgCBCICIAAoAgggAkECdEEeQQEgACgCAEGWk4CAAEF/QcCBgwYQr4CAgAAaIAEgBjYCBCABIAA2AgAgASAAKAIAEKmAgIAA
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
CnBBMHIhBAsgASACaiAEOgAAIAAoAgxBKEEwIAEgAkEBahC4gICAACABQSA6AAIgAUH49AA7AQBBAyECAkAgAEHMAGooAgAiA0F/
Sg0AIAFBLToAA0EAIANrIQNBBCECC0E/IQQCQCADQY/OAEsNAAJAAkACQAJAAkAgA0HoB0kNACABIAJyIANB//8DcUHoB25BCnBB
MHI6AAAgAkEBaiECDAELIANB5ABJDQELIAEgAnIgA0H//wNxQeQAbkH/AXFBCnBBMHI6AAAgAkEBaiECDAELIANBCkkNAQsgASAC
aiADQf//A3FBCm5BCnBBMHI6AAAgAkEBaiECCyADQf//A3FBCnBBMHIhBAsgASACaiAEOgAAIAAoAgxBKEE4IAEgAkEBahC4gICA
ACABQSA6AAIgAUH59AA7AQBBAyECAkAgAEHQAGooAgAiA0F/Sg0AIAFBLToAA0EAIANrIQNBBCECC0E/IQQCQCADQY/OAEsNAAJA
AkACQAJAAkAgA0HoB0kNACABIAJyIANB//8DcUHoB25BCnBBMHI6AAAgAkEBaiECDAELIANB5ABJDQELIAEgAnIgA0H//wNxQeQA
bkH/AXFBCnBBMHI6AAAgAkEBaiECDAELIANBCkkNAQsgASACaiADQf//A3FBCm5BCnBBMHI6AAAgAkEBaiECCyADQf//A3FBCnBB
MHIhBAsgASACaiAEOgAAIAAoAgxBKEHAACABIAJBAWoQuICAgAACQCAAQegAai0AACIDRQ0AAkACQAJAAkACQAJAAkACQAJAAkAC
QAJAAkACQAJAIANBAXFFDQAgAUHSADoABCABQc+ooaoENgIAQQUhAiADQQJxRQ0CIAFBLDoABUEGIQIMAQtBACECIANBAnENAEEA
IQIgA0EEcQ0CQQAhAiADQQhxDQRBACECIANBEHENBkEAIQIgA0EgcQ0IQQAhAiADQcAAcQ0KQQAhAiADQYABcQ0MDA0LIAIgAXIi
BEHMADoAACAEQQFyQeUAOgAAIARBAmpB5ugBOwEAIAJBBGohAgsgA0EEcUUNASABIAJyQSw6AAAgAkEBaiECCyABIAJqIgRB0tKd
wwY2AAAgBEEEakH0ADoAACACQQVqIQILIANBCHFFDQECQCACDQBBACECDAELIAEgAmpBLDoAACACQQFqIQILIAEgAmoiBEHN0pGj
BjYAACAEQQRqQezKATsAACACQQZqIQILIANBEHFFDQECQCACDQBBACECDAELIAEgAmpBLDoAACACQQFqIQILIAEgAmpBNDoAACAC
QQFqIQILIANBIHFFDQECQCACDQBBACECDAELIAEgAmpBLDoAACACQQFqIQILIAEgAmpBNToAACACQQFqIQILIANBwABxRQ0BAkAg
Ag0AQQAhAgwBCyABIAJqQSw6AAAgAkEBaiECCyABIAJqQTY6AAAgAkEBaiECCyADQYABcUUNAQJAIAINAEEAIQIMAQsgASACakEs
OgAAIAJBAWohAgsgASACakE3OgAAIAJBAWohAgsgACgCDEEoQcgAIAEgAhC4gICAAAsgACgCDBC2gICAAAsgAUGAAWokgICAgAAL
lAEBAXwCQCAAQdgAaisDACICRAAAAAAAAAAAZEUNACAAIAIgAaEiAjkDWCACRAAAAAAAAAAAZUUNACAAQgA3A1ggAEHMAGpBADYC
AAsCQCAAQeAAaisDACICRAAAAAAAAAAAZEUNACAAIAIgAaEiATkDYCABRAAAAAAAAAAAZUUNACAAQgA3A2AgAEHQAGpBADYCAAsL
0AEBAn8CQAJAAkACQCABKAIAQXxqDgMAAQIDCyAAIAEoAgQ2AkQgAEHIAGogASgCCDYCAA8LQQEgASgCDCICdEEBIAJBf2pBB0kb
IQIgAEHoAGotAAAhAwJAIAEoAhBFDQAgACADIAJyOgBoDwsgACADIAJBf3NxOgBoDwsCQCABKAIMIgJFDQAgAEHYAGpCgICAgICA
gOg/NwMAIABBzABqIAI2AgALIAEoAhAiAUUNACAAQeAAakKAgICAgICA6D83AwAgAEHQAGogATYCAAsLAgALyAIBAn8CQEGYAiAA
EOqAgIAAIgBFDQAgACAAKAKQAiIBQQFqNgKQAiAAQb2AgIAANgJAIABBvoCAgAA2AjwgAEG/gICAADYCJCAAQZWAgIAANgIgIABB
wICAgAA2AhwgAEHBgICAADYCGCAAQfAAaiICIAFBAnRqQQA2AgBBwoCAgAAgABCJgICAABogAEGskYCAAEF/EO6AgIAAGiAAQfKL
gIAAQX8Q7oCAgAAaIABB14uAgABBfxDugICAABogAEG4kYCAAEF/EO6AgIAAGiAAQeiQgIAAQX8Q7oCAgAAaIABBxZGAgABBfxDu
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
D3FBxouAgABqLQAAOgAMIAEgAkEQdkEPcUHGi4CAAGotAAA6AAsgASACQRR2QQ9xQcaLgIAAai0AADoACiABIAJBGHZBD3FBxouA
gABqLQAAOgAJIAAoAgxBKEEoIAFBBWpBCxC4gICAACABQSA6AAcgAUH59AA7AAUgASAAQcwAaigCACICQQ9xQcaLgIAAai0AADoA
DyABIAJBHHZBxouAgABqLQAAOgAIIAEgAkEEdkEPcUHGi4CAAGotAAA6AA4gASACQQh2QQ9xQcaLgIAAai0AADoADSABIAJBDHZB
D3FBxouAgABqLQAAOgAMIAEgAkEQdkEPcUHGi4CAAGotAAA6AAsgASACQRR2QQ9xQcaLgIAAai0AADoACiABIAJBGHZBD3FBxouA
gABqLQAAOgAJIAAoAgxBKEEwIAFBBWpBCxC4gICAACABQSA6AAcgAUH69AA7AAUgASAAQdAAaigCACICQQ9xQcaLgIAAai0AADoA
DyABIAJBHHZBxouAgABqLQAAOgAIIAEgAkEEdkEPcUHGi4CAAGotAAA6AA4gASACQQh2QQ9xQcaLgIAAai0AADoADSABIAJBDHZB
D3FBxouAgABqLQAAOgAMIAEgAkEQdkEPcUHGi4CAAGotAAA6AAsgASACQRR2QQ9xQcaLgIAAai0AADoACiABIAJBGHZBD3FBxouA
gABqLQAAOgAJIAAoAgxBKEE4IAFBBWpBCxC4gICAACAAKAIMELaAgIAACyABQRBqJICAgIAACwIACzkAAkAgASgCAEEIRw0AIABB
yABqIAEoAgQ2AgAgAEHMAGogASgCCDYCACAAQdAAaiABKAIMNgIACwsNAEEIQQAQlICAgAAaC7oBAAJAQcQAIAAQ6oCAgAAiAEUN
ACAAQceAgIAANgI8IABBlICAgAA2AiQgAEGVgICAADYCICAAQZaAgIAANgIcIABBq4uAgABBCBDugICAABogAEGni4CAAEEMEO6A
gIAAGiAAQY6NgIAAQQgQ7oCAgAAaIABB7IuAgABBBRDugICAABogAEGci4CAAEEKEO6AgIAAGiAAQbSLgIAAQQUQ7oCAgAAaIABB
/omAgABBDRDugICAABoLIAALbgACQAJAAkACQAJAAkACQAJAIAAoAjQOBwABAgMEBQYHCyAAEOKAgIAAGg8LIAAQh4GAgAAaDwsg
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
JXg6JXg6JXgASW5wdXQALi4uZW5kIG9mIGxpc3QATGlzdAAhISEgdG91Y2hpZCAlZCBhbHJlYWR5IGV4aXN0cwAgICVkIGJ1dHRv
bnMAVHJhbnNmb3JtcwBQcmltaXRpdmVzAFRvbyBNYW55IFNwcml0ZXMATGlzdCBSZXNvdXJjZXMAbG9ja2VkIGN1cnNvcgBObyBh
Y2NlbGVyb21ldGVyAEFjY2VsZXJvbWV0ZXIASW50ZXJtZWRpYXRlIEZyYW1lYnVmZmVyAHJlZ3Jlc3Npb25fMjAyNDA2MDlfbG9n
X3BjdF9wAEF1ZGlvAFZpZGVvAFJlZ3Jlc3Npb24Ad2FzbQAhISEgVW5hYmxlIHRvIHJlY29yZCBrZXlib2FyZCBldmVudCAleD0l
ZCwgYnVmZmVyIGZ1bGwARGVjYWwATW91c2UgTG9jawBSYXcgSm95c3RpY2sAVG91Y2gAc29uZwBzdHJpbmcAMDEyMzQ1Njc4OWFi
Y2RlZgAgIFJlcGVhdDogdHJ1ZQBXcml0ZQBNb3VzZQAgIEZvcmNlOiBmYWxzZQBTdG9yZQBSZWFsIHRpbWUAR2FtZSB0aW1lAFRp
bGUARUdHX0VWRU5UX1RPVUNIIGZhaWxlZCB0byBlbmFibGUAbGFuZ3VhZ2UAU3RyaW5ncyBieSBMYW5ndWFnZQBpbWFnZQBQZXJz
aXN0ZW5jZQBSZWZlcmVuY2UAVE9ETzogbWVudV9rZXlib2FyZABLZXlib2FyZABzb3VuZABSZWFkAC4uLnRvbyBiaWchICVkPiVk
AGRldmlkPSVkIGJ0bmlkPSVYIHZhbHVlPSVkACVkICVwICVkACEhISBJbnZhbGlkIHRvdWNoIHN0YXJ0IGV2ZW50IGZvciB0b3Vj
aGlkICVkACEhISBVbmV4cGVjdGVkIHRvdWNoIGZpbmlzaCBldmVudCBmb3IgdG91Y2hpZCAlZAAhISEgVW5leHBlY3RlZCB0b3Vj
aCBtb3ZlIGV2ZW50IGZvciB0b3VjaGlkICVkACEhISBVbmV4cGVjdGVkIHN0YXRlICVkIGZvciBldmVudCBvbiB0b3VjaGlkICVk
ACVkICVkICVwICVkICVkAE1pc2MAbWV0YWRhdGEAbXlTdG9yZWREYXRhAEpPWQBLRVkAVEVYVABNQlVUVE9OAE1NT1RJT04ATVdI
RUVMAFRPVUNIAElkZW50aWNhbD8AVGludDoATGFuZ3M6AEFscGhhOgBUaGlzIG11c3QgcHJpbnQgJzEyMyAoKHNvbWUgYWRkcmVz
cykpIDQ1Nic6AFRoaXMgbXVzdCBwcmludCAnMTIzIDQ1NiAoKHNvbWUgYWRkcmVzcykpIDc4OSAxMTEnOgAgIFRyaW06IDk5ACEh
ISBGYWlsZWQgdG8gbG9hZCBpbWFnZTowOjgATW9kZTcARm9yY2UgUGxheWhlYWQgdG8gMS4wAFBsYXkgU29uZyAwAFBsYXkgU291
bmQgMAAgIFBhbjogMABGYWlsZWQgdG8gZW5hYmxlICVzIGV2ZW50cy4AV2F0Y2ggbG9nIGZvciByZXN1bHRzLgAhISEgRmFpbGVk
IHRvIGFkZCB0b3VjaCAlZC4gRXhwZWN0IGZ1cnRoZXIgZXJyb3JzLgBKb3kgb3IgUS4uUCB0byBwbGF5IG5vdGVzLgBFc2MsIG1v
dXNlLCBvciAxMCBzIGlkbGUgdG8gcmV0dXJuLgBtZW51X3JhdyBjbG9zaW5nIGR1ZSB0byAlZiBzIGlkbGUuAEwvUiB0byBjaGFu
Z2UuAExpc3Rpbmcgc3RvcmFnZSBrZXlzLi4uAFJlYWRpbmcgJ215U3RvcmVkRGF0YScgZnJvbSBzdG9yYWdlLi4uAC4uLiclLipz
JwBXcml0aW5nIHN0b3JhZ2UgJ215U3RvcmVkRGF0YScgPSAnJS4qcycAICAnJS4qcycAICAiJXMiAFRvbyBtYW55IQAuLi5zdWNj
ZXNzIQBOb25lIQBlZ2dfbG9ja19jdXJzb3IgZmFpbGVkIQBJbml0aWFsaXplIHRleHR1cmUgZmFpbGVkIQAuLi5GQUlMVVJFIQAh
ISEgbWVudV9yYXcgcmVxdWlyZXMgYSBmb250IG9yIHRpbGVzaGVldCAhISEAAAAAAAAAAAAAZnMtOFLB4D8YLURU+yH5P2ZzLThS
wfA/AAAAAAAAAAAAAAAAAAAAgAAAAACAAAAA/wAAAIAAAP//AAD/gP8AAP//AACA/////////wAAAAAAAAAAAAAAAAAAAABAAAAA
gAAAAMAAAAD/AAAAAAAAAAAAAAAAAAAAMgAKAP////9aAAoA/////0YAFAAAAAD/WgAeAP8AAP9GACgA/wAAAAAAAAAAAAAAZAAK
AP/////IAAoA/wAA/3gAKAAA/wD/yAAoAAAA/wBkADwAFAAAAAAAAAAAAAAAFAAtABYAKAAtABcAPAAtABgAUAAtABkAZAAtABoA
eAAtABsAjAAtABwAoAAtAB0AFABLABYAKABLABYBPABLABYCUABLABYDZABLABYEeABLABYFjABLABYGoABLABYHqQcAAFoFAAC/
BQAAXgYAALoFAACXBgAAAKAcBG5hbWUB+BvQAQAUZWdnX2ltYWdlX2dldF9oZWFkZXIBEGVnZ19pbWFnZV9kZWNvZGUCEmVnZ190
ZXh0dXJlX3VwbG9hZAMPZWdnX3RleHR1cmVfbmV3BA9lZ2dfdGV4dHVyZV9kZWwFFmVnZ190ZXh0dXJlX2dldF9oZWFkZXIGD2Vn
Z19yZW5kZXJfdGludAcQZWdnX3JlbmRlcl9hbHBoYQgNZWdnX2RyYXdfdGlsZQkQZWdnX3Jlc19mb3JfZWFjaAoWZWdnX2dldF91
c2VyX2xhbmd1YWdlcwsLZWdnX3Jlc19nZXQMDWVnZ190aW1lX3JlYWwNB2VnZ19sb2cODWVnZ19kcmF3X3JlY3QPDWVnZ19kcmF3
X2xpbmUQDWVnZ19kcmF3X3RyaWcRDmVnZ19kcmF3X2RlY2FsEhRlZ2dfZHJhd19kZWNhbF9tb2RlNxMbZWdnX2pveXN0aWNrX2Rl
dmlkX2J5X2luZGV4FBBlZ2dfZXZlbnRfZW5hYmxlFRRlZ2dfam95c3RpY2tfZ2V0X2lkcxYcZWdnX2pveXN0aWNrX2Zvcl9lYWNo
X2J1dHRvbhcVZWdnX2pveXN0aWNrX2dldF9uYW1lGA9lZ2dfbG9ja19jdXJzb3IZDmVnZ190aW1lX2xvY2FsGhZlZ2dfdGV4dHVy
ZV9sb2FkX2ltYWdlGw1lZ2dfc3RvcmVfZ2V0HA1lZ2dfc3RvcmVfc2V0HRZlZ2dfc3RvcmVfa2V5X2J5X2luZGV4Hg9lZ2dfYXVk
aW9fZXZlbnQfFmVnZ19hdWRpb19nZXRfcGxheWhlYWQgE2VnZ19hdWRpb19wbGF5X3NvbmchFGVnZ19hdWRpb19wbGF5X3NvdW5k
IhZlZ2dfYXVkaW9fc2V0X3BsYXloZWFkIxdlZ2dfcmVxdWVzdF90ZXJtaW5hdGlvbiQNZWdnX2V2ZW50X2dldCURX193YXNtX2Nh
bGxfY3RvcnMmCGZvbnRfZGVsJwhmb250X25ldygNZm9udF9hZGRfcGFnZSkNZm9udF9nZXRfcm93aCoRZm9udF9jb3VudF9nbHlw
aHMrEGZvbnRfY291bnRfcGFnZXMsFmZvbnRfcmVuZGVyX3RvX3RleHR1cmUtEGZvbnRfYnJlYWtfbGluZXMuDGZvbnRfbWVhc3Vy
ZS8XZm9udF9yZW5kZXJfc3RyaW5nX3JnYmEwF2ZvbnRfcmVuZGVyX25ld190ZXh0dXJlMRJmb250X21lYXN1cmVfZ2x5cGgyFWZv
bnRfcmVuZGVyX3N0cmluZ19hMTMVZm9udF9yZW5kZXJfY2hhcl9yZ2JhNBNmb250X3JlbmRlcl9jaGFyX2ExNRN0aWxlX3JlbmRl
cmVyX2JlZ2luNhF0aWxlX3JlbmRlcmVyX2VuZDcSdGlsZV9yZW5kZXJlcl90aWxlOBR0aWxlX3JlbmRlcmVyX3N0cmluZzkQdGV4
dF91dGY4X2RlY29kZToQdGV4dF91dGY4X2VuY29kZTsJdGV4dF9pbml0PA90ZXh0X2NiX2Zvcl9yZXM9EXRleHRfZ2V0X21ldGFk
YXRhPg90ZXh0X2dldF9zdHJpbmc/FnRleHRfZm9yX2VhY2hfbGFuZ3VhZ2VAEXRleHRfZ2V0X2xhbmd1YWdlQRF0ZXh0X3NldF9s
YW5ndWFnZUIGbWVtY3B5QwdtZW1tb3ZlRAZtZW1jbXBFB3N0cm5jbXBGBnN0cmR1cEcGbWVtc2V0SARmYWJzSQNzaW5KA2Nvc0sF
YXRhbjJMBWZyZXhwTQRwb3dmTgRmbW9kTwNsb2dQA2V4cFEEbW9kZlIFbGRleHBTBWxvZzEwVARzcXJ0VQpmcGNsYXNzaWZ5VgZt
YWxsb2NXBGZyZWVYB3JlYWxsb2NZBmNhbGxvY1oEcmFuZFsFc3JhbmRcCnNyYW5kX2F1dG9dE21lbnVfbmV3X3ByaW1pdGl2ZXNe
El9wcmltaXRpdmVzX3JlbmRlcl8SX3ByaW1pdGl2ZXNfdXBkYXRlYBFfcHJpbWl0aXZlc19ldmVudGERcHJpbWl0aXZlc19tb3Rp
b25iEW1lbnVfbmV3X2pveXN0aWNrYxBfam95c3RpY2tfcmVuZGVyZBBfam95c3RpY2tfdXBkYXRlZQ9fam95c3RpY2tfZXZlbnRm
DV9qb3lzdGlja19kZWxnE21lbnVfbmV3X3RyYW5zZm9ybXNoEl90cmFuc2Zvcm1zX3JlbmRlcmkIbWVudV9kZWxqCG1lbnVfbmV3
awptZW51X2V2ZW50bAttZW51X3VwZGF0ZW0LbWVudV9yZW5kZXJuD21lbnVfb3B0aW9uX2FkZG8RbWVudV9vcHRpb25fZXZlbnRw
Em1lbnVfb3B0aW9uX3VwZGF0ZXESbWVudV9vcHRpb25fcmVuZGVychxtZW51X29wdGlvbl9yZWFkX3RhaWxfc3RyaW5ncxltZW51
X29wdGlvbl9yZWFkX3RhaWxfaW50dBxtZW51X29wdGlvbl9yZWFkX3RhaWxfZG91YmxldR9tZW51X29wdGlvbl9yZXdyaXRlX3Rh
aWxfc3RyaW5ndhxtZW51X29wdGlvbl9yZXdyaXRlX3RhaWxfaW50dx9tZW51X29wdGlvbl9yZXdyaXRlX3RhaWxfZG91YmxleBBt
ZW51X25ld19saXN0cmVzeQ9fbGlzdHJlc19yZW5kZXJ6D19saXN0cmVzX3VwZGF0ZXsOX2xpc3RyZXNfZXZlbnR8DF9saXN0cmVz
X2RlbH0PbGlzdHJlc19hZGRfcmVzfhVsaXN0cmVzX3JlYnVpbGRfdGlsZXN/EG1lbnVfbmV3X3Nwcml0ZXOAAQ9fc3ByaXRlc19y
ZW5kZXKBAQ9fc3ByaXRlc191cGRhdGWCAQ5fc3ByaXRlc19ldmVudIMBDF9zcHJpdGVzX2RlbIQBEXNwcml0ZXNfc2V0X2NvdW50
hQENbWVudV9uZXdfbWFpboYBDF9tYWluX29wdGlvbocBDG1lbnVfbmV3X3Jhd4gBC19yYXdfcmVuZGVyiQELX3Jhd191cGRhdGWK
AQpfcmF3X2V2ZW50iwEIX3Jhd19kZWyMARRyYXdfY2JfY291bnRfYnV0dG9uc40BCnJhd19hcHBlbmSOAQ5tZW51X25ld19zdG9y
ZY8BDV9zdG9yZV9vcHRpb26QARJtZW51X25ld19tb3VzZWxvY2uRARFfbW91c2Vsb2NrX3JlbmRlcpIBEV9tb3VzZWxvY2tfdXBk
YXRlkwEQX21vdXNlbG9ja19ldmVudJQBDl9tb3VzZWxvY2tfZGVslQENbWVudV9uZXdfbWlzY5YBDF9taXNjX3JlbmRlcpcBDm1p
c2NfcmVwcl90aW1lmAERbWVudV9uZXdfa2V5Ym9hcmSZARBfa2V5Ym9hcmRfcmVuZGVymgEQX2tleWJvYXJkX3VwZGF0ZZsBD19r
ZXlib2FyZF9ldmVudJwBDV9rZXlib2FyZF9kZWydAQ5tZW51X25ld190b3VjaJ4BDV90b3VjaF9yZW5kZXKfAQ1fdG91Y2hfdXBk
YXRloAEMX3RvdWNoX2V2ZW50oQEKX3RvdWNoX2RlbKIBFG1lbnVfbmV3X3BlcnNpc3RlbmNlowETX3BlcnNpc3RlbmNlX29wdGlv
bqQBE19wZXJzaXN0ZW5jZV9yZW5kZXKlARRtZW51X25ld19mcmFtZWJ1ZmZlcqYBE19mcmFtZWJ1ZmZlcl9yZW5kZXKnARNfZnJh
bWVidWZmZXJfdXBkYXRlqAEQX2ZyYW1lYnVmZmVyX2RlbKkBFmZyYW1lYnVmZmVyX2RyYXdfc2NlbmWqARNtZW51X25ld19yZWdy
ZXNzaW9uqwESX3JlZ3Jlc3Npb25fb3B0aW9urAESX3JlZ3Jlc3Npb25fcmVuZGVyrQESX3JlZ3Jlc3Npb25fdXBkYXRlrgEQbWVu
dV9uZXdfc3RyaW5nc68BD19zdHJpbmdzX3JlbmRlcrABD19zdHJpbmdzX3VwZGF0ZbEBDl9zdHJpbmdzX2V2ZW50sgEMX3N0cmlu
Z3NfZGVsswEOc3RyaW5nc19jYl9yZXO0AQ9zdHJpbmdzX2NiX2RyYXe1AQ5tZW51X25ld192aWRlb7YBDV92aWRlb19vcHRpb263
AQ5tZW51X25ld19tb3VzZbgBDV9tb3VzZV9yZW5kZXK5AQ1fbW91c2VfdXBkYXRlugEMX21vdXNlX2V2ZW50uwEKX21vdXNlX2Rl
bLwBDm1lbnVfbmV3X2F1ZGlvvQENX2F1ZGlvX2FkanVzdL4BDV9hdWRpb19vcHRpb26/AQ1fYXVkaW9fcmVuZGVywAEMX2F1ZGlv
X2V2ZW50wQEKX2F1ZGlvX2RlbMIBDV9hdWRpb19jYl9yZXPDARZtZW51X25ld19hY2NlbGVyb21ldGVyxAEVX2FjY2VsZXJvbWV0
ZXJfcmVuZGVyxQEVX2FjY2VsZXJvbWV0ZXJfdXBkYXRlxgEUX2FjY2VsZXJvbWV0ZXJfZXZlbnTHARJfYWNjZWxlcm9tZXRlcl9k
ZWzIAQ5tZW51X25ld19pbnB1dMkBDV9pbnB1dF9vcHRpb27KAQ9lZ2dfY2xpZW50X3F1aXTLARtsaWdodHNvbl9kZWZhdWx0X2V2
ZW50X21hc2vMAQ9lZ2dfY2xpZW50X2luaXTNAQhwb3BfbWVudc4BEWVnZ19jbGllbnRfdXBkYXRlzwERZWdnX2NsaWVudF9yZW5k
ZXIHEgEAD19fc3RhY2tfcG9pbnRlcgkKAQAHLnJvZGF0YQA4CXByb2R1Y2VycwEMcHJvY2Vzc2VkLWJ5AQxVYnVudHUgY2xhbmcR
MTQuMC4wLTF1YnVudHUxLjE)t0q152r7(RW5nbGlzaA)r9(TGlnaHRzIE9u)rb(SGVsbG8gd29ybGQ)r26(TXVyYmxhZ3lsZSBicm9ja3RvbmZvcmQgZWIgbm9nZ2xp
Zml6ZS4)q23r8(ZnJhbmNhaXM)rc(THVtaWVyZSBWaXZl)rd(Qm9uam91ciBtb25kZQ)r22(TCdlbGxlY2hhbXBzIGQncydpaSBsJ2FsbGVjaGFyZ25lLg)q182re(0KDRg9GB
0YHQutC40Lk)rd(0JvQsNC40YYg0L7QvQ)r13(0J/RgNC40LLQtdGCINC80LjRgA)r3b(0J/RgNC+0YHRgdGC0LLQvtC70LLQs9GA0LjQvdC40Lkg0YHRgtC7
0LLRgNC+0YDQstC70L7QsdC+0YY)t0rd5(iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAnElEQVQ4y2NgYGBg+H6G4z8DFoBL
nIFYxSQbjC5BiqFEKSDJS1DwH4pxAkaYqZwmPxjRNf//D9HLyMjIwMDAwIjNNYzoAlCD4JrhNkENQbeQEZfTcRmA4QViNOMzhAU5
ZLGEA8HYwOuC/kQhBgYGBobC+e9wuwCfTdxy9gxKmmZ4XcOE3asQS5Q0zRjuXT9FciAiJyJi1ZKfEikGAGqyUXajckByAAAAAElF
TkSuQmCC)r2a6(iVBORw0KGgoAAAANSUhEUgAAAIAAAACAAQMAAAD58POIAAAABlBMVEUAAAD///+l2Z/dAAACW0lEQVRIx+2VMWtbMRDH
j6aoHkTQeIMhb/SooYMox8NkMCV0yJCxw003PYKn4kGIEPIJOpYOnUM/hKHhTaXjI1PJ1DF0KhmM3ZP9EuLnuFBoSwu9RdbPuvvf
/ZFsgG1RwME6OIDz9tPRajmD99tObKvxDwQOwO0XDv3rvDMZDOji0Hk8cgp2FUAc9w7Bo8ugn8EguELBPEKEkPNivzi6PTHOYDAZ
PYdcwwNe5RRwZ08hqzjA6WYbhIEkUaISwAITSHgxEmYjgprtRyBoTQvQRzRwjNhPMVpNQQbbh1fojTFixWhCRNQUHpmRoALdeVWh
SIYIyUBPVXCzj6gnYkokZGs+rQlORYOZVf4j118E3ui2BZd8/U3gPEWWyeQ4of3K87nA29UJbbS65OazwMmqRgZa45NAkqzCpVCo
U60qD/VRJqnrWlKYBrU1V0AFlRh/heEONEGsH2OlKVoUpZo7Qh+wBuBqYhRcB/S+n2fl40pBqCtkv7sEzyQiudMaUzAB5pt9eGC9
FNkrO13ahZQBKoaLJbAmUqmWRjUIZ1FnKXV8IZ3W3mCTJLfKqlNmx7CRFjCa7McKlKsagqG2jdCWq9oueqfWgHdY6PjlSyI1SCQp
GGeRpAZdNySWnW2WjmWDGhTUE/2cwtmPOZVeQU/9MEyWnHqcVipsbu/nj97QrPv1SdwnD8MOwHctebJYrIObTspOt+jjrmTvIbA3
uwfyUywe7c2oC4Z0H6iJd6Bo16HvAuiAuxj+DnDyZ8DOh8V6H7bbmOv+SXTn35vC//glsfHA+OcBbfnF+HviO+IR1/C4hII0AAAA
AElFTkSuQmCC)r20d(iVBORw0KGgoAAAANSUhEUgAAAFQAAAA2AQMAAABjmSzTAAAABlBMVEUAAAD///+l2Z/dAAABwklEQVQoz33RzUsb
QRQA8Jc4kjVIGxcPQXKYTLOwu4deBMHbugQ1OTXW3npQvHhsUBAPwuQLNn5AWEZUiEu67KL+AYKFCq2kB6FY8D/Q1ksPQegxF9+u
H7UFfTDw4/F4b+YNHMUaDQEACTyf8prq7vPQld+yyj5woOjSBEmw7sW1ge65rOtBnqMjpu2xfR5BAn+ZHhqE/l54CAL/R3H0dNmZ
4xBDrxHNjApuWNhoJ3TLMdAHyR8L1bkavMKaU5qOZxstx0TX0ZMNHpTAwvHXojWzDtFnZsHZsPNHORGs+gWWtfybaqYsRr5RqGlm
YE+/onDYMd9ffS639UMKx0Hesz19l0IpqPdswTYorLwedir+9y0X+zwVP1NL56uq2x2zAIRdktFxQ9zZZzJ1AX41Z+UpN8US+ICq
PSBP+ZIpoWvot/NWmaAr5xf9TLW6vfz6yVncIFESkUKPG4QQ5dbpYvNsKdK3l0TH8kpG+LlpD92XV9rCr9+b3OdjxWZ70Vemt+/6
Jh6tcEb6Z6/6I+fC9x51RCH7IhfMEj4RBY1ZHt5ftNri3UAm1xPkWxl7U1Nv6z+ezMaznbAPDz4QqPTX4V5vAIcAlO/GwEFbAAAA
AElFTkSuQmCC)r220(iVBORw0KGgoAAAANSUhEUgAAAFUAAAA2AQMAAACMW0ftAAAABlBMVEUAAAD///+l2Z/dAAAB1UlEQVQoz2PoaFCa
62/AwPi8gYFBlmPRggkdDEwCDAwMmuwyO4RmLGC6AGSvbOVQEVnpXzUBxGaXmSO0q5EJxJ6r0dEi0OgAVt95gGMHP8MCxgcMuIHD
OQU5JgelbiUge4mbgwnTAqVOBSDbL6/BhMlLZbITkM3CwCBygJVDoQ2sg1PkANO0wgwgiw/IZmBVm5TRABLnF2HgUpqlDlbD0cCB
ZIcElBaRWCXwuUNRlGUKA4OSqoOmi4tTQ6cDA0OyxDFDF7nve+/eYWCYslTTK0WgRaGjg4Hh+9731UdknluA2CBxlwCIOIhdPA+i
HgQYkexihtKFHsoiC/gmuGl4GDB4tbis4JjI0cnQ58HgwZMscVSpgcFL04PhVdCUpUoqQMM0Axi8gWxVjaWanic9GLwuTVmqMVFV
0wOovsgnWeKAnsQxg44InGGoBPQXg0JLiCfQL46qDhoMglxMUyBSgu6GPQkgRvGc51YrvIImdTRA3H+ieM4jGLvDSaAJxAaqsXxu
2JPU0QDRzIRkBxuU5gT5i0GhJxDIlgL6i4lXUIhJYQEDOLyFgBgYedY9yRLnl3oFTdmpwAAklypogkkwW0kIIm4E8peOYU/yAqTU
sUABKRwPAAD+UJDf5v2M2AAAAABJRU5ErkJggg)r232(iVBORw0KGgoAAAANSUhEUgAAAF8AAAA2AQMAAACbedckAAAABlBMVEUAAAD///+l
2Z/dAAAB50lEQVQoz2Nw2qHYt+KckIwgpxIDg4KAU8AELyEOhTYg5/uELwIgjpcCkNMi084zwXt+X1DGIgaG50ItTJO8gjyTloJk
hJqcQJxgJTugnimNcyZOntzppcPBgAekWz6u8pzo5e+qVsHAMEWV1ckr2MgzV9MDzHEMCGbqDAVxvltyFjyY6s0Z+hIks5TTMSAy
CiIzZSm/k1dklqcriDPdkhNkWqCrmgc+Sx/bNSlpqob6CS7s7GOY0uFSBOR4CSzyCmKYwqGx0lM11ElggVYQwxMOgRWdsqHOcza8
82No4VBY6cka6hS0QsuNoaXDoUgTxFnl5cXQzNGgpN/6/fHcjZ2TYDYoYFrK2AAiHCAcJjDZAOGkWB5LjenSlNI0PsDAIK7KNblp
VpZ2phdQaclOroc8q9ZorQdxpiwVam46raWlCeIUW8qB9HhpGjkwkAUe1woKBoWGHFk8WQZotKBwF5DjsiBkCZAjsNQl8GpI2sY7
a0AcV6+A0JDwFSFTgHoEmydWxNelbZ6sAnI8I9wjMJ9AgNMEsPcbBUGUgoUDYwAD4yEOoN8YkgWY5zBaTGhpYAH5Z84XRQWNCU9V
RRxACaldUlHnxzSdJQ6ghNTCqqg1ZaqJO1BTskjzTlWfGVOWNjIghx0aAADsI5thJcwqQAAAAABJRU5ErkJggg)r85(iVBORw0KGgoAAAAN
SUhEUgAAADcAAAAJAQMAAACsZSbYAAAABlBMVEUAAAD///+l2Z/dAAAAOklEQVQI12NgAAH5HwwThBjYHyiwMHiorOpQUJnCoOLB
ILRQawmD0AQGRf1VR+B8DxUGDpA8TD1UPwA0+Q+Fiuq8wwAAAABJRU5ErkJggg)rf5(iVBORw0KGgoAAAANSUhEUgAAADAAAAAQCAYAAABQ
rvyxAAAAvElEQVRIx82V0RHEIAhEV0q5JlLM1ZdibCKtmB9vJmPg1FVMmMknPFhwA9wj5W9GzKylhpTAI+444g4SfG1Yq5W8BxhS
uzJ8GhBmyQB/IzdfbuudAyjNum1Dem66Agyf7TtjQIup8qUG+ilV3LeXsySLafFDeZMN6wcAZLWDcRpMDYovDNjB72m+dD6+2tpZ
9Wm+LHYftz9xs4OMuI9HDWoDyvq7GjAMgMqXiUo+kh96HaFBvaX5MuocT+efVe6L32f2dpAAAAAASUVORK5CYII)rbc4(iVBORw0KGgoAAAAN
SUhEUgAAAQAAAAEACAYAAABccqhmAAALi0lEQVR42u3dTWhUVxsA4DOhi6BkOZt2USIEpBtRBBeVj+5EF4VIQQRDV5YWlHTTjXRZ
uukmoUJLXZUIIhQDXSjuSokLQRQ3RQgYuvDbZBmUrLzfJme+M2fuvXPnJ84kPg8MSZw5956ZnPc9P/ee2Aq9vg4h/BLKfRNC+DXU
G7X8QIoQinCAtUJoLbZXOu9hffvbVvr82bnlnve3sbPaKjtWk9dWnausbJ38uKOWH5fF9kqRf4bTYhrr1ioL3KV2u/TFa9vbdYHc
Kf/x3x+Wlv/3P/8deyI4DAmgLDij7d2tMEoCaM/O97yuqhE2DeJBzt+v/LiCIp67PTvf+cz2K8kMWvdJ1K2pmTR4l9rtyuCPiWHv
+V/2ynQF/8d/f1gZ/DEx7D2fl2cvMPMG1Z6d7wnis3PLRRps+c9V5cqOXxfYa3/90fX83QfHwt0HxyrrX/Z8foxxNvyy9xzdePso
3D96uuhXftCRy6BJ7/7R08WNt49qE/I0jACKusCvGQ10ytcFfs1oYOTGcJhGAGmjCSGEW0euVJbb3t3qBNPZueWirmFdfXM7hBDC
hddPaj/vVxurxaXzL0ufS49flUTSEUzZyCUmiY/OLveMevJj3j96usjru9heKW6ut8JHZ5dbdaOd/P3GY8Vz3Vxvhfx9buystl5t
rBbXFovGdUnf590Hx8K1xaLz+aRl8t9n+tlMeiQwM2JP/PUYylMS/LGhxsfVN7e7Gk57dj4stleKxfZKV/Bv726Fq29ud5UtO3aZ
a4tFV6DH3nuYXiuWSUcA7dn5TpBUJZP7R08XdQF36fzL2l43fkYnHi51HatsepX35DEp5K+98PpJKx6ryVRqsb1SpGVOPFyqTYqT
HgEM3PvnawKD9v5NRwEnz5z8LYQQnj1+9tX7MgKIDfbVxmpx5s+fw+PPr4f49fm5tRBCCD/OfNrVe8SAiEPNEw+XQl72o7PLrbLA
Kmu8eUNt0vs3GQW0Z+dLy8cyac+d1rWsTlVJ5+qb2yEGXJrY+q2rlB0r1jXWJe/J17e/7RqJ5IkyTb4hhPD83Fq4deTK1I0AptLJ
Myd/u/P7nXDn9zudRPA+9P5pQ8vFhp3OKdM5b/qaQY+dBnhsyHFOHxtyHNrW1T8Gzc31VteaQFXwV01FTjxcCq82VotXG6uNgz9N
fmf+/Lk0EJv2wtu7W53zx7o0KVN2zlif+LuZpnWAmWkO/uh9SQKxx4tfH39+PaRfn59b6zyX9hzx+wuvn7TiKCEvmx+7XxK4++BY
WP3+p7D6/U+dBt1vBBETTGz8sfzdB8caBf+tI1d6AjiWT6cT+cJi7vHn1zvvO9Z/e3erNvjzY8f3nwdw3bpMfp5YPq3PtJkJTK00
AMsSRb9/qyrf1PIP34XlH76rXaeo+7eq8vncOw/MqoBZ+uyLrq8x+eU9aj4CqAryfseuq8/27lbXWkTdscvq056dn4pLgVO7BpCO
Ai5/eblyHeAwXgWIc970klpcna7rhdMFr3QIeun8y0ZD8HSaULaOEEchcR0iXYPIpyBl6xf53D5dv4hBfHO91QmWNOjiPD5PFhs7
q618DSGfBlVd2aibSuRD+FifqnqUyS+Jxs8uXUOYdPv7YFoD49njZ19d/vJy30XAwyZd8IoNNzbKxfZKcaGm0aSr3dcWi65Gur27
1ffGlTRAX4WlnsSaL0Kmfpz5NNx4+yg8P7dWug5RFvx5j9qenQ/Pz62Fxw+vVy7ipTfTVMkXPAdZREzPGZNAV/LLFvHqjhUvdzZd
f5nUCKBzE9AQvf83ez/+MuR9ACPfEXgY7wSMDWztrz/C0mdflN7QU5U88qCKx0gbeF0SSBtpGsjPz62FH2c+7buAtb27FW68fdRT
tmqqkq+ip+VjufwyXnodP44A0hX7svPkn21Zb50mmnTBM9Ylvv+6BFD1Gef1mpbbgmdGDMBfx1CepGGnjSsG7jDXj2OZdE67vbvV
c2mqbi3h2mLRedw6ciXk9xvEOwvz+xNuHbnSVbZunaIqgOKUIfacTZNeWqYsad59cKzv3DudaqULq3XJb2NntRWH/FU3ElUlpUmP
AMKgo4Ck9/81Ld90FDCu3v8wrgHkC0tpAMcGlt5Jl4qXqtI5b36MJgtPg+5JGHUPQjxGLBNHAf2SRiwzbE8a6133mcREko5+8rsw
h13Mm4ZRgM1AU5QAJrEZZ5TAb3L+polg2A0z7yKI9mszz7QlgJ5ALmE78D4lgElux52G7cjTFBTTHLDvIgEcKKMmgFH344/h/OMs
Vuxj2yj2uXxr8F99T7ligGMWYzr/uziXBLCfCWCUIfA4EsA/p04NVOaTp09LA2zI4/Scv+nxx1k+ft9UUqazI/XewkLXay5ubla1
8SI954jnL6tL17kGqJcEMMkEMEwiGNP5i39OnQovdnZqX3t8bq4qyLqCq8lxysq/2NmpapzFvYWFgc7f7zhJ+YETV0kdeo4RP4OS
enReW5XAhk2gJUmgE/zpZ1eTJN+5DwI94h1l6X3f+WLWfm3t3Guwlb1OdG9hIVzc3Czi902Pkb+2SY7tE/whhND65OnTTmAdn5tL
69eokZclrXjOuueqEsjxubmycpXJZoTz56OCnvc8yGslgAnL9+NH+Y0w7dn5sDi7UoTtb9/ZyCwNsgGnB8PO45sE/9iSQJ640vda
91xVr5wFXu1nlx8/TZR1z/UL7FiHUUcb+8VmoBIXXj9pxXvhQwidnWA33j7q/GGOeCPMIf0IigGDP00CXT3fXrAUAySfVs054nOt
fM7+YmcnrV/n+Xj+fIqSlk/LNTh3adJJRwl75+oM//N69ZuiSQAT7P2H3Y+/HwGYP2IjLmtA8d9i46t49HVvYaHzSIfAA8xZuxp5
TALxMeZRUt/6JEmobH2i1fQ4/epxcXOz6/eSJ89pZQqQ9fzx66uwVFTtx79/9HSxH1s5j8/N9R0ili1uXdzcLO4tLIQXOzuNjlF3
/rogimsOFdOUoqrxjxoIw0wnqubyDVbgiyGDtxV/D8fn5g5E8EsAfcS99Pme9ib3tI9b0njLArCVBud+9D4xsSQJKA3GytXucZ5/
lCSwz8FfmgQkgANqsb1SXDr/Mtx98P/Av7ZYhPU+W1rHEeQj9FytZNGqyIfwTXr6kiTTs8AVV9fLrkLkC15VU4xBgyOObIZNAsME
fzznYU8C1gBKgj/dj3/p/MvOjrb411738/wXNzc7j3Qenczt+64fpCvgsfHHx4Dz61bZwltZw86Cv1XxGHnkM+TCYt91ljxg8zl9
g+McSBJAFvzpz2V/3ukdbeEsXVhqkATqbsiZ6isWWZLrvI9Y//zqQs06R11A9iyopiObKCaxmHjyeuUJsGTh9cAkClOARP4fRqT7
8Sf0l1x7hpM1N5A0vRuvaa9WOgXoJ6nfUGruaGz1uw+i7ipD0ysQ+dWOpgur4zi3BDBh+f84k+6lT/9G3/rZqUsCYwv+po01vwqR
36U4yPsrC+yK4XdlEqibbzedi1dd6ixbD0hvQx7X+SfSwxz0oB3nXoBh9tPvx2agSWzGGcSYNyMd9M08xZg2M0kAk0wAw+6n38ft
wO96O+44ql2MeKyDuJ23GPH8EsAkE8AUDMEO6+3EHACuAoAEAEgAgAQASACABABIAIAEAEgAgAQASACABABIAIAEAEgAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvJf+ByKGJKuEzV1gAAAAAElFTkSuQmCC
)t0s2rf88(vu7uUAHCACoAKiNYgAAaLIAAUXiAAAxogAATQIAAVFKAAIASgAAAAAAAiQ3Dhk/Hg8qCi8kCPz8/NIpPh4PKgT8/PyOMD4KK
T0WDyoGLygI/Pz8hjA+CiE6xi8oBPz8/I4wMhIvJAoPKgT8/PyKDyoE/Pz8jjQ+Ej5JLj5GLg8qCi8oCPz8/JIPKgT8/PyKODcOD
yoGLyQI/Pz8ij5JIj5GHg8qBPz8/I4oPgoPKgYvKAT8/PyGMD4SLygKDyoE/Pz80jQyEj5KLj5DLi8kCg8qBPz8/I4PKgT8/PyON
D4SDyoGLygI/Pz8jjpDFj5KFg8qBPz8/I48NxI9txoPKgYvJAj8/PyKPcMWDyoE/Pz8jjA+Cj23Ei8oCg8qBPz8/IokPhI5uRIvK
AoPKgT8/PyKLDIWPcUaDyoGLyQI/Pz8ij25Eg8qBPz8/IowPhY9ug4PKgYvKAj8/PzSPcYWDyoE/Pz8jjQ3Fj26Fi8kCg8qBPz8/
Io9vB4PKgT8/PyOPDYOOcgaLygKDyoE/Pz8ijm8Gi8oCg8qBPz8/Io8NRY9vRYvJAoPKgT8/PyKIckWDyoE/Pz8jjw0Gj2+Fg8qB
i8oCPz8/IYhyhILKgT8/PyOPDMWPT8mLyQODyoE/Pz8jjU+Hg8qBPz8/NI8OgopOhYvKAoPKgT8/PyKMDoKPTaODyoGLygI/Pz8i
jQzDg8qBi8kCPz8/IoPKgT8/PyOPDoSDyoKLygI/Pz8ig8qBPz8/I44NRYpNSI9tRoPKgYvJAj8/PyGMbgeTKj8/PyKMDwOPbsiD
yoGLygE/Pz8ijA8EjW+Ji8oCg8qBPz8/NI8NQoxwRovJAoPKgT8/PyKOcQeDyoE/Pz8jjA8FjXHFi8oCg8qBPz8/IYhyhYPKgT8/
PyOODAiIctuPkM6Pks6LyQKDyoE/Pz8jjA3Gkyo/Pz8ijA8Fg8qBi8oBPz8/IowMCIySFo+P1ovKAoPKgT8/PyOKDceLyQKDyoE/
Pz8jig8Gg8qBPz8/IowMCYvKAoPKgj8/PzSMDceDyoE/Pz8jjA8Gj4/Oj5DNi8kCg8qBPz8/IZMqEo4MBz8/PxGMDciLygKDyoE/
Pz8ijA8Gj4/Yj48XiskFg8qBPz8/Io4MB4PKgYvKAj8/PyOODceDyoGLyQI/Pz8iig8Gi8oCg8qBPz8/IYwMCIvJAoPKgT8/PyOO
DIWPL4OPLkKPLIOPT8OPr8aLyQODyoI/Pz8yiS+BjyyBjC5BjU+CiK+Fg8qBPzCHLIKMLkGPL4E/L48OQo8vgo8uQo8sgo9PQouv
RovKAoPKgT8/PyGLDkKLLkKPL4KPLIKPT4KJr4aLygKDyoE/Pz8hiwyEjC+Ciy5CjyyCj0/DiK/Fi8kCg8qBPz8/II4uQo8sgo8v
go1Pg4qvhoPKgT8/Ao8uQY8vgY8sgT8vjw5FjyyCjy5Cjy+Cj09Diq9Gg8qBi8oCPz8/IYcuRI8vhI8sg45Pg4uvhoPKgT8/PyKN
DISPLIKPLkKPL4KPT8SPr8aDyoGLyQI/Pz8hjy+Bji5BjyyBjE+DiK+GgcqBPzCPL4GLLkGPLIE/MI0OQo8sgo8uQY8vgY9PRIiv
RoPKgovKAj8/PzKLDkKNL4SDLkOPLIKPT4KJr4aLygKDyoE/Pz8gjg6GjyyWjy5Ujy+Sj1CYj7Cdi8kCg8qBPz8/IowOR5MqPz8/
I44OBoPKgYvKAj8/PyKMDkWDyoE/Pz8ijw3Fjy3Djy+DjzDCj0/Cj6/Gi8kCg8qBPz8/II8vgY8wwo8twY1PgYqvhoPKgT8/A48v
gYgtwY0wwT8viw+Cjy3EjzDCjy+Bj09CiK9Gi8oBg8qBPz8/IIsPg48vgo8wwo8twotPgoivhovKAoPKgT8/PyCJDcSPMMKPLcKP
L4KPT8OLr8aLyQODyoE/Pz8ijy3BjjDBjy+Bj0+Ch6+Gg8qBPy+NMMGPL4GPLcE/MY8PhY8vgo8two8wwY9PQ4evR4vKA4PKgT8/
PzKPL4KPLcKPMMKNT4OIr4c/Pz8jjA3Ejy3BjzDBjy+Bj0/Eiq/Gi8kCg8qBPz8/IY8wwY8vgY8twY5Pg4ivhoPKgT8wjzDBjy3B
jy+BPzCPD4KPLcKPMMKPL4KPT0SJr0aDyoGLygI/Pz8hjQ+Djy+Bjy3BjzDBjU+Cia+Gi8oCg8qBPz8/IY4Px48w1o8t1Y8vlo9R
lI+xlIvJA4PKgT8/PyOMD4eDyoE/Pz8jjg9Gi8oCg8qBPz8/M44Ph4PKgT8/PyKPDIWPLkGPL4KPLIKPT8SPslKDyoKLyQI/Pz8g
jy+BjC5BjyyBjU+Cg8qBPy+PL4GILIGPLkE/MI8OQo0sgYssgY8uQY8vgY1PQ4PKgovKAj8/PyCKDkSPLkGPLIKPL4KOT4SPspaL
ygKTKj8/PzOJDIWPLIGPLkGPL4GPT8SDyoKLyQI/Pz8gjyyBjy+Bjy5BjE+Dg8qBPzCILkGIL4GILIE/MY4ORI8vgY0uQY8sgo8v
gY8uQY9PQ4PKgYvKAj8/PyGPLkKPL4KPLIKMT4OMskGDyoE/HIyygT8KjbJBN4wMho8sgo8uQY8vgY9PxI+xhoPKgovJAj8/PzOP
LIGOLkGPL4GNT4KHsUU/L40uQYgsgY8vgT8wjQ5CnLKPL4GPLkGcso9PQ4aww4PKgYvKAj8/Px+LDkWPL4KPLkGPLIGNT4OKsIGL
ygKDyoE/HIqwwTaLsIE/CowOho8vlI8slY8uV49PxI+vxovJAoPKgT8/PyGJDkgSiU+Ch6+Fg8qBPz8/IowOBYtPQoOvB4vKAoPK
gT8/Pw2Gr4YSig5Gjk+Dg8qBPz8/IY8NxY8vgo8wwo8two9Oto+v1YPKgovJAj8/PyKPLcGLMMGPL4GDyoE/MI8wwYgtwY8vgT8w
jA+Ejy3Bjy+CjzDCjy3Bg8qCi8oCPz8/M40PhI4wwY8two8vgo+unovKAoPKgT8/PyCMDcWPL4GOMMKPLcGLyQKDyoE/Pz8ijy3B
ijDBji+BgMqBPzCIMMGIL4GILcE/MY0PhI4wwY8vg5y3nLePMMGDyoGLygI/Pz8gjzDBjy3Cjy+BgMqBPz8/IY8Nx48vg48tw48w
wY9N4Y+uVIvJAoPKgT8/PzSMMMGPLcGOL4E/MIgtwYswwY0vgT8xjQ2Gji3CjzDCjy+Ci8oCPz8/Io8wwY8two8vgY+uiovKAj8/
PyOPDUiPL5CPLdCPMNCLygI/Pz8ji8oBPz8/Io0NBovKAj8/PyOLygI/Pz8kjwyGjyyCjS+Cjy5Cj0/Cj6/Gg8qBi8kCPz8/IYgs
gYguQYgvgY5PgoavhoPKgT8wji+Biy5BjyyBPzGPDkKPLkKPL4KPLISPT0OHr0aDyoGLygI/Pz8hjA5Djy5Cjy+CjyyCj0+Eia+H
i8oCg8qBPz8/M44MhI8sgo8uQY8vgY9PxIyvxovJAoPKgT8/PyKPL4KOLkKPLIGNT4OIr4aDyoE/LogsgY8uQY8vgT8xjw5Ejy+B
jy5BjyyBjk9Ehq9Gi8oCg8qBPz8/IY8vgo8uQY8sgo9Pg4evhoPKgT8/PyCIDIaPLkGPLIGPL4GPT8SLr8eDyoGLyQM/Pz8zjy+B
jyyBjy5BjU+Dh6+GgMqBPzCOLkGPL4GPLIE/MI0OQ48uQY8vgY8sgYxPQ4ivRoPKgYvKAj8/PyGLDkOPL4GPLIKPLkGOT4KJr4aL
ygKDyoE/Pz8gjQ6HjyyQjy+Qjy5Qj1CVj7CXi8kDg8qBPz8/I4sORoLKgT8/PyKPDgaDyoGLygI/Pz8hjA5FgcqBPz8/M48NxY8t
wo8wwo8vgo9PxI+vxoPKgYvJAj8/PyGKMMKML4GPLcGMT4OIr4aDyoE/L4gtwY4wwY8vgT8wjA+Cjy3FjzDCjy+Cj09DiK9Gg8qB
i8oBPz8/IYsPgo8two8wwo8vgo9Pg4qvhovKApMqPz8/IYoNxI8wwY8two8vgY9Pw4uvxoPKgYvJAj8/PyGPLcGPMMGPL4GMT4SL
r4eCyoE/PwSOMMGILcGPL4E/MY8PhJy3jzDCjy+Cj09DiK9Gg8qCi8oCPz8/IogwwY8two8vgo5PgoivhoPKgT8/PyGMDcSPMMGP
LcGPL4GPT8SMr8aDyoGLyQI/Pz8ijy3BjTDBjy+Bi0+Diq+GPzCILcGIL4GIMME/MY8Pgo4wwY8two8vgY1PQ4ivRoPKgYvKAj8/
PyCND4SPL4KPMMKPLcKNT4KLr4aLygKDyoE/Pz8hjw/GjjDLjy+Mjy3Lj1GTj7GUi8kCg8qBPz8/NIsPhj8/PyKJD0aDyoGLygI/
Pz8hjQ+Fg8qBPz8/I4wOgoUMwo8vwo8ugo8swo9RgoKM6oKN6oKOqY6xhYPKhIvJBInMQz8/PyGNDMGLDoGPL8KPLoKPLMKNUUKN
sUSDyoI/Pz8hiw6CjAzCjyzCjy/Cjy6Bj1CCh7CCi8oCg8qCPz8/IosOgooMwY8swY8ugY4vwY9RgoixhIPKgovKAj8/PyGNDoKM
DMGPLMKPLoKPL8GOUUSPsUaLyQSDyoI/Pz8yjA6BjwzBjy6Bjy/BjyzBjlCCirCCPz8/IY0OgY8MwY8ugo8swo4vwY9Rg4uxhovK
A4PKgj8/PyCPDMGJDoGPLMKPL8GPLoKOUUKIsUKAyoE/Pz8hjQwCjw3Cjy8CjywCjy3Bj1GCgY8ogo3ngYzoj7GFg8qCicxCi8kC
Pz8/IYoNwosMAo8sAo0twogvAo1RRIqxRj8/PzSKDcKODAKNLAKLLcKLLwKMUMKHsMKDyoGLygKDyoE/Pz8iiw3BiwwCjiwCjS8B
jC3Bj1GDiLGFi8oCg8qBPz8/IYsMAogNwY4sAowtwo8vAo1RRI+xRovJAoPKgT8/PyGMDAKLDcGPLAKMLcKPLwKLUMKNsMI/Pz8h
jQwCjg3CjywCjy8CjC3Bj1GDiLGFi8oCg8qBPz8/IYwNwo0MAowtwY4vAY0sAo9RQoaxQ4LKgT8/PzKPDLOPDnWPLLePLnaPL7aP
UYOCjLeCjnaCjbaPsYWLyQODyoKJzEI/Pz8jjVFDirFGg8qCPz8/Io5Qg4+wh4PKgYvKAj8/PyKPUUKOsUaLygKDyoE/Pz8gj1CC
j7CFi8oCg8qCPz8/Io9Pg4mvh4HKgT8/PyOJUIKDyoKLygISirCFPz8/D4tPg4qviD8/PzOPDIWPLkKPL4GPLIKPToKProSLygKD
yoE/Pz8gjE+Eiq+HPz8/I48NBY5Og42uhYvKAj8/PyGLTcSNrceLygE/Pz8jjQ1Hj05Mj65bi8oCPz8/Pz8/PwaPDYeLygE/Pz8/
Pz8/Bw)s6r4a4(vu7uUAITACoAKgAAAAASZIAAJkyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiDCJiDGIiEnJPz8/PyOHSoo/Pz8/DYgwiIgxiIhL
iD8/Pz8NiEzJPz8/Pw2IMIiIMYeIS4s/Pz8/DYdKhj8/Pz8MiDDpiDGqiErLPz8/Pw2HS4o/Pz8/DIZMiD8/Pz8Nh03SPz8/Pz8/
Pz8/Pz8/J4gwh4cxhodJyT8/Pz8NhkqKPz8/Pw2HMIiHMYaGS4Y/Pz8/DIhMyj8/Pz8NhzCHiDGIh0uIPz8/PwyHSoY/Pz8/DYkw
1YgyFohKyj8/Pz8Nh0uGPz8/PwyGTIg/Pz8/DIkw0YgxkYlNzD8/Pz8Nh0yIPz8/PwyHS4U/Pz8/DIgwiIgxiIhJyj8/Pz8Nh0qJ
Pz8/Pw2IMImHMYiGS4o/Pz8/DYdMyj8/Pz8NiDCIiDGIh0uLPz8/PyKHSoc/Pz8/DIkw0YkxkohKyz8/Pz8Nh0uPPz8/PwyHTIg/
Pz8/DIgvjYgwz4hNyz8/Pz8Nh06IPz8/PwyHT4Y/Pz8/DIcvyogwS4dLij8/Pz8Nh0xGPz8/PwyIL0eIMEiHTUg/Pz8/DYdOiT8/
Pz8NiC9IiDBIh01IPz8/Pw2HTEc/Pz8/DYgv6okwaIhMDD8/Pz8NhkzLPz8/PwyHTcg/Pz8/DIdPCD8/Pz8NhE3IPz8/Pw2GTMY/
Pz8/DYgvyYgwSYdLiz8/Pz8NhkxOPz8/PwyHL0iIMEiGTUg/Pz8/DYdOij8/Pz8NiC9IiDBIhk1KPz8/PyKHTEg/Pz8/DYgwYIcx
oYhLiD8/Pz8NhkxKPz8/Pw2FTUg/Pz8/DYdOlD8/Pz8/Pz8/Pz8/PyeIM5GHTMk/Pz8/DYVNiD8/Pz8NiDNRhk6IPz8/Pw2HT8g/
Pz8/DYcy0YZOiD8/Pz8Nhk2IPz8/Pw2HMbKITcc/Pz8/DYVOij8/Pz8Nh0+IPz8/Pw2GUMg/Pz8/DYVPiD8/Pz8NhU6IPz8/Pw2I
M5CHTMs/Pz8/DYZNiT8/Pz8MiTNThk6IPz8/Pw2IT8g/Pz8/DYcyz4ZOjz8/Pz8MhU2FPz8/H4YyQyyHMpmHTcg/Pz8/DYZOij8/
Pz8Nhk+HPz8/PwyIMZqHUMc/Pz8/DYZPij8/Pz8NhU6FPz8/PwyHM5CHTMs/Pz8/DYVNiz8/Pz8iiTNRh06IPz8/Pw2HT8k/Pz8/
DYcy0IZOiT8/Pz8Nhk2HPz8/Pw2IM1KGTAk/Pz8/DYZMyD8/Pz8NhzLShU3KPz8/Pw2HTws/Pz8/DYYyDoZNxj8/Pz8MhkzHPz8/
Pw2IM5GGTIw/Pz8/DYZNiT8/Pz8MhzLQh05IPz8/Pw2IT4k/Pz8/DYkykIdOST8/Pz8Nh02IPz8/Pw2JNFiITMg/Pz8/DYZNiD8/
Pz8Nhk6IPz8/Pw2INJQWhk/IPz8/NoZOiD8/Pz8Nhk2GPz8/H4Y0QiyINI6HTIw/Pz8/DYdNij8/Pz8MhzRShk5LPz8/Pw2HT4c/
Pz8/DIVOSxaIM5A/Pz82hk2HPz8/PwyIMqiHTIg/Pz8/DYdNhz8/Pz8Nhk5HPz8/Pw2HT48/Pz8/Pz8/Pz8/Pz89)s1r11fb(vu7uUAIsACoA
Kgh+gAAEUIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhxCJiCrHPz8/PxqHEMiHLcg/Pz8/GogSmocuiD8/Pz8aiC3HPz8/PxqI
LIk/Pz8/GYcQioctyD8/Pz8aiBDKhiuIPz8/PxqIElGILcg/Pz8/GogqyD8/Pz8ahxCLhy3JPz8/PxmIEMiGLog/Pz8/GogSE4ct
yD8/Pz8ahyyIPz8/PxqIEcmHLcg/Pz8/GYgRiIYriD8/Pz8aiBFJhy3IPz8/PxqIEIqIKsg/Pz8/GokQyYctyT8/Pz8aiRKghy6I
Pz8/PxmGLcg/Pz8/GocsiD8/Pz8ahy3JPz8/PxqHK4g/Pz8/GYcUgYgtyD8/Pz8aiRS2iSrIPz8/PxqHLck/Pz8/GocuiD8/Pz8a
hi3IPz8/PxmHK4g/Pz8/GoctyD8/Pz8ahywIPz8/PxqHLcg/Pz8/GYcRCYgsSz8/Pz8ahhCIhi4JPz8/PxqHEmOGL0g/Pz8/GoYv
yD8/Pz8ahzAIPz8/PxmHL8k/Pz8/GoYvSj8/Pz8ahxQDhS4IPz8/PxqHFBuHLEk/Pz8/GYYuCT8/Pz8ahi9IPz8/PxqHL8k/Pz8/
GocUgocwBz8ZhhTDPyiFFIM/GIYUCIYvyD8/Pz8ZhxOJhy9JPz8/PxqHEwqFLgg/Pz8/GocSyIYsST8/Pz8aiBJJhi4JPz8/PxmH
ESuGL0g/Pz8/GoUvyD8/Pz8ahjAIPz8/PxqHL8w/Pz8/GoUvSj8/Pz8ZiBCJhi4HPz8/PxqIETOHLEg/Pz8/GoUuCD8/Pz8ahi9I
Pz8/PxmFLgk/Pz8/GocsSj8/Pz8/Pz8/Pz8/Pz8/Pz8/KIgQiYcqyD8/Pz8aiBDIhy3IPz8/PxqIEpqHLog/Pz8/GoctyD8/Pz8g
hSyHPz8/PxKIEIkHhy3FPz8/PxmIEM0BhiuHPz8/PwiGLckQiBJQPz8/PxmIKso/Pz8/GYgQiQmILco/Pz8/DokQyQyJLoc/Pz8/
FokSDwOHLcc/Pz8/GocsiD8/Pz8TiRHJB4ktyT8/Pz8TiBGKB4crij8/Pz8RhxFHCYYtyj8/Pz8OhxCKiCrJPz8/PxqIEMuGLck/
Pz8/GYkSooguiD8/Pz8aiC3IPz8/PxqHLIk/Pz8/GoYtyD8/Pz8ZhiuIPz8/PxqHFIGHLcc/Pz8/GokUsYgqyD8/Pz8ahi3JPz8/
PxqGLog/Pz8/GYYtyD8/Pz8ahyuIPz8/PxqHLcg/Pz8/GoYsCD8/Pz8Zhy3IPz8/PxqHEQiHLEk/Pz8/GocQiYYuCT8/Pz8ahxJi
hy9IPz8/PxqGL8g/Pz8/GYcwCT8/Pz8ahi/JPz8/PxqHL0k/Pz8/GocUAoYuCD8/Pz8ZiBQahyxIPz8/PxqGLgk/Pz8/GoYvSD8/
Pz8ahy/JPz8/PxqGFIKHMAc/HIcUwz8whhSDPwyGFAeHL8g/Pz8/GocTiYcvST8/Pz8ahxMJhi4IPz8/PxqIEsiHLEg/Pz8/GYcS
SYYuCT8/Pz8ahxEshi9IPz8/PxqGL8c/Pz8/GoYwCD8/Pz8ahi/JPz8/PxmHL0g/Pz8/GocQiYYuCD8/Pz8ahxE0hixIPz8/PxqG
Lgk/Pz8/GYYvRz8/Pz8ahS4IPz8/PxqGLE8/Pz8/Pz8/Pz8/Pz8/Pz8/PyiHEYmGLMs/Pz8/GocRSYUuiT8/Pz8ahhCKhi/IPz8/
PxmHEYqGLok/Pz8/GogRSYYsyT8/Pz8ahxCJhi6JPz8/PxqIEYiHL8g/Pz8/GogRSYYuiD8/Pz8ZiBGKhyyHPz8/PxqHEUmGLkg/
Pz8/GocQiYcviD8/Pz8aiBFchy5IPz8/PxmHLIk/Pz8/GoYuST8/Pz8ahy+JPz8/PxqGEUmHLkc/Pz8/GocRCoYsSj8/Pz8ZhhCI
hi4IPz8/PxqHEEmHL0g/Pz8/GocRCYUuCT8/Pz8ahxCIhixJPz8/PxmHEEiGLgo/Pz8/GocRCYcvRz8/Pz8ahxBIhS4HPz8/PxqH
EUqHLAo/Pz8/GocQiYctiD8/Pz8ZiA/Dhy8KPz8/PxqHEgmGLYk/Pz8/GocRSYcsCT8/Pz8ahxCJhy2IPz8/PxmIEsiHLwk/Pz8/
GogSB4ctiD8/Pz8aiBFJhywJPz8/PxqIE4qHLYg/Pz8/GogSx4cvCj8/Pz8ZhxIJhy2HPz8/PxqIFEmHLAk/Pz8/GocTiYctiD8/
Pz8ahxRIhy8HPz8/PxmIFQmHLYk/Pz8/GocV/Ycrij8/Pz8ahi1IPz8/PxqGLoc/Pz8/GoYtRz8/Pz8ZhiuLPz8/PxqGLUk/Pz8/
GoYuiT8/Pz8ahxWChi1IPz8/PxmKFauHK4k/Pz8/GoUtSD8/Pz8ahS6HPz8/PxqFLUg/Pz8/GocrjT8/Pz8/Pz8/Pz8/Pz8/Pz8/
KIgPSIcrkD8/Pz8ZiA+IPz8/PxqIEEmHLUOHLoM/Pz8/GogPSYgtRocuhT8/Pz8ahw+IiCuQPz8/PxqIEYk/Pz8/GYkPSYctQogu
gz8/Pz8ahw+JPz8/PxqJEMiHK5A/Pz8/GocPSj8/Pz8ZiA+Ihy1EiC6DPz8/PxqJEFOHLUOHLoM/Pz8/Gocrjz8/Pz8aiA/JPz8/
PxqID4mHLUSILoQ/Pz8/GYcPCT8/Pz8aiA+MhirRPz8/PxqHD8g/Pz8/GokQyYgsg4ktwj8/Pz8Zhw+KhyyBiS3BPz8/PxqJD8mI
KtE/Pz8/GogRiD8/Pz8aiA+JiCyBiC3BPz8/PxqHD8k/Pz8/GYkSSIkq0D8/Pz8ahw+JPz8/PxqJD8iILIGILcE/Pz8/GocSk4cs
goctwT8/Pz8ZiSrQPz8/PxqIEkg/Pz8/GokSB4gshIctxD8/Pz8ahxGJPz8/PxqHD0qIK5E/Pz8/GYYPiD8/Pz8aiRBLhy1Bhy6D
Pz8/PxqID0iHLUGHLoM/Pz8/GogPiogrkD8/Pz8ZhxGKPz8/PxqJD0iHLUSILoM/Pz8/GogPiD8/Pz8aiRDIhyuQPz8/PxqHD0k/
Pz8/GYgPiYctQYcugj8/Pz8aiRBUhy1Bhy6DPz8/PxqHK48/Pz8/GoYPyD8/Pz8ZiA+IiC1DiC6DPz8/PxqGDwk/Pz8/GogPmogq
zz8/Pz8/Pz8/NIgsgogtwT8/Pz8ZiA6bhyyBiC3BPz8/PxqGKtA/Pz8/Pz8/PzSHLIGILcI/Pz8/GYgOiD8/Pz8ahw5biCrSPz8/
Pz8/Pz80iCyBiC3BPz8/PxqIDp6ILIGILcI/Pz8/GYgq0D8/Pz8/Pz8/NIgsgoktwT8/Pz8/Pz8/M4gPSIcrkD8/Pz8ahw+IPz8/
PxqIEEmILUGHLoI/Pz8/GogPSYctQocugj8/Pz8aiA+JhyuNPz8/PxmHEYo/Pz8/GocPSIctQogugj8/Pz8ahg+IPz8/PxqJEMmI
K5A/Pz8/GYcPST8/Pz8aiA+Ihy1BiC6CPz8/PxqJEFOHLUGHLoE/Pz8/GogrkD8/Pz8ahw/IPz8/PxmID4iHLUGILoM/Pz8/GocP
CD8/Pz8aiQ+LiCrQPz8/PxqGD8g/Pz8/GYkQyIgsgoctwT8/Pz8aiA+KhyyBhy3BPz8/PxqID8iIKtE/Pz8/GocRiD8/Pz8aiA+J
iCyBiC3BPz8/PxmHD8g/Pz8/GogSSIgq0D8/Pz8ahw+JPz8/PxqHD8iHLIGILcE/Pz8/GYoSlIcsgYYtwT8/Pz8aiSrPPz8/PxqH
Ekg/Pz8/GogSCIcsgogtwT8/Pz8ahhGIPz8/PxmID0mHK5E/Pz8/GogPiD8/Pz8aiBBJhy1BiC6DPz8/PxqID0iHLUKGLoE/Pz8/
GYgPiogrjz8/Pz8ahxGJPz8/PxqID0iILUOILoM/Pz8/GogPiT8/Pz8aiRDKhyuQPz8/PxmHD0k/Pz8/GogPiIctQogugz8/Pz8a
iRBUhy1Bhi6DPz8/PxqIK48/Pz8/GYYPyD8/Pz8aiA+Jhy1BiC6GPz8/PxqHDwk/Pz8/GokPmogq0T8/Pz8/Pz8/M4gsgogtwT8/
Pz8ahw6biCyBhy3CPz8/PxqGKtA/Pz8/Pz8/PzOILIKJLcI/Pz8/GocOiT8/Pz8aiQ5aiCrRPz8/Pz8/Pz80hyyBiC3BPz8/PxmI
DpOILIGILcE/Pz8/Gocq0D8/Pz8/Pz8/NIgOkYcsg4ctxD8/Pz8/Pz8/M4gPG4gqUT8/Pz8ahiwIPz8/PxqHLUg/Pz8/GocOU4Ys
CD8/Pz8ZhipKPz8/PxqGLAg/Pz8/GogOUYctRz8/Pz8ahSwHPz8/PxmJDcmHKf8/Pz8/GocOSj8/Pz8aiA6IPz8/PxKIDko/Pz8/
GYgOiT8/Pz8ihw8JPz8/PxqHDok/Pz8/GocPCT8/Pz8ahw+IPz8/PxmGDwg/Pz8/GocPiT8/Pz8ahg/HPz8/PxqIEIg/Pz8/GocP
wT8lhxCDPyGHD8M/EogPhj8/Pz8aiA8JPz8/PxqID4qIKow/Pz8/GocOiYgshz8/Pz8Zhw5Jhy2IPz8/PxqHD8mHLIk/Pz8/GocO
iYcqiz8/Pz8ahw5KhiyIPz8/PxqID4mHLYg/Pz8/GYcOiYYsiT8/Pz8aiA5JiCqIPz8/PxqHD8mHLIk/Pz8/GogOiYctiT8/Pz8Z
hw5KhyyIPz8/PxqID4mIKoo/Pz8/GocOiYYsiD8/Pz8aiA5Khy2JPz8/PxqHDomHLIc/Pz8/GYgPiYcqyj8/Pz8ahw6JhyyHPz8/
PxqHDkqHLcc/Pz8/GocOiYcsgYUsgT8/Pz8Zhw+JhyrMPz8/PxqHDomGLIg/Pz8/GocOSYctxz8/Pz8ahw6JhyyIPz8/PxqIDeKH
Kss/Pz8/GYcsiD8/Pz8aiC3JPz8/PxqGLIg/Pz8/Gocqyz8/Pz8ZhiyIPz8/PxqHLcg/Pz8/Gocshz8/Pz8aiA+JhyqJPz8/PxqH
DomHLIg/Pz8/GYgOSYcthz8/Pz8aiA/JhyyIPz8/PxqHDomHKog/Pz8/GogOSYYsiD8/Pz8ZiBCJhy2JPz8/PxqHDomGLIg/Pz8/
GocOSYcqiD8/Pz8aiRDKhyyJPz8/PxqHDoaHLY8/Pz8/GYYOSYYsiD8/Pz8aiBGJiCqKPz8/PxqID4iHLIk/Pz8/GogRSYctij8/
Pz8ZiA+JhyyIPz8/PxqKEhyJKss/Pz8/GocsiD8/Pz8ahy3KPz8/PxqLEpyHLIg/Pz8/GYgqzz8/Pz8ahiyIPz8/PxqHLcoBihG2
Pz8/PxmGLIg/Pz8/GYgqzj8/Pz8ahSyJPz8/PxqILck/Pz8/GocsiD8/Pz8aiCpQPz8/PxmILAk/Pz8/GooOiIsRiYgtST8/Pz8a
hiwJPz8/PxqKDxqLEhuIKdE/Pz8/GYcriT8/Pz8aiCzJPz8/PxqJD5qJEpqHK4k/Pz8/Gogpyj8/Pz8ahyuJPz8/PxmKDfOKEPiI
LMo/Pz8/GocriD8/Pz8ahynJPz8/PxqHK4g/Pz8/GYcsyD8/Pz8ahSuJPz8/PxqHKc0/Pz8/GoYriD8/Pz8aiRDLhyzJPz8/PxmG
K4g/Pz8/GogRSIgqTT8/Pz8ahxBFhiwJPz8NiBFEPz8NiRIIhy1KPz8/PxmIEUSHLAc/Pw2HEgQ/Pw2KE0gKiCpOPz8/PxCIEgSH
LAg/Pw2JE0Q/Pw2KFEgIiC1LPz8/PxKHE0SHLAg/PwyGFEQ/Pw2KFR2IKk4/Pz8/GoYsCD8/Pz8ahy1LPz8/PxqHLAk/Pz8/GYkV
FYgqSz8/Pz8ahiwKPz8/PxqHLUk/Pz8/GoYsCT8/Pz8aiQ8SihITiSnQPz8/PxmHK4k/Pz8/GogsyT8/Pz8aig+SihKShyuJPz8/
PxqIKcs/Pz8/GYcriT8/Pz8aiQ3wiRDyiCzJPz8/PxqHK4g/Pz8/GoYpyT8/Pz8ahiuJPz8/PxmGLMg/Pz8/GoQriD8/Pz8ahynL
Pz8/PxqFK4k/Pz8/GYkQ0oYsyD8/Pz8ahiuIPz8/PxqJEGyHKk0/Pz8/GoUsCD8/Pz8ahi1IPz8/PxmGLAg/Pz8/GoYqUD8/Pz8a
hSwIPz8/PxqIEE+HLUk/Pz8/GYYsCD8/Pz8aiA8/iSpKPz8/PxqGLAk/Pz8/GoctST8/Pz8ahSwIPz8/PxmHKkg/Pz8/GoYsCD8/
Pz8ahi1IPz8/PxqGLAg/Pz8/GQ)t0s21r3b(6+sA1gBWHwQE+joUAwCZAwD//wAA3wIAFgAyANIAGQUBkADIAgMAAQAABAAH//8ADUjTACQd
ywCeAAA)r39(6+sApABpHAFMAgCT3AIADv//AK+z3AAjBAAHAOwAGQBFABgALACDAE4BAAADAAv//wAlLlgAdAAA)r42(6+sAnQBXHwILCSJTgbYA
QQASAAMCpgQA//8BAOkAAABYAQAFA20BAAAEAAT//wALKe4AGg9yAHQAAAUHCAAyAhQA)r2f(6+sBRACLAQUBAAAEAAT//wAsMI0AMg09
AOIAAAUCWAEsBQJYAMgICPwIB9ACUAA)r6d(6+sBqgCAFwIJD2fCAC8ACQAXA7MEAABBAgAfALoAigBOAQAABAAP//8AEzlhABgWEQBQAAAI
C7gIC7gCAgAEAEbMM4CAAf//AgBC//8BaAAAAAEFAQAABAAE//8ACWaeABso0wCOAAAFA+gBLA)r24(6+sBdABpAQUBAAAEAAr/vgAiIjQA
MA09ARgAAAUEsADIAgcA)r31(6+sBBABEHACAAgD//wEAGWWEAC8CABQA5QAwACYBAAAEABP//wAnWnsATBywAH4AAA)r36(6+sAZwAmHgoY8TYg
WBQHAAAAA8ADAP//AAv4AAEAAAQAC///AAs2EQAmD3IAKwAACCMoAgUA)r31(6+sBBABEHACAAgD//wEAGWWEAC8CABMBUgAvADUBAAAE
ABP//wAnWnsATBywAH4AAA)r46(6+sBCAAmHgoY8TYgWBQHAAAAA8AEAP//AAv4AAEAAAgABLhGAAj//wADncsACqRpAAfo0wALWEYAECe5
AM0AAAgjKAIFAA)r2d(6+sA1ACAAQUFAKoAKAUAqgAoAhQAAQAABQAIz3IAE///ABNnuQAzJYQAcwAA)r54(6+sCTwAzHgoY8TYgWBQHAAAAA8AH
AP//ABEcAAEAAAMAC///ABEsIwAcAAAEABKAgIDmBAAZs4CAzAH//wQAMf//ADOo0wF8RYQAbwAACCMoAgUA)r2d(6+sA1ACAAQUFAMgA
KAUAyAAoAhQAAQAABQAIz3IAE///ABNnuQAzJYQAcwAA)r2d(6+sA1ACAAQUFAPoAKAUA/wAoAhQAAQAABQAIz3IAE///ABNnuQAzJYQA
cwAA)r4c(6+sElgCqFgfXAAAYAAAEAxkDAA5QAQLsD6YBAAAEAA///wBIO5YAUx3LAl4AAAQAObOAgMwEACtms4DMAf//AwHORYQBN0Rp
AZEAAA)r2d(6+sA1ACAAQUFASwAKAUBNgAoAhQAAQAABQAIz3IAE///ABNnuQAzJYQAcwAA)r39(6+sCuwAoPgcGF8ZAEQQDAcUCmaaeAgDRunsC
TynuBdsABQAAFAEAAAQAC///ADMnuQA2E9wCRwAA)r4b(6+sDpACAFgoYAFIAAIQAfkEPAwADAAAmAAEAAAUABaRpABP//wAgTCMANhlh
AjsAAAQAKZlmgLMEADWzZoCAAf//AgEj//8CgQAA)r32(6+sBUgA8Fgv2AD4AEQAAAAAAAAOzBAAIoAABAAAFAAngAAAL//8AI1T3ADUh
GgDmAAA)r76(6+sCbQCAHQQCJgQA//8BAG9PcgfjAAEAAAQACf//ACJGngAeEsIAjAAABAAogICAzAH//wIAuf//AX8AAAAWCCAAWgB4k0MN
AuMCAAv4AAEAAAQAB///AB43LAAxEsIA0AAABAA1gGaAswFQjQIA1VcsAZgAAA)r38(6+sBOwBcHwQJBqVwQBEEAwAIASYCAP//AAryAAEA
AAQAC///ACQkaQArDlgA4QAABR9AAfQCCgA)r31(6+sAoQBDFgb7AC4ADQABTwEAA6MCAAoBiAAFBHsBAAAEAAf//wATOnsAGxPcAGwAAA)r5b(6+sD
wwBDPwQM8SEIAgEAAAAAAAAAA9kEAP//AAc3AQBYBa8PAAAyAQAAAgAP//8ANgAABAAbgOaA5gQAFbNmgMwIF3ACCgAB//8EAEP/
/wDBRGkBoT7lAR4AAA)r35(6+sBkgBXPgv5AEIAIAAMAAIAAAFMAYD//wAAUQAEAAlgAQAABAAE//8AEVlhACcjTwFWAAA)r38(6+sCJACAHgovIzFI
QiQAAAAAAwACAGjTAgAP//8B99PcCbgAAQAABAAW//8AHy5YADkPcgG2AAA)r32(6+sA5gCAFgf8ABYAAAgDAuYBAAHjAgAHAHcA6ACGAQAA
BAAJ//8AEjGnABkNPQCyAAA)r32(6+sA5gCAFgf8ABYAAAgDAuYBAAHjAgAJAFYA5gBzAQAABAAO//8ADyjTABcNPQCyAAA)r3b(6+sBOwCANgf7d0Mo
EggEAPUBAALIAgAWAHoBgQBeCAAAMgUAggBkAQAABAAk//8AMjCNAC4RpwC3AAA)r36(6+sBmwCANgf7d0MoEggEAPUBAALIAgAWAHoBgQBe
CAAAMgEAAAQAGf//ADEkaQA3DCMBGgAA)r36(6+sBmwCANgf7d0MoEggEAPUBAALIAgAXAEUBfQAzCAAAMgEAAAQAGf//ADEkaQA3DCMB
GgAA)r2e(6+sAgAAiFgc0l+JiMhcBAWYCAAAuAQCZCW8BAAAEAAn//wAYSNMAHBYRAEMAAA)r2e(6+sAgAAiFgc0l+JiMhcBAWYCAAAgAQCaA6MB
AAAEAAn//wAYSNMAHBYRAEMAAA)r2d(6+sAuwCAFgocM1FdTC4dDwgBAsUBAAy0AAEAAAQAD///ABQz3AAzB7kAZQAA)r2d(6+sAuwCAFgocM1Fd
TC4dDwgBAsUBAAlvAAEAAAQAD///ABQz3AAzB7kAZQAA)r30(6+sA0gCAAQUFG1gBkAEAAAcABv//AAsU9wAKFPcABnYRAA8gAAAZDCMA
iQAAAgoA)r70(6+sCZABPAQUBAAADABb//wA6TT0A1gAABABjgEyAmQQAb4BMgGYB//8CAUz//wDlAAAAFgUHNmc7BwSAAQAAQwIAGi8X
AX4bjgEAAAQAEv//AConuQAvCwgBEQAABAA/wECA5gH//wIBUf//ARMAAA)r2d(6+sBWgCAMgb4GQsABAEEewEBiwY3DAAAyAEAAAQAKv//
AFVOWABBGWEAmgAA)r2d(6+sCgQCAMgb4GQsABAEEewECoQaZCAAAyAEAAAQAWv//AFZAAABbEacBdgAA)r85(6+sBxgBcPgcJNFcjGAAHAMAB
AP//AQKmwAAA7AEB0gEKEAAAyAEAABcADf//AAYAAAAaAAAAFf//AAsAAAAeAAAADf//AA4AAAAiAAAAFJGnABgAAAAZAAAAEEAA
ABAAAAAeAAAADi9yAAkAAAAmAAAADRywAA4AAAAgAAAAEBLCABMAAA)ra9(6+sClgBcPgcJNFcjGAAHAMABAP//AQKmwAAA7AECvAE+EAAA
yAEAACAADf//AAYAAAAaAAAAFf//AAsAAAAgAAAAEv//AAkAAAAgAAAAFf//AAoAAAAhAAAAEv//AA4AAAAcAAAAF7lhAAcAAAAe
AAAAF4nuAAoAAAAdAAAAGE9yAAsAAAAgAAAAFCjTAA4AAAAhAAAADhp7AAwAAAAfAAAAFBCNACUAAA)r29(6+sAqQBXAQUFBLAAMgUEsAK8
AhQAAQAABAAH//8ADUAAABMblgCCAAA)r4d(6+sA9QCbPwIN3QAvslCBAAA9HggAAAQAAwBhGgEAC///BQwBAAsOvgoAADIBAAAEAA79ywAd
VhEAMB3LAJoAAAUFFAGQBQUUAGQCBwA)r4d(6+sA9QCbPwIN3QAvslCBAAA9HggAAAQAAwBhGgEAC///BQwBAAsOvgoAADIBAAAEAA79ywAd
VhEAMB3LAJoAAAUDIAGQBQMgAGQCBwA)r38(6+sAuwC9HAdUBAD//wEAkgAAAMADAAgBGwASAIIAxgEjAQAABAAR//8AGEjTADISwgBgAAAI
Arw)r3c(6+sBRwC9HAdUBADFhAIAVPp7AJIAAADAAwAMANgADgCCATwA7AEAAAQAEf//ABhI0wBcFywAwgAACAK8)r4c(6+sAWwDKHg3sRWcWAE8A
LxMEAAAAA2YCAK5YAgAM57kAQwAAAbgDAAUMtAAHBBkABgkoAQAABAAI//8AD1LCABwkaQAoAAAFE4gDIA)r42(6+sAgACpFg3sRWcWAE8A
LxMEAAAAA2YCAAG4AwAFDLQABwQZAAYJKAEAAAQACP//AA9SwgAiFywARwAACAu4CAnE)r47(6+sA6ADNPgz+bjgQBgAAAAAAAAAAgAEA
IjQCAEf//wDwJp4BrQEBRwEbCAAJYAEAAAQACv//ABs8sAAyEsIAkQAABQUUAyA)</egg-rom>
<script>
/* Webgl.js
 * Adapter that exposes GLES2 to the Wasm client, and implements in a WebGL context.
 */
 
class Webgl {
  constructor(egg, gl) {
    this.egg = egg;
    this.gl = gl;
    this.o = ["neverZero"]; // GL objects (mixed types), indexed by ID. Can be sparse.
    this.nextId = 1;
    this.glstrp = 0; // Storage for glGetString, set by Render.js.
    this.glstra = 0;
    this.locv = ["neverZero"]; // Uniform locations. TODO We never remove them. Will that be a problem?
  }
  
  generatePublicApi() {
    return {
      // Anything with no pointers or object names converts trivially.
      glActiveTexture: (a) => this.gl.activeTexture(a),
      glBlendColor: (a,b,c,d) => this.gl.blendColor(a,b,c,d),
      glBlendEquation: (a) => this.gl.blendEquation(a),
      glBlendEquationSeparate: (a,b) => this.gl.blendEquationSeparate(a,b),
      glBlendFunc: (a,b) => this.gl.blendFunc(a,b),
      glBlendFuncSeparate: (a,b,c,d) => this.gl.blendFuncSeparate(a,b,c,d),
      glCheckFramebufferStatus: (a) => this.gl.checkFramebufferStatus(a),
      glClear: (a) => this.gl.clear(a),
      glClearColor: (a,b,c,d) => this.gl.clearColor(a,b,c,d),
      glClearDepthf: (a) => this.gl.clearDepth(a),
      glClearStencil: (a) => this.gl.clearStencil(a),
      glColorMask: (a,b,c,d) => this.gl.colorMask(a,b,c,d),
      glCullFace: (a) => this.gl.cullFace(a),
      glDepthFunc: (a) => this.gl.depthFunc(a),
      glDepthMask: (a) => this.gl.depthMask(a),
      glDepthRangef: (a,b) => this.gl.depthRangef(a,b),
      glDisable: (a) => this.gl.disable(a),
      glDisableVertexAttribArray: (a) => this.gl.disableVertexAttribArray(a),
      glDrawArrays: (a,b,c) => this.gl.drawArrays(a,b,c),
      glDrawElements: (a,b,c,d) => this.gl.drawElements(a,b,c,d),
      glEnable: (a) => this.gl.enable(a),
      glEnableVertexAttribArray: (a) => this.gl.enableVertexAttribArray(a),
      glFinish: () => this.gl.finish(),
      glFlush: () => this.gl.flush(),
      glFrontFace: (a) => this.gl.frontFace(a),
      glGenerateMipmap: (a) => this.gl.generateMipmap(a),
      glGetError: () => this.gl.getError(),
      glHint: (a,b) => this.gl.hint(a,b),
      glIsEnabled: (a) => this.gl.isEnabled(a),
      glLineWidth: (a) => this.gl.lineWidth(a),
      glPixelStorei: (a,b) => this.gl.pixelStore(a,b),
      glPolygonOffset: (a,b) => this.gl.polygonOffset(a,b),
      glReleaseShaderCompiler: () => this.gl.releaseShaderCompiler(),
      glRenderbufferStorage: (a,b,c,d) => this.gl.renderbufferStorage(a,b,c,d),
      glSampleCoverage: (a,b) => this.gl.sampleCoverage(a,b),
      glScissor: (a,b,c,d) => this.gl.scissor(a,b,c,d),
      glStencilFunc: (a,b,c) => this.gl.stencilFunc(a,b,c),
      glStencilFuncSeparate: (a,b,c,d) => this.gl.stencilFuncSeparate(a,b,c,d),
      glStencilMask: (a) => this.gl.stencilMask(a),
      glStencilMaskSeparate: (a,b) => this.gl.stencilMaskSeparate(a,b),
      glStencilOp: (a,b,c) => this.gl.stencilOp(a,b,c),
      glStencilOpSeparate: (a,b,c,d) => this.gl.stencilOpSeparate(a,b,c,d),
      glTexParameterf: (a,b,c) => this.gl.texParameterf(a,b,c),
      glTexParameteri: (a,b,c) => this.gl.texParameteri(a,b,c),
      glUniform1f: (a,b) => this.gl.uniform1f(this.locv[a],b),
      glUniform1i: (a,b) => this.gl.uniform1i(this.locv[a],b),
      glUniform2f: (a,b,c) => this.gl.uniform2f(this.locv[a],b,c),
      glUniform2i: (a,b,c) => this.gl.uniform2i(this.locv[a],b,c),
      glUniform3f: (a,b,c,d) => this.gl.uniform3f(this.locv[a],b,c,d),
      glUniform3i: (a,b,c,d) => this.gl.uniform3i(this.locv[a],b,c,d),
      glUniform4f: (a,b,c,d,e) => this.gl.uniform4f(this.locv[a],b,c,d,e),
      glUniform4i: (a,b,c,d,e) => this.gl.uniform4i(this.locv[a],b,c,d,e),
      glVertexAttrib1f: (a,b) => this.gl.vertexAttrib1f(a,b),
      glVertexAttrib2f: (a,b,c) => this.gl.vertexAttrib2f(a,b,c),
      glVertexAttrib3f: (a,b,c,d) => this.gl.vertexAttrib3f(a,b,c,d),
      glVertexAttrib4f: (a,b,c,d,e) => this.gl.vertexAttrib4f(a,b,c,d,e),
      glViewport: (a,b,c,d) => this.gl.viewport(a,b,c,d),
      // All the rest are a little more interesting:
      glAttachShader: (a,b) => this.glAttachShader(a,b),
      glBindAttribLocation: (a,b,c) => this.glBindAttribLocation(a,b,c),
      glBindBuffer: (a,b) => this.glBindBuffer(a,b),
      glBindFramebuffer: (a,b) => this.glBindFramebuffer(a,b),
      glBindRenderbuffer: (a,b) => this.glBindRenderbuffer(a,b),
      glBindTexture: (a,b) => this.glBindTexture(a,b),
      glBufferData: (a,b,c,d) => this.glBufferData(a,b,c,d),
      glBufferSubData: (a,b,c,d) => this.glBufferSubData(a,b,c,d),
      glCompileShader: (a) => this.glCompileShader(a),
      glCompressedTexImage2D: (a,b,c,d,e,f,g,h) => this.glCompressedTexImage2D(a,b,c,d,e,f,g,h),
      glCompressedTexSubImage2D: (a,b,c,d,e,f,g,h,i) => this.glCompressedTexSubImage2D(a,b,c,d,e,f,g,h,i),
      glCopyTexImage2D: (a,b,c,d,e,f,g,h) => this.glCopyTexImage2D(a,b,c,d,e,f,g,h),
      glCopyTexSubImage2D: (a,b,c,d,e,f,g,h) => this.glCopyTexSubImage2D(a,b,c,d,e,f,g,h),
      glCreateProgram: () => this.glCreateProgram(),
      glCreateShader: (a) => this.glCreateShader(a),
      glDeleteBuffers: (a,b) => this.glDeleteBuffers(a,b),
      glDeleteFramebuffers: (a,b) => this.glDeleteFramebuffers(a,b),
      glDeleteProgram: (a) => this.glDeleteProgram(a),
      glDeleteRenderbuffers: (a,b) => this.glDeleteRenderbuffers(a,b),
      glDeleteShader: (a) => this.glDeleteShader(a),
      glDeleteTextures: (a,b) => this.glDeleteTextures(a,b),
      glDetachShader: (a,b) => this.glDetachShader(a,b),
      glFramebufferRenderbuffer: (a,b,c,d) => this.glFramebufferRenderbuffer(a,b,c,d),
      glFramebufferTexture2D: (a,b,c,d,e) => this.glFramebufferTexture2D(a,b,c,d,e),
      glGenBuffers: (a,b) => this.glGenBuffers(a,b),
      glGenFramebuffers: (a,b) => this.glGenFramebuffers(a,b),
      glGenRenderbuffers: (a,b) => this.glGenRenderbuffers(a,b),
      glGenTextures: (a,b) => this.glGenTextures(a,b),
      glGetActiveAttrib: (a,b,c,d,e,f,g) => this.glGetActiveAttrib(a,b,c,d,e,f,g),
      glGetActiveUniform: (a,b,c,d,e,f,g) => this.glGetActiveUniform(a,b,c,d,e,f,g),
      glGetAttachedShaders: (a,b,c,d) => this.glGetAttachedShaders(a,b,c,d),
      glGetAttribLocation: (a,b) => this.glGetAttribLocation(a,b),
      glGetBooleanv: (a,b) => this.glGetBooleanv(a,b),
      glGetBufferParameteriv: (a,b,c) => this.glGetBufferParameteriv(a,b,c),
      glGetFloatv: (a,b) => this.glGetFloatv(a,b),
      glGetFramebufferAttachmentParameteriv: (a,b,c,d) => this.glGetFramebufferAttachmentParameteriv(a,b,c,d),
      glGetIntegerv: (a,b) => this.glGetIntegerv(a,b),
      glGetProgramiv: (a,b,c) => this.glGetProgramiv(a,b,c),
      glGetProgramInfoLog: (a,b,c,d) => this.glGetProgramInfoLog(a,b,c,d),
      glGetRenderbufferParameteriv: (a,b,c) => this.glGetRenderbufferParameteriv(a,b,c),
      glGetShaderiv: (a,b,c) => this.glGetShaderiv(a,b,c),
      glGetShaderInfoLog: (a,b,c,d) => this.glGetShaderInfoLog(a,b,c,d),
      glGetShaderPrecisionFormat: (a,b,c,d) => this.glGetShaderPrecisionFormat(a,b,c,d),
      glGetShaderSource: (a,b,c,d) => this.glGetShaderSource(a,b,c,d),
      glGetString: (a) => this.glGetString(a),
      glGetTexParameterfv: (a,b,c) => this.glGetTexParameterfv(a,b,c),
      glGetTexParameteriv: (a,b,c) => this.glGetTexParameteriv(a,b,c),
      glGetUniformfv: (a,b,c) => this.glGetUniformfv(a,b,c),
      glGetUniformiv: (a,b,c) => this.glGetUniformiv(a,b,c),
      glGetUniformLocation: (a,b) => this.glGetUniformLocation(a,b),
      glGetVertexAttribfv: (a,b,c) => this.glGetVertexAttribfv(a,b,c),
      glGetVertexAttribiv: (a,b,c) => this.glGetVertexAttribiv(a,b,c),
      glGetVertexAttribPointerv: (a,b,c) => this.glGetVertexAttribPointerv(a,b,c),
      glIsBuffer: (a) => this.glIsBuffer(a),
      glIsFramebuffer: (a) => this.glIsFramebuffer(a),
      glIsProgram: (a) => this.glIsProgram(a),
      glIsRenderbuffer: (a) => this.glIsRenderbuffer(a),
      glIsShader: (a) => this.glIsShader(a),
      glIsTexture: (a) => this.glIsTexture(a),
      glLinkProgram: (a) => this.glLinkProgram(a),
      glReadPixels: (a,b,c,d,e,f,g) => this.glReadPixels(a,b,c,d,e,f,g),
      glShaderBinary: (a,b,c,d,e) => this.glShaderBinary(a,b,c,d,e),
      glShaderSource: (a,b,c,d) => this.glShaderSource(a,b,c,d),
      glTexImage2D: (a,b,c,d,e,f,g,h,i) => this.glTexImage2D(a,b,c,d,e,f,g,h,i),
      glTexParameterfv: (a,b,c) => this.glTexParameterfv(a,b,c),
      glTexParameteriv: (a,b,c) => this.glTexParameteriv(a,b,c),
      glTexSubImage2D: (a,b,c,d,e,f,g,h,i) => this.glTexSubImage2D(a,b,c,d,e,f,g,h,i),
      glUniform1fv: (a,b,c) => this.glUniform1fv(a,b,c),
      glUniform1iv: (a,b,c) => this.glUniform1iv(a,b,c),
      glUniform2fv: (a,b,c) => this.glUniform2fv(a,b,c),
      glUniform2iv: (a,b,c) => this.glUniform2iv(a,b,c),
      glUniform3fv: (a,b,c) => this.glUniform3fv(a,b,c),
      glUniform3iv: (a,b,c) => this.glUniform3iv(a,b,c),
      glUniform4fv: (a,b,c) => this.glUniform4fv(a,b,c),
      glUniform4iv: (a,b,c) => this.glUniform4iv(a,b,c),
      glUniformMatrix2fv: (a,b,c,d) => this.glUniformMatrix2fv(a,b,c,d),
      glUniformMatrix3fv: (a,b,c,d) => this.glUniformMatrix3fv(a,b,c,d),
      glUniformMatrix4fv: (a,b,c,d) => this.glUniformMatrix4fv(a,b,c,d),
      glUseProgram: (a) => this.glUseProgram(a),
      glValidateProgram: (a) => this.glValidateProgram(a),
      glVertexAttrib1fv: (a,b) => this.glVertexAttrib1fv(a,b),
      glVertexAttrib2fv: (a,b) => this.glVertexAttrib2fv(a,b),
      glVertexAttrib3fv: (a,b) => this.glVertexAttrib3fv(a,b),
      glVertexAttrib4fv: (a,b) => this.glVertexAttrib4fv(a,b),
      glVertexAttribPointer: (a,b,c,d,e,f) => this.glVertexAttribPointer(a,b,c,d,e,f),
    };
  }
  
  /* Create and delete objects.
   **********************************************************/
   
  objAlloc() {
    const p = this.o.indexOf(null);
    if (p >= 0) return p;
    return this.nextId++;
  }
  
  objDel(id) {
    if (id < 1) return;
    this.o[id] = null;
  }

  glCreateProgram() {
    const id = this.objAlloc();
    if (!(this.o[id] = this.gl.createProgram())) return 0;
    return id;
  }

  glCreateShader(a) {
    const id = this.objAlloc();
    if (!(this.o[id] = this.gl.createShader(a))) return 0;
    return id;
  }

  glGenBuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.objAlloc();
      this.o[id] = this.gl.createBuffer();
      this.egg.exec.mem32[p] = id;
    }
  }

  glGenFramebuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.objAlloc();
      this.o[id] = this.gl.createFramebuffer();
      this.egg.exec.mem32[p] = id;
    }
  }

  glGenRenderbuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.objAlloc();
      this.o[id] = this.gl.createRenderbuffer();
      this.egg.exec.mem32[p] = id;
    }
  }

  glGenTextures(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.objAlloc();
      this.o[id] = this.gl.createTexture();
      this.egg.exec.mem32[p] = id;
    }
  }

  glDeleteBuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.egg.exec.mem32[p];
      this.gl.deleteBuffer(this.o[id]);
      this.objDel(id);
    }
  }

  glDeleteFramebuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.egg.exec.mem32[p];
      this.gl.deleteFramebuffer(this.o[id]);
      this.objDel(id);
    }
  }

  glDeleteProgram(a) {
    this.gl.deleteProgram(this.o[a]);
    this.objDel(a);
  }

  glDeleteRenderbuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.egg.exec.mem32[p];
      this.gl.deleteRenderbuffer(this.o[id]);
      this.objDel(id);
    }
  }

  glDeleteShader(a) {
    this.gl.deleteShader(this.o[a]);
    this.objDel(a);
  }

  glDeleteTextures(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.egg.exec.mem32[p];
      this.gl.deleteTexture(this.o[id]);
      this.objDel(id);
    }
  }

  glIsBuffer(a) {
    return this.gl.isBuffer(this.o[a]);
  }

  glIsFramebuffer(a) {
    return this.gl.isFramebuffer(this.o[a]);
  }

  glIsProgram(a) {
    return this.gl.isProgram(this.o[a]);
  }

  glIsRenderbuffer(a) {
    return this.gl.isRenderbuffer(this.o[a]);
  }

  glIsShader(a) {
    return this.gl.isShader(this.o[a]);
  }

  glIsTexture(a) {
    return this.gl.isTexture(this.o[a]);
  }
   
  /* Miscellaneous.
   ***********************************************************/
  
  glAttachShader(pid, sid) {
    this.gl.attachShader(this.o[pid], this.o[sid]);
  }

  glBindAttribLocation(pid, index, namep) {
    const program = this.o[pid];
    const name = this.egg.exec.readCString(namep);
    this.gl.bindAttribLocation(program, index, name);
  }

  glBindBuffer(target, id) {
    const buffer = this.o[id];
    this.gl.bindBuffer(target, buffer);
  }

  glBindFramebuffer(target, id) {
    const fb = this.o[id];
    this.gl.bindFramebuffer(target, fb);
  }

  glBindRenderbuffer(target, id) {
    const rb = this.o[id];
    this.gl.bindRenderbuffer(target, rb);
  }

  glBindTexture(target, id) {
    const texture = this.o[id];
    this.gl.bindTexture(target, texture);
  }

  glBufferData(target, size, datap, usage) {
    if (datap) {
      const data = this.egg.exec.getView(datap, size);
      if (!data) return;
      this.gl.bufferData(target, data, usage);
    } else {
      this.gl.bufferData(target, size, usage);
    }
  }

  glBufferSubData(target, offset, size, datap) {
    const data = this.egg.exec.getView(datap, size);
    if (!data) return;
    this.gl.bufferSubData(target, offset, data);
  }

  glCompileShader(id) {
    const shader = this.o[id];
    this.gl.compileShader(shader);
  }

  glDetachShader(pid, sid) {
    const program = this.o[pid];
    const shader = this.o[sid];
    this.gl.detachShader(program, shader);
  }

  glFramebufferRenderbuffer(target, attachment, rbtarget, rbid) {
    const rb = this.o[rbid];
    this.gl.framebufferRenderbuffer(target, attachment, rbtarget, rb);
  }

  glFramebufferTexture2D(target, attachment, textarget, texid, level) {
    const texture = this.o[texid];
    this.gl.framebufferTexture2D(target, attachment, textarget, texture, level);
  }

  glGetActiveAttrib(pid, index, bufsize, lenp, sizep, typep, namep) {
    const program = this.o[pid];
    const attr = this.gl.getActiveAttrib(program, index);
    if (!attr) return;
    if (sizep) this.egg.exec.mem32[sizep >> 2] = attr.size;
    if (typep) this.egg.exec.mem32[typep >> 2] = attr.type;
    if (namep && (bufsize > 0)) {
      this.egg.exec.safeWrite(namep, bufsize, attr.name);
    }
  }

  glGetActiveUniform(pid, index, bufsize, lenp, sizep, typep, namep) {
    const program = this.o[pid];
    const attr = this.gl.getActiveUniform(program, index);
    if (!attr) return;
    if (sizep) this.egg.exec.mem32[sizep >> 2] = attr.size;
    if (typep) this.egg.exec.mem32[typep >> 2] = attr.type;
    if (namep && (bufsize > 0)) {
      this.egg.exec.safeWrite(namep, bufsize, attr.name);
    }
  }

  glGetAttachedShaders(pid, max, countp, dstp) {
    const program = this.o[pid];
    const shaders = this.gl.getAttachedShaders(program) || [];
    if (countp) this.egg.exec.mem32[countp >> 2] = shaders.length;
    const cpc = Math.min(shaders.length, max);
    for (let i=0; i<cpc; i++, dstp+=4) {
      let id = this.o.indexOf(shaders[i]);
      if (id < 0) id = 0;
      this.egg.exec.mem32[dstp >> 2] = id;
    }
  }

  glGetAttribLocation(pid, namep) {
    const program = this.o[pid];
    const name = this.egg.exec.readCString(namep);
    return this.gl.getAttribLocation(program, name);
  }

  glGetProgramInfoLog(pid, bufsize, lenp, dstp) {
    const program = this.o[pid];
    const src = this.gl.getProgramInfoLog(program) || "";
    this.egg.exec.mem32[lenp >> 2] = this.egg.exec.safeWrite(dstp, bufsize, src);
  }

  glGetShaderInfoLog(sid, bufsize, lenp, dstp) {
    const shader = this.o[sid];
    const src = this.gl.getShaderInfoLog(shader) || "";
    this.egg.exec.mem32[lenp >> 2] = this.egg.exec.safeWrite(dstp, bufsize, src);
  }

  glGetShaderPrecisionFormat(stype, ptype, rangep, precp) {
    const rsp = this.gl.getShaderPrecisionFormat(stype, ptype);
    if (!rsp) return;
    rangep >>= 2;
    this.egg.exec.mem32[rangep++] = rsp.rangeMin;
    this.egg.exec.mem32[rangep] = rsp.rangeMax;
    this.egg.exec.mem32[precp >> 2] = rsp.precision;
  }

  glGetShaderSource(sid, bufsize, lenp, dstp) {
    const shader = this.o[sid];
    const src = this.gl.getShaderSource(shader) || "";
    this.egg.exec.mem32[lenp >> 2] = this.egg.exec.safeWrite(dstp, bufsize, src);
  }

  glGetUniformLocation(pid, namep) {
    const program = this.o[pid];
    const name = this.egg.exec.readCString(namep);
    const loc = this.gl.getUniformLocation(program, name);
    if (!loc) return 0;
    const id = this.locv.length;
    this.locv.push(loc);
    return id;
  }

  glLinkProgram(pid) {
    const program = this.o[pid];
    this.gl.linkProgram(program);
  }

  glShaderBinary(count, dstp, bfmt, src, srcc) {
    // GL_APICALL void GL_APIENTRY glShaderBinary (GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length);
    // Evidently there is no such thing in WebGL.
  }

  glShaderSource(sid, count, stringsp, lensp) {
    const shader = this.o[sid];
    let glsl = "";
    stringsp >>= 2;
    lensp >>= 2;
    for (let i=0; i<count; i++, stringsp++, lensp++) {
      const srcp = this.egg.exec.mem32[stringsp];
      const srcc = this.egg.exec.mem32[lensp];
      const sub = this.egg.exec.readLimitedString(srcp, srcc);
      glsl += sub;
    }
    this.gl.shaderSource(shader, glsl);
  }

  glUseProgram(a) {
    this.gl.useProgram(this.o[a]);
  }

  glValidateProgram(a) {
    this.gl.validateProgram(this.o[a]);
  }
  
  /* Generic parameters.
   ******************************************************************************/
   
  paramAsInts(src) {
    if (!src) return [0];
    if (typeof(src) === "number") return [~~src];
    const p = this.o.indexOf(src);
    if (p > 0) return [p];
    if (src.length) return src.map(v => ~~v);
    return [0];
  }
  
  paramAsFloats(src) {
    if (!src) return [0];
    if (typeof(src) === "number") return [src];
    if (src.length) return src;
    return [0];
  }
  
  paramAsString(src) {
    if (!src) return "";
    if (typeof(src) === "string") return src;
    return "";
  }

  glGetBooleanv(pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getParameter(pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetIntegerv(pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getParameter(pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetFloatv(pname, dstp) {
    const rsp = this.paramAsFloats(this.gl.getParameter(pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.memf32[dstp] = rsp[i];
    }
  }
  
  glGetString(pname) {
    const rsp = this.paramAsString(this.gl.getParameter(pname));
    this.egg.exec.safeWrite(this.glstrp, this.glstra, rsp + "\0");
    return this.glstrp;
  }

  glGetBufferParameteriv(target, pname, dstp) {
    // Every defined field is a single int.
    const rsp = this.gl.getBufferParameter(target, pname);
    this.egg.exec.mem32[dstp >> 2] = rsp;
  }

  glGetFramebufferAttachmentParameteriv(target, attachment, pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getFramebufferAttachmentParameter(target, attachment, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetProgramiv(pid, pname, dstp) {
    // Every defined field is a single int.
    const program = this.o[pid];
    const rsp = this.gl.getProgramParameter(program, pname);
    this.egg.exec.mem32[dstp >> 2] = rsp;
  }

  glGetRenderbufferParameteriv(target, pname, dstp) {
    // Every defined field is a single int.
    const rsp = this.gl.getRenderbufferParameter(target, pname);
    this.egg.exec.mem32[dstp >> 2] = rsp;
  }

  glGetShaderiv(sid, pname, dstp) {
    // Every defined field is a single int.
    const shader = this.o[sid];
    const rsp = this.gl.getShaderParameter(shader, pname);
    this.egg.exec.mem32[dstp >> 2] = rsp;
  }

  glGetTexParameterfv(target, pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getTexParameter(target, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.memf32[dstp] = rsp[i];
    }
  }

  glGetTexParameteriv(target, pname, dstp) {
    const rsp = this.paramAsFloats(this.gl.getTexParameter(target, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetUniformfv(pid, id, dstp) {
    const program = this.o[pid];
    const rsp = this.paramAsFloats(this.gl.getUniform(program, this.locv[id]));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.memf32[dstp] = rsp[i];
    }
  }

  glGetUniformiv(pid, id, dstp) {
    const program = this.o[pid];
    const rsp = this.paramAsInts(this.gl.getUniform(program, this.locv[id]));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetVertexAttribfv(index, pname, dstp) {
    const rsp = this.paramAsFloats(this.gl.getVertexAttrib(index, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.memf32[dstp] = rsp[i];
    }
  }

  glGetVertexAttribiv(index, pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getVertexAttrib(index, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetVertexAttribPointerv(index, pname, dstp) {
    const offset = this.gl.getVertexAttribOffset(index, pname);
    this.egg.exec.mem32[dstp >> 2] = offset;
  }

  glTexParameterfv(target, pname, srcp) {
    // No defined texture field uses a vector.
    this.gl.texParameterf(target, pname, this.egg.exec.memf32[srcp >> 2]);
  }

  glTexParameteriv(target, pname, srcp) {
    // No defined texture field uses a vector.
    this.gl.texParameteri(target, pname, this.egg.exec.mem32[srcp >> 2]);
  }

  glUniform1fv(id, c, p) {
    this.gl.uniform1fv(this.locv[id], this.egg.exec.memf32.slice(p >> 2, c));
  }

  glUniform1iv(id, c, p) {
    this.gl.uniform1iv(this.locv[id], this.egg.exec.mem32.slice(p >> 2, c));
  }

  glUniform2fv(id, c, p) {
    this.gl.uniform2fv(this.locv[id], this.egg.exec.memf32.slice(p >> 2, c * 2)); 
  }

  glUniform2iv(id, c, p) {
    this.gl.uniform2iv(this.locv[id], this.egg.exec.mem32.slice(p >> 2, c * 2));
  }

  glUniform3fv(id, c, p) {
    this.gl.uniform3fv(this.locv[id], this.egg.exec.memf32.slice(p >> 2, c * 3)); 
  }

  glUniform3iv(id, c, p) {
    this.gl.uniform3iv(this.locv[id], this.egg.exec.mem32.slice(p >> 2, c * 3));
  }

  glUniform4fv(id, c, p) {
    this.gl.uniform4fv(this.locv[id], this.egg.exec.memf32.slice(p >> 2, c * 4)); 
  }

  glUniform4iv(id, c, p) {
    this.gl.uniform4iv(this.locv[id], this.egg.exec.mem32.slice(p >> 2, c * 4));
  }

  glUniformMatrix2fv(id, c, trans, p) {
    this.gl.uniformMatrix2fv(this.locv[id], trans, this.egg.exec.memf32.slice(p >> 2, c * 4));
  }

  glUniformMatrix3fv(id, c, trans, p) {
    this.gl.uniformMatrix3fv(this.locv[id], trans, this.egg.exec.memf32.slice(p >> 2, c * 9));
  }

  glUniformMatrix4fv(id, c, trans, p) {
    this.gl.uniformMatrix4fv(this.locv[id], trans, this.egg.exec.memf32.slice(p >> 2, c * 16));
  }

  glVertexAttrib1fv(index, p) {
    this.gl.vertexAttrib1fv(index, this.egg.exec.memf32.slice(p >> 2, 1));
  }

  glVertexAttrib2fv(index, p) {
    this.gl.vertexAttrib2fv(index, this.egg.exec.memf32.slice(p >> 2, 2));
  }

  glVertexAttrib3fv(index, p) {
    this.gl.vertexAttrib3fv(index, this.egg.exec.memf32.slice(p >> 2, 3));
  }

  glVertexAttrib4fv(index, p) {
    this.gl.vertexAttrib4fv(index, this.egg.exec.memf32.slice(p >> 2, 4));
  }

  glVertexAttribPointer(index, size, type, norm, stride, p) {
    //TODO WebGL (p) is an offset in the bound vbo. GLES2 it can be an absolute pointer in client memory.
    this.gl.vertexAttribPointer(index, size, type, norm, stride, p);
  }
  
  /* Image operations.
   ****************************************************************************/
   
  measureImage(w, h, fmt, type) {
    if ((w < 1) || (w > 4096)) return 0;
    if ((h < 1) || (h > 4096)) return 0;
    let chanc = 0;
    switch (fmt) {
      case this.gl.STENCIL_INDEX8:
      case this.gl.DEPTH_COMPONENT:
      case this.gl.LUMINANCE:
      case this.gl.ALPHA: chanc=1; break;
      case this.gl.LUMINANCE_ALPHA: chanc=2; break;
      case this.gl.RGB: chanc=3; break;
      case this.gl.RGBA: chanc=4; break;
    }
    if (chanc < 1) return 0;
    let wordlen = 0;
    switch (type) {
      case this.gl.UNSIGNED_BYTE:
      case this.gl.BYTE:
        wordlen=1;
        break;
      case this.gl.UNSIGNED_SHORT:
      case this.gl.SHORT:
      case this.gl.UNSIGNED_SHORT_5_6_5:
      case this.gl.UNSIGNED_SHORT_4_4_4_4:
      case this.gl.UNSIGNED_SHORT_5_5_5_1:
        wordlen=2;
        break;
      case this.gl.UNSIGNED_INT:
      case this.gl.INT:
      case this.gl.FLOAT:
        wordlen=4;
        break;
    }
    if (wordlen < 1) return 0;
    return wordlen * chanc * w * h;
  }

  glCompressedTexImage2D(target, level, ifmt, w, h, border, size, srcp) {
    const src = this.egg.exec.getView(srcp, size);
    if (!src) return;
    this.gl.compressedTexImage2D(target, level, ifmt, w, h, border, src);
  }

  glCompressedTexSubImage2D(target, level, xo, yo, w, h, fmt, size, srcp) {
    const src = this.egg.exec.getView(srcp, size);
    if (!src) return;
    this.gl.compressedTexImage2D(target, level, xo, yo, w, h, fmt, src);
  }

  glCopyTexImage2D(target, level, ifmt, x, y, w, h, border) {
    this.gl.copyTexImage2D(target, level, ifmt, x, y, w, h, border);
  }

  glCopyTexSubImage2D(target, level, xo, yo, x, y, w, h) {
    this.gl.copyTexSubImage2D(target, level, xo, yo, x, y, w, h);
  }

  glReadPixels(x, y, w, h, fmt, type, dstp) {
    const len = this.measureImage(w, h, fmt, type);
    if (len < 1) return;
    const dst = this.egg.exec.getView(dstp, len);
    if (!dst) return;
    this.gl.readPixels(x, y, w, h, fmt, type, dst);
  }

  glTexImage2D(target, level, ifmt, w, h, border, fmt, type, srcp) {
    const len = this.measureImage(w, h, fmt, type);
    if (len < 1) return;
    const src = this.egg.exec.getView(srcp, len);
    if (!src) return;
    this.gl.texImage2D(target, level, ifmt, w, h, border, fmt, type, src);
  }

  glTexSubImage2D(target, level, xo, yo, w, h, fmt, type, srcp) {
    const len = this.measureImage(w, h, fmt, type);
    if (len < 1) return;
    const src = this.egg.exec.getView(srcp, len);
    if (!src) return;
    this.gl.texSubImage2D(target, level, xo, yo, w, h, fmt, type, src);
  }

}
class Rom {
  constructor(src) {
    this.resv = []; // {tid,qual,rid,v:Uint8Array}, sorted
    this.decode(src);
  }
  
  getRes(tid, qual, rid) {
    let lo=0, hi=this.resv.length;
    while (lo < hi) {
      const ck = (lo + hi) >> 1;
      const q = this.resv[ck];
           if (tid < q.tid) hi = ck;
      else if (tid > q.tid) lo = ck + 1;
      else if (qual < q.qual) hi = ck;
      else if (qual > q.qual) lo = ck + 1;
      else if (rid < q.rid) hi = ck;
      else if (rid > q.rid) lo = ck + 1;
      else return q.v;
    }
    return this.empty;
  }
  
  decode(src) {
    let tid=1, qual=0, rid=1, i=0;
    const rdch = () => {
      let ch;
      for (;;) {
        ch = src.charCodeAt(i++);
        if (ch > 0x20) return ch;
        if (i >= src.length) return 0;
      }
    };
    const rdn = () => {
      let n=0;
      while (i < src.length) {
        const ch = rdch();
        if (!ch) break;
        if ((ch >= 0x30) && (ch <= 0x39)) { n <<= 4; n |= ch - 0x30; continue; }
        if ((ch >= 0x61) && (ch <= 0x66)) { n <<= 4; n |= ch - 0x61 + 10; continue; }
        if ((ch >= 0x41) && (ch <= 0x46)) { n <<= 4; n |= ch - 0x41 + 10; continue; }
        i--;
        break;
      }
      return n;
    };
    while (i < src.length) {
      const cmd = rdch();
      if (!cmd) break;
      switch (cmd) {
        case 0x74: tid += rdn() + 1; qual = 0; rid = 1; break;
        case 0x71: qual += rdn() + 1; rid = 1; break;
        case 0x73: rid += rdn() + 1; break;
        case 0x72: {
            if ((tid > 0x63) || (qual > 0x3ff) || (rid > 0xffff)) {
              throw new Error(`Invalid res id ${tid}:${qual}:${rid} around ${i}/${src.length} in ROM`);
            }
            const len = rdn();
            const body = new Uint8Array(len);
            let bodyp = 0;
            if (rdch() !== 0x28) throw new Error(`Expected '(' around ${i}/${src.length} in ROM`);
            const buf = [];
            for (;;) {
              const ch = rdch();
              if (ch === 0x29) break;
              if (!ch) throw new Error(`Unclosed resource body`);
                   if ((ch >= 0x41) && (ch <= 0x5a)) buf.push(ch - 0x41);
              else if ((ch >= 0x61) && (ch <= 0x7a)) buf.push(ch - 0x61 + 26);
              else if ((ch >= 0x30) && (ch <= 0x39)) buf.push(ch - 0x30 + 52);
              else if (ch === 0x2b) buf.push(62);
              else if (ch === 0x2f) buf.push(63);
              else throw new Error(`Expected ')' or base64 digit, found ${ch} (${i}/${src.length})`);
              if (buf.length >= 4) {
                body[bodyp++] = (buf[0] << 2) | (buf[1] >> 4);
                body[bodyp++] = (buf[1] << 4) | (buf[2] >> 2);
                body[bodyp++] = (buf[2] << 6) | buf[3];
                buf.splice(0, 4);
              }
            }
            body[bodyp++] = (buf[0] << 2) | (buf[1] >> 4);
            body[bodyp++] = (buf[1] << 4) | (buf[2] >> 2);
            body[bodyp++] = (buf[2] << 6) | buf[3];
            this.resv.push({ tid, qual, rid, v: body });
            rid++;
          } break;
        default: throw new Error(`Unexpected command '${cmd}' around ${i-1}/${src.length} in ROM`);
      }
    }
  }
}

Rom.RESTYPE_metadata = 1;
Rom.RESTYPE_wasm = 2;
Rom.RESTYPE_string = 3;
Rom.RESTYPE_image = 4;
Rom.RESTYPE_song = 5;
Rom.RESTYPE_sound = 6;
/* SfgPrinter.js
 * Produce PCM dumps from our tiny binary sound format.
 *
 * Unlike our C counterpart, we run completely synchronously.
 * That's because in WebAudio you don't get intimate access to the signal generator,
 * what we use to time and pay out printing in C.
 * Printing is not trivial. There's a real possibility of missing video frames due to sound effects being printed.
 *
 * It's written as a class to keep things flexible.
 * But typical usage is a one-shot kind of deal:
 *   const myPcm = new SfgPrinter(serial).print();
 * Uint8Array in, Float32Array out.
 */
 
class SfgPrinter {
  constructor(src, rate) {
    if (!(src instanceof Uint8Array)) throw new Error(`Expected Uint8Array`);
    if (!rate || (rate < 200) || (rate > 200000)) throw new Error(`Invalid rate for SfgPrinter`);
    this.src = src;
    this.rate = rate;
    this.dst = null; // Float32Array
  }
  
  print() {
    if (!this.dst) this._print();
    return this.dst;
  }
  
  /* Private below this point.
   */
  
  _print() {
    if (this.src.length < 6) throw new Error(`Invalid SFG`);
    if ((this.src[0] !== 0xeb) || (this.src[1] !== 0xeb)) throw new Error("Invalid SFG");
    const durms = (this.src[2] << 8) | this.src[3];
    const durframes = Math.max(1, Math.round(durms * this.rate / 1000));
    const master = this.src[4] + this.src[5] / 256.0;
    this.dst = new Float32Array(durframes);
    const tmp = new Float32Array(durframes);
    // Add one voice at a time to (this.dst).
    // Unlike the C implementation, we're synchronous, so we kind of process everything as we read it.
    for (let srcp=6; srcp<this.src.length; ) {
      const np = this._printVoice(tmp, srcp);
      if (!np || (np <= srcp)) throw new Error(`PCM print stalled at ${srcp}/${this.src.length}`);
      srcp = np;
      for (let i=durframes; i-->0; ) this.dst[i] += tmp[i];
    }
    // Apply master level.
    for (let i=durframes; i-->0; ) this.dst[i] *= master;
  }
  
  // Overwrite (dst), and return new (srcp).
  _printVoice(dst, srcp) {
    const waveSizeBits = 10;
    const waveSizeSamples = 1 << waveSizeBits;

    const features = this.src[srcp++];
    
    let wave = null; // Float32Array(waveSizeSamples) | "noise" | "silence"
    if (features & 0x01) { // shape
      switch (this.src[srcp++]) {
        case 0: wave = this._printSine(waveSizeSamples); break;
        case 1: wave = this._printSquare(waveSizeSamples); break;
        case 2: wave = this._printSawup(waveSizeSamples); break;
        case 3: wave = this._printSawdown(waveSizeSamples); break;
        case 4: wave = this._printTriangle(waveSizeSamples); break;
        case 5: wave = "noise"; break;
        case 6: wave = "silence"; break;
        default: throw new Error(`Unknown wave shape ${this.src[srcp-1]}`);
      }
    } else {
      wave = this._printSine(waveSizeSamples);
    }
    
    if (features & 0x02) { // harmonics
      const coefc = this.src[srcp++];
      if (wave instanceof Float32Array) {
        const nwave = new Float32Array(waveSizeSamples);
        for (let step=1; step<=coefc; step++) {
          this._printHarmonic(nwave, wave, step, this.src[srcp++] / 255.0);
        }
        wave = nwave;
      } else {
        // harmonics is meaningless for noise or silence, but it is technically legal. skip it.
        srcp += coefc;
      }
    }
    
    let fmrate = 0;
    let fmscale = 0;
    if (features & 0x04) { // fm
      fmrate = this.src[srcp] + this.src[srcp+1] / 256.0; srcp += 2;
      fmscale = this.src[srcp] + this.src[srcp+1] / 256.0; srcp += 2;
      fmrate *= Math.PI * 2;
    }
    
    const fmrange = {};
    if (features & 0x08) { // fmenv
      srcp = this._decodeEnv(fmrange, srcp, fmscale / 65535.0);
    } else {
      this._constantEnv(fmrange, fmscale);
    }
    
    const rate = {};
    if (features & 0x10) { // rate
      srcp = this._decodeEnv(rate, srcp, 1 / this.rate);
    } else {
      this._constantEnv(rate, 440 / this.rate);
    }
    
    let ratelforate = 0;
    let ratelfodepth = 0;
    if (features & 0x20) { // ratelfo
      const rate = this.src[srcp] + this.src[srcp+1] / 256.0; srcp += 2; // hz
      const depth = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2; // cents
      ratelforate = (rate * Math.PI * 2) / this.rate; // radians/frame
      ratelfodepth = depth / 1200; // power of 2
    }
    
    if (features & 0xc0) throw new Error(`Unknown features (0x${(features & 0xc0).toString(16)}) in voice`);
    
    /* We now have everything we need for the oscillator.
     * Run it to completion, overwriting (dst).
     */
    if (wave === "silence") {
      for (let i=dst.length; i-->0; ) dst[i] = 0;
    } else if (wave === "noise") {
      for (let i=dst.length; i-->0; ) dst[i] = Math.random() * 2 - 1;
    } else { //TODO Opportunities here to run simpler oscillators, eg if rate LFO or FM not in play. See sfg_update.c
      this._oscillateFull(
        dst, wave, rate, ratelforate, ratelfodepth, fmrate, fmrange
      );
    }
    
    /* Process all positional operations individually.
     */
    while (srcp < this.src.length) {
      const opcode = this.src[srcp++];
      if (!opcode) break; // End Of Voice
      switch (opcode) {
        case 0x01: srcp = this._printOpLevel(dst, srcp); break;
        case 0x02: srcp = this._printOpGain(dst, srcp); break;
        case 0x03: srcp = this._printOpClip(dst, srcp); break;
        case 0x04: srcp = this._printOpDelay(dst, srcp); break;
        case 0x05: srcp = this._printOpBandpass(dst, srcp); break;
        case 0x06: srcp = this._printOpNotch(dst, srcp); break;
        case 0x07: srcp = this._printOpLopass(dst, srcp); break;
        case 0x08: srcp = this._printOpHipass(dst, srcp); break;
        default: throw new Error(`Unknown voice op ${opcode}`);
      }
    }
  
    return srcp;
  }
  
  /* Oscillator.
   */
   
  _oscillateFull(dst, wave, rate, ratelforate, ratelfodepth, fmrate, fmrange) {
    for (let i=0, ratelfop=0, modp=0, carp=0; i<dst.length; i++) {
  
      // Acquire carrier rate.
      let crate = this._updateEnv(rate);
      crate *= Math.pow(2, Math.sin(ratelfop) * ratelfodepth);
      ratelfop += ratelforate;
      if (ratelfop >= Math.PI) ratelfop -= Math.PI * 2;
    
      // Acquire modulation.
      let mod = Math.sin(modp);
      mod *= this._updateEnv(fmrange);
      modp += crate * fmrate;
      if (modp >= Math.PI) modp -= Math.PI * 2;
    
      // Acquire sample and advance carrier.
      const sp = Math.floor(carp * wave.length);
      dst[i] = wave[sp] || 0;
      crate += crate * mod;
      carp += crate;
      while (carp >= 1) carp -= 1;
      while (carp < 0) carp += 1;
    }
  }
  
  /* Positional ops.
   * These all read from (this.src) and return the new position.
   */
  
  _printOpLevel(dst, srcp) {
    const env = {};
    srcp = this._decodeEnv(env, srcp, 1 / 65535.0);
    let lo=dst[0], hi=dst[0];
    for (let i=dst.length; i-->0; ) {
      if (dst[i]<lo) lo=dst[i];
      else if (dst[i]>hi) hi=dst[i];
    }
    for (let i=0; i<dst.length; i++) {
      dst[i] *= this._updateEnv(env);
    }
    return srcp;
  }
  
  _printOpGain(dst, srcp) {
    const gain = this.src[srcp] + this.src[srcp+1] / 256.0; srcp += 2;
    for (let i=dst.length; i-->0; ) {
      dst[i] *= gain;
    }
    return srcp;
  }
  
  _printOpClip(dst, srcp) {
    const hi = this.src[srcp++] / 255.0;
    const lo = -hi;
    for (let i=dst.length; i-->0; ) {
      const v = dst[i];
      if (v > hi) dst[i] = hi;
      else if (v < lo) dst[i] = lo;
    }
    return srcp;
  }
  
  _printOpDelay(dst, srcp) {
    const ms = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2;
    const period = Math.ceil((ms * this.rate) / 1000);
    if (isNaN(period) || (period < 1)) return srcp + 4;
    const buf = new Float32Array(period);
    let bufp = 0;
    const dry = this.src[srcp++] / 255.0;
    const wet = this.src[srcp++] / 255.0;
    const sto = this.src[srcp++] / 255.0;
    const fbk = this.src[srcp++] / 255.0;
    for (let i=0; i<dst.length; i++) {
      const next = dst[i];
      const prev = buf[bufp];
      dst[i] = next * dry + prev * wet;
      buf[bufp] = next * sto + prev * fbk;
      if (++bufp >= period) bufp = 0;
    }
    return srcp;
  }
  
  _printOpBandpass(dst, srcp) {
    const mid = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const wid = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const r = 1 - 3 * wid;
    const cosfreq = Math.cos(Math.PI * 2 * mid);
    const k = (1 - 2 * r * cosfreq + r * r) / (2 - 2 * cosfreq);
    const coefv = [
      1 - k,
      2 * (k - r) * cosfreq,
      r * r - k,
      2 * r * cosfreq,
      -r * r,
    ];
    this._applyIir(dst, coefv);
    return srcp;
  }
  
  _printOpNotch(dst, srcp) {
    const mid = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const wid = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const r = 1 - 3 * wid;
    const cosfreq = Math.cos(Math.PI * 2 * mid);
    const k = (1 - 2 * r * cosfreq + r * r) / (2 - 2 * cosfreq);
    const coefv = [
      k,
      -2 * k * cosfreq,
      k,
      2 * r * cosfreq,
      -r * r,
    ];
    this._applyIir(dst, coefv);
    return srcp;
  }
  
  _printOpLopass(dst, srcp) {
    const freq = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const rp = -Math.cos(Math.PI / 2);
    const ip = Math.sin(Math.PI / 2);
    const t = 2 * Math.tan(0.5);
    const w = 2 * Math.PI * freq;
    const m = rp * rp + ip * ip;
    const d = 4 - 4 * rp * t + m * t * t;
    const x0 = (t * t) / d;
    const x1 = (2 * t * t) / d;
    const x2 = (t * t) / d;
    const y1 = (8 - 2 * m * t * t) / d;
    const y2 = (-4 - 4 * rp * t - m * t * t) / d;
    const k = Math.sin(0.5 - w / 2) / Math.sin(0.5 + w / 2);
    const coefv = [
      (x0 - x1 * k + x2 * k * k) / d,
      (-2 * x0 * k + x1 + x1 * k * k - 2 * x2 * k) / d,
      (x0 * k * k - x1 * k + x2) / d,
      (2 * k + y1 + y1 * k * k - 2 * y2 * k) / d,
      (-k * k - y1 * k + y2) / d,
    ];
    this._applyIir(dst, coefv);
    return srcp;
  }
  
  _printOpHipass(dst, srcp) {
    const freq = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const rp = -Math.cos(Math.PI / 2);
    const ip = Math.sin(Math.PI / 2);
    const t = 2 * Math.tan(0.5);
    const w = 2 * Math.PI * freq;
    const m = rp * rp + ip * ip;
    const d = 4 - 4 * rp * t + m * t * t;
    const x0 = (t * t) / d;
    const x1 = (2 * t * t) / d;
    const x2 = (t * t) / d;
    const y1 = (8 - 2 * m * t * t) / d;
    const y2 = (-4 - 4 * rp * t - m * t * t) / d;
    const k = -Math.cos(w / 2 + 0.5) / Math.cos(w / 2 - 0.5);
    const coefv = [
      -(x0 - x1 * k + x2 * k * k) / d,
      (-2 * x0 * k + x1 + x1 * k * k - 2 * x2 * k) / d,
      (x0 * k * k - x1 * k + x2) / d,
      -(2 * k + y1 + y1 * k * k - 2 * y2 * k) / d,
      (-k * k - y1 * k + y2) / d,
    ];
    this._applyIir(dst, coefv);
    return srcp;
  }
  
  _applyIir(dst, coefv) {
    const statev = [0, 0, 0, 0, 0];
    for (let i=0; i<dst.length; i++) {
      statev[2]=statev[1];
      statev[1]=statev[0];
      statev[0]=dst[i];
      dst[i]=(
        statev[0]*coefv[0]+
        statev[1]*coefv[1]+
        statev[2]*coefv[2]+
        statev[3]*coefv[3]+
        statev[4]*coefv[4]
      );
      statev[4]=statev[3];
      statev[3]=dst[i];
    }
  }
  
  /* Envelopes.
   * Decode into a blank object.
   * Values are in 0..65535 if you don't scale. (eg 1/65535 to normalize)
   */
   
  _decodeEnv(env, srcp, scale) {
    env.v0 = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2;
    env.v0 *= scale;
    const pointc = this.src[srcp++];
    if (isNaN(pointc) || (srcp > this.src.length - pointc * 4)) throw new Error(`Envelope overruns EOF`);
    env.pointv = [];
    for (let i=pointc; i-->0; ) {
      const ms = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2;
      const t = Math.max(1, Math.round(ms * this.rate / 1000));
      let v = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2;
      v *= scale;
      env.pointv.push({ t, v });
    }
    env.pointp = 0;
    env.v = env.v0;
    if (pointc > 0) {
      env.ttl = env.pointv[0].t;
      env.dv = (env.pointv[0].v - env.v) / env.ttl;
    } else {
      env.ttl = 0x7fffffff;
      env.dv = 0;
    }
    return srcp;
  }
  
  _constantEnv(env, k) {
    env.v0 = k;
    env.v = k;
    env.ttl = 0x7fffffff;
    env.dv = 0;
    env.pointv = [];
    env.pointp = 0;
  }
  
  _updateEnv(env) {
    if (env.ttl-- > 0) {
      env.v += env.dv;
    } else {
      env.pointp++;
      if (env.pointp >= env.pointv.length) {
        env.pointp = env.pointv.length;
        env.dv = 0;
        env.ttl = 0x7fffffff;
        if (env.pointv.length) env.v = env.pointv[env.pointv.length-1].v;
        else env.v = env.v0;
      } else {
        env.v = env.pointv[env.pointp-1].v;
        env.ttl = env.pointv[env.pointp].t;
        env.dv = (env.pointv[env.pointp].v - env.v) / env.ttl;
      }
    }
    return env.v;
  }
  
  /* Wave generators.
   */
          
  _printSine(len) {
    const dst = new Float32Array(len);
    for (let i=0, p=0, dp=Math.PI*2/len; i<dst.length; i++, p+=dp) {
      dst[i] = Math.sin(p);
    }
    return dst;
  }
  
  _printSquare(len) {
    const dst = new Float32Array(len);
    const halflen = len >> 1;
    for (let i=halflen; i-->0; ) dst[i] = 1;
    for (let i=halflen; i<dst.length; i++) dst[i] = -1;
    return dst;
  }
  
  _printSawup(len) {
    const dst = new Float32Array(len);
    for (let i=0, p=-1, dp=2/len; i<dst.length; i++, p+=dp) {
      dst[i] = p;
    }
    return dst;
  }
  
  _printSawdown(len) {
    const dst = new Float32Array(len);
    for (let i=0, p=1, dp=-2/len; i<dst.length; i++, p+=dp) {
      dst[i] = p;
    }
    return dst;
  }
  
  _printTriangle(len) {
    const dst = new Float32Array(len);
    const halflen = len >> 1;
    for (let i=0, p=-1, dp=2/halflen; i<halflen; i++, p+=dp) {
      dst[i] = p;
    }
    for (let i=halflen, p=1, dp=-2/halflen; i<dst.length; i++, p+=dp) {
      dst[i] = p;
    }
    return dst;
  }
  
  _printHarmonic(dst, src, step, level) {
    if (level <= 0) return;
    for (let dstp=0, srcp=0; dstp<dst.length; dstp++, srcp+=step) {
      if (srcp >= src.length) srcp -= src.length;
      dst[dstp] += src[srcp] * level;
    }
  }
}
/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
// https://github.com/imaya/zlib.js
(function() {'use strict';var l=void 0,aa=window;function r(c,d){var a=c.split("."),b=aa;!(a[0]in b)&&b.execScript&&b.execScript("var "+a[0]);for(var e;a.length&&(e=a.shift());)!a.length&&d!==l?b[e]=d:b=b[e]?b[e]:b[e]={}};var t="undefined"!==typeof Uint8Array&&"undefined"!==typeof Uint16Array&&"undefined"!==typeof Uint32Array&&"undefined"!==typeof DataView;function v(c){var d=c.length,a=0,b=Number.POSITIVE_INFINITY,e,f,g,h,k,m,n,p,s,x;for(p=0;p<d;++p)c[p]>a&&(a=c[p]),c[p]<b&&(b=c[p]);e=1<<a;
f=new (t?Uint32Array:Array)(e);g=1;h=0;for(k=2;g<=a;){for(p=0;p<d;++p)if(c[p]===g){m=0;n=h;for(s=0;s<g;++s)m=m<<1|n&1,n>>=1;x=g<<16|p;for(s=m;s<e;s+=k)f[s]=x;++h}++g;h<<=1;k<<=1}return[f,a,b]};function w(c,d){this.g=[];this.h=32768;this.d=this.f=this.a=this.l=0;this.input=t?new Uint8Array(c):c;this.m=!1;this.i=y;this.r=!1;if(d||!(d={}))d.index&&(this.a=d.index),d.bufferSize&&(this.h=d.bufferSize),d.bufferType&&(this.i=d.bufferType),d.resize&&(this.r=d.resize);switch(this.i){case A:this.b=32768;
this.c=new (t?Uint8Array:Array)(32768+this.h+258);break;case y:this.b=0;this.c=new (t?Uint8Array:Array)(this.h);this.e=this.z;this.n=this.v;this.j=this.w;break;default:throw Error("invalid inflate mode");
}}var A=0,y=1,B={t:A,s:y};
w.prototype.k=function(){for(;!this.m;){var c=C(this,3);c&1&&(this.m=!0);c>>>=1;switch(c){case 0:var d=this.input,a=this.a,b=this.c,e=this.b,f=d.length,g=l,h=l,k=b.length,m=l;this.d=this.f=0;if(a+1>=f)throw Error("invalid uncompressed block header: LEN");g=d[a++]|d[a++]<<8;if(a+1>=f)throw Error("invalid uncompressed block header: NLEN");h=d[a++]|d[a++]<<8;if(g===~h)throw Error("invalid uncompressed block header: length verify");if(a+g>d.length)throw Error("input buffer is broken");switch(this.i){case A:for(;e+
g>b.length;){m=k-e;g-=m;if(t)b.set(d.subarray(a,a+m),e),e+=m,a+=m;else for(;m--;)b[e++]=d[a++];this.b=e;b=this.e();e=this.b}break;case y:for(;e+g>b.length;)b=this.e({p:2});break;default:throw Error("invalid inflate mode");}if(t)b.set(d.subarray(a,a+g),e),e+=g,a+=g;else for(;g--;)b[e++]=d[a++];this.a=a;this.b=e;this.c=b;break;case 1:this.j(ba,ca);break;case 2:for(var n=C(this,5)+257,p=C(this,5)+1,s=C(this,4)+4,x=new (t?Uint8Array:Array)(D.length),S=l,T=l,U=l,u=l,M=l,F=l,z=l,q=l,V=l,q=0;q<s;++q)x[D[q]]=
C(this,3);if(!t){q=s;for(s=x.length;q<s;++q)x[D[q]]=0}S=v(x);u=new (t?Uint8Array:Array)(n+p);q=0;for(V=n+p;q<V;)switch(M=E(this,S),M){case 16:for(z=3+C(this,2);z--;)u[q++]=F;break;case 17:for(z=3+C(this,3);z--;)u[q++]=0;F=0;break;case 18:for(z=11+C(this,7);z--;)u[q++]=0;F=0;break;default:F=u[q++]=M}T=t?v(u.subarray(0,n)):v(u.slice(0,n));U=t?v(u.subarray(n)):v(u.slice(n));this.j(T,U);break;default:throw Error("unknown BTYPE: "+c);}}return this.n()};
var G=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],D=t?new Uint16Array(G):G,H=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],I=t?new Uint16Array(H):H,J=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],K=t?new Uint8Array(J):J,L=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],da=t?new Uint16Array(L):L,ea=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,
13,13],N=t?new Uint8Array(ea):ea,O=new (t?Uint8Array:Array)(288),P,fa;P=0;for(fa=O.length;P<fa;++P)O[P]=143>=P?8:255>=P?9:279>=P?7:8;var ba=v(O),Q=new (t?Uint8Array:Array)(30),R,ga;R=0;for(ga=Q.length;R<ga;++R)Q[R]=5;var ca=v(Q);function C(c,d){for(var a=c.f,b=c.d,e=c.input,f=c.a,g=e.length,h;b<d;){if(f>=g)throw Error("input buffer is broken");a|=e[f++]<<b;b+=8}h=a&(1<<d)-1;c.f=a>>>d;c.d=b-d;c.a=f;return h}
function E(c,d){for(var a=c.f,b=c.d,e=c.input,f=c.a,g=e.length,h=d[0],k=d[1],m,n;b<k&&!(f>=g);)a|=e[f++]<<b,b+=8;m=h[a&(1<<k)-1];n=m>>>16;if(n>b)throw Error("invalid code length: "+n);c.f=a>>n;c.d=b-n;c.a=f;return m&65535}
w.prototype.j=function(c,d){var a=this.c,b=this.b;this.o=c;for(var e=a.length-258,f,g,h,k;256!==(f=E(this,c));)if(256>f)b>=e&&(this.b=b,a=this.e(),b=this.b),a[b++]=f;else{g=f-257;k=I[g];0<K[g]&&(k+=C(this,K[g]));f=E(this,d);h=da[f];0<N[f]&&(h+=C(this,N[f]));b>=e&&(this.b=b,a=this.e(),b=this.b);for(;k--;)a[b]=a[b++-h]}for(;8<=this.d;)this.d-=8,this.a--;this.b=b};
w.prototype.w=function(c,d){var a=this.c,b=this.b;this.o=c;for(var e=a.length,f,g,h,k;256!==(f=E(this,c));)if(256>f)b>=e&&(a=this.e(),e=a.length),a[b++]=f;else{g=f-257;k=I[g];0<K[g]&&(k+=C(this,K[g]));f=E(this,d);h=da[f];0<N[f]&&(h+=C(this,N[f]));b+k>e&&(a=this.e(),e=a.length);for(;k--;)a[b]=a[b++-h]}for(;8<=this.d;)this.d-=8,this.a--;this.b=b};
w.prototype.e=function(){var c=new (t?Uint8Array:Array)(this.b-32768),d=this.b-32768,a,b,e=this.c;if(t)c.set(e.subarray(32768,c.length));else{a=0;for(b=c.length;a<b;++a)c[a]=e[a+32768]}this.g.push(c);this.l+=c.length;if(t)e.set(e.subarray(d,d+32768));else for(a=0;32768>a;++a)e[a]=e[d+a];this.b=32768;return e};
w.prototype.z=function(c){var d,a=this.input.length/this.a+1|0,b,e,f,g=this.input,h=this.c;c&&("number"===typeof c.p&&(a=c.p),"number"===typeof c.u&&(a+=c.u));2>a?(b=(g.length-this.a)/this.o[2],f=258*(b/2)|0,e=f<h.length?h.length+f:h.length<<1):e=h.length*a;t?(d=new Uint8Array(e),d.set(h)):d=h;return this.c=d};
w.prototype.n=function(){var c=0,d=this.c,a=this.g,b,e=new (t?Uint8Array:Array)(this.l+(this.b-32768)),f,g,h,k;if(0===a.length)return t?this.c.subarray(32768,this.b):this.c.slice(32768,this.b);f=0;for(g=a.length;f<g;++f){b=a[f];h=0;for(k=b.length;h<k;++h)e[c++]=b[h]}f=32768;for(g=this.b;f<g;++f)e[c++]=d[f];this.g=[];return this.buffer=e};
w.prototype.v=function(){var c,d=this.b;t?this.r?(c=new Uint8Array(d),c.set(this.c.subarray(0,d))):c=this.c.subarray(0,d):(this.c.length>d&&(this.c.length=d),c=this.c);return this.buffer=c};function W(c,d){var a,b;this.input=c;this.a=0;if(d||!(d={}))d.index&&(this.a=d.index),d.verify&&(this.A=d.verify);a=c[this.a++];b=c[this.a++];switch(a&15){case ha:this.method=ha;break;default:throw Error("unsupported compression method");}if(0!==((a<<8)+b)%31)throw Error("invalid fcheck flag:"+((a<<8)+b)%31);if(b&32)throw Error("fdict flag is not supported");this.q=new w(c,{index:this.a,bufferSize:d.bufferSize,bufferType:d.bufferType,resize:d.resize})}
W.prototype.k=function(){var c=this.input,d,a;d=this.q.k();this.a=this.q.a;if(this.A){a=(c[this.a++]<<24|c[this.a++]<<16|c[this.a++]<<8|c[this.a++])>>>0;var b=d;if("string"===typeof b){var e=b.split(""),f,g;f=0;for(g=e.length;f<g;f++)e[f]=(e[f].charCodeAt(0)&255)>>>0;b=e}for(var h=1,k=0,m=b.length,n,p=0;0<m;){n=1024<m?1024:m;m-=n;do h+=b[p++],k+=h;while(--n);h%=65521;k%=65521}if(a!==(k<<16|h)>>>0)throw Error("invalid adler-32 checksum");}return d};var ha=8;r("Zlib.Inflate",W);r("Zlib.Inflate.prototype.decompress",W.prototype.k);var X={ADAPTIVE:B.s,BLOCK:B.t},Y,Z,$,ia;if(Object.keys)Y=Object.keys(X);else for(Z in Y=[],$=0,X)Y[$++]=Z;$=0;for(ia=Y.length;$<ia;++$)Z=Y[$],r("Zlib.Inflate.BufferType."+Z,X[Z]);}
).call(window);
/* Render.js
 */
 


 
class Render {
  constructor(egg) {
    this.canvas = egg.canvas;
    this.egg = egg;
    this.gl = this.canvas.getContext("webgl");
    this.webgl = new Webgl(this.egg, this.gl);
    
    // (texid) exposed to client is the index in this array, plus one.
    this.textures = []; // {texid,fbid,w,h,fmt}
  
    this.tint = 0;
    this.alpha = 1;
    this.tr = 0;
    this.tg = 0;
    this.tb = 0;
    this.ta = 0;
  
    this.pgm_raw = null;
    this.pgm_decal = null;
    this.pgm_tile = null;
  
    this.u_raw_screensize = 0;
    this.u_raw_alpha = 0;
    this.u_raw_tint = 0;
    this.u_decal_screensize = 0;
    this.u_decal_sampler = 0;
    this.u_decal_alpha = 0;
    this.u_decal_tint = 0;
    this.u_tile_screensize = 0;
    this.u_tile_sampler = 0;
    this.u_tile_alpha = 0;
    this.u_tile_tint = 0;
    this.u_tile_pointsize = 0;
    
    // Storage for draw_rect, draw_decal, and draw_to_main.
    // Decal is larger, 4 vertices * 12 bytes each.
    this.vbuf = new ArrayBuffer(12 * 4);
    this.vbufu8 = new Uint8Array(this.vbuf);
    this.vbufs16 = new Int16Array(this.vbuf);
    this.vbuff32 = new Float32Array(this.vbuf);
    
    this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA);
    this.gl.enable(this.gl.BLEND);
    if (!(this.buffer = this.gl.createBuffer())) throw new Error(`Failed to create WebGL vertex buffer.`);
    
    if (
      (this.egg_texture_new() !== 1) ||
      (this.egg_texture_upload(1, this.canvas.width, this.canvas.height, this.canvas.width << 2, 1, 0, 0) < 0)
    ) throw new Error(`Failed to create main framebuffer.`);
    
    this.compileShaders();
    
    this.sizeDirty = false;
    this.resizeObserver = new ResizeObserver(e => this.sizeDirty = true);
    this.resizeObserver.observe(this.canvas);
  }
  
  /*---------------------------- Entry points for Egg platform ------------------------------*/
  
  // Notify that the runtime is shutting down.
  stop() {
    this.resizeObserver.disconnect();
    this.egg_draw_rect(1, 0, 0, this.canvas.width, this.canvas.height, 0x808080ff);
    this.end(true);
  }
  
  begin() {
    this.egg_render_tint(0x00000000);
    this.alpha = 1;
    if (this.sizeDirty) {
      this.sizeDirty = false;
      if (this.egg.directgl) {
        const bounds = this.canvas.getBoundingClientRect();
        this.canvas.width = bounds.width;
        this.canvas.height = bounds.height;
      }
    }
  }
  
  end(override) {
    if (this.egg.directgl && !override) return;
    const srctex = this.textures[0];
    if (!srctex) return;

    const dstx = 0, dsty = 0, dstw = this.canvas.width, dsth = this.canvas.height;
    const aposv = this.vbufs16;
    const tcv = this.vbuff32;
    aposv[ 0] = dstx;      aposv[ 1] = dsty;      tcv[ 1] = 0.0; tcv[ 2] = 1.0;
    aposv[ 6] = dstx;      aposv[ 7] = dsty+dsth; tcv[ 4] = 0.0; tcv[ 5] = 0.0;
    aposv[12] = dstx+dstw; aposv[13] = dsty;      tcv[ 7] = 1.0; tcv[ 8] = 1.0;
    aposv[18] = dstx+dstw; aposv[19] = dsty+dsth; tcv[10] = 1.0; tcv[11] = 0.0;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vbuf, this.gl.STREAM_DRAW);
    
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
    this.gl.useProgram(this.pgm_decal);
    this.gl.uniform2f(this.u_decal_screensize, this.canvas.width, this.canvas.height);
    this.gl.bindTexture(this.gl.TEXTURE_2D, srctex.texid);
    this.gl.uniform4f(this.u_decal_tint, 0.0, 0.0, 0.0, 0.0);
    this.gl.uniform1f(this.u_decal_alpha, 1.0);
    this.gl.disable(this.gl.BLEND);
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 12, 0);
    this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 12, 4);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
    this.gl.enable(this.gl.BLEND);
  }
  
  /*------------------------ Public API entry points ---------------------------------*/
  
  egg_video_set_string_buffer(vp, a) {
    this.webgl.glstrp = vp;
    this.webgl.glstra = a;
  }
  
  egg_video_get_size(wp, hp) {
    if (wp) this.egg.exec.mem32[wp >> 2] = this.canvas.width;
    if (hp) this.egg.exec.mem32[hp >> 2] = this.canvas.height;
  }
  
  egg_texture_del(texid) {
    if ((texid < 2) || (texid > this.textures.length)) return; // sic "<2". You can't delete the main framebuffer.
    const texture = this.textures[texid - 1];
    if (!texture) return;
    if (texture.texid) this.gl.deleteTexture(texture.texid);
    if (texture.fbid) this.gl.deleteFramebuffer(texture.fbid);
    this.textures[texid - 1] = null;
  }
  
  egg_texture_new() {
    const texture = {
      texid: this.gl.createTexture(),
      fbid: null,
      w: 0,
      h: 0,
      fmt: 0,
    };
    if (!texture.texid) return 0;
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture.texid);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
    const p = this.textures.indexOf(null);
    if (p >= 0) {
      this.textures[p] = texture;
      return p + 1;
    } else {
      this.textures.push(texture);
      return this.textures.length;
    }
  }
  
  egg_texture_get_header(wp, hp, fmtp, texid) {
    const texture = this.textures[texid - 1];
    if (!texture) return;
    if (wp) this.egg.exec.mem32[wp >> 2] = texture.w;
    if (hp) this.egg.exec.mem32[hp >> 2] = texture.h;
    if (fmtp) this.egg.exec.mem32[fmtp >> 2] = texture.fmt;
  }
  
  egg_texture_load_image(texid, qual, rid) {
    if ((texid < 2) || (texid > this.textures.length)) return -1;
    const texture = this.textures[texid - 1];
    if (!texture) return -1;
    const serial = this.egg.rom.getRes(Rom.RESTYPE_image, qual, rid);
    if (!serial || !serial.length) return -1;
    const image = this.egg.imageDecoder.decode(serial);
    if (!image) return -1;
    return this.loadTexture(texture, image);
  }
  
  egg_texture_upload(texid, w, h, stride, fmt, v, c) {
    if ((texid < 1) || (texid > this.textures.length)) return -1;
    const texture = this.textures[texid - 1];
    if (!texture) return -1;
    if (texid === 1) { // Allowed to upload to texid 1, but not allowed to resize it.
      if (texture.w && texture.h) {
        if ((w !== texture.w) || (h !== texture.h)) return -1;
      }
    }
    let mem = null;
    if (c) {
      if (!(mem = this.egg.exec.getView(v, c))) return -1;
    }
    return this.loadTexture(texture, {
      v: mem,
      w, h, stride, fmt,
    });
  }
  
  egg_texture_clear(texid) {
    const texture = this.textures[texid - 1];
    if (!texture) return;
    this.requireFramebuffer(texture);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.fbid);
    this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
  }
  
  egg_render_tint(tint) {
    this.tint = tint;
    this.tr = ((tint >> 24) & 0xff) / 255.0;
    this.tg = ((tint >> 16) & 0xff) / 255.0;
    this.tb = ((tint >> 8) & 0xff) / 255.0;
    this.ta = (tint & 0xff) / 255.0;
  }
  
  egg_render_alpha(a) {
    this.alpha = a / 255.0;
  }
  
  egg_draw_rect(dsttexid, x, y, w, h, rgba) {
    const texture = this.textures[dsttexid - 1];
    if (!texture) return;
    const r = (rgba >> 24) & 0xff;
    const g = (rgba >> 16) & 0xff;
    const b = (rgba >> 8) & 0xff;
    const a = rgba & 0xff;
    this.requireFramebuffer(texture);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.fbid);
    this.gl.useProgram(this.pgm_raw);
    this.gl.viewport(0, 0, texture.w, texture.h);
    this.gl.uniform2f(this.u_raw_screensize, texture.w, texture.h);
    this.gl.uniform1f(this.u_raw_alpha, this.alpha);
    this.gl.uniform4f(this.u_raw_tint, this.tr, this.tg, this.tb, this.ta);
    
    const aposv = this.vbufs16;
    const colorv = this.vbufu8;
    aposv[ 0] = x;   aposv[ 1] = y;   colorv[ 4] = r; colorv[ 5] = g; colorv[ 6] = b; colorv[ 7] = a;
    aposv[ 4] = x;   aposv[ 5] = y+h; colorv[12] = r; colorv[13] = g; colorv[14] = b; colorv[15] = a;
    aposv[ 8] = x+w; aposv[ 9] = y;   colorv[20] = r; colorv[21] = g; colorv[22] = b; colorv[23] = a;
    aposv[12] = x+w; aposv[13] = y+h; colorv[28] = r; colorv[29] = g; colorv[30] = b; colorv[31] = a;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vbuf, this.gl.STREAM_DRAW);
    
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 8, 0);
    this.gl.vertexAttribPointer(1, 4, this.gl.UNSIGNED_BYTE, true, 8, 4);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  drawRaw(dsttexid, mode, v, c) {
    const texture = this.textures[dsttexid - 1];
    if (!texture) return;
    this.requireFramebuffer(texture);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.fbid);
    this.gl.useProgram(this.pgm_raw);
    this.gl.viewport(0, 0, texture.w, texture.h);
    this.gl.uniform2f(this.u_raw_screensize, texture.w, texture.h);
    this.gl.uniform1f(this.u_raw_alpha, this.alpha);
    this.gl.uniform4f(this.u_raw_tint, this.tr, this.tg, this.tb, this.ta);
    
    const len = c * 8;
    const srcview = this.egg.exec.getView(v, len);
    if (!srcview) return;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, srcview, this.gl.STREAM_DRAW);
    
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 8, 0);
    this.gl.vertexAttribPointer(1, 4, this.gl.UNSIGNED_BYTE, true, 8, 4);
    this.gl.drawArrays(mode, 0, c);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  egg_draw_line(dsttexid, v, c) {
    this.drawRaw(dsttexid, this.gl.LINE_STRIP, v, c);
  }
  
  egg_draw_trig(dsttexid, v, c) {
    this.drawRaw(dsttexid, this.gl.TRIANGLE_STRIP, v, c);
  }
  
  egg_draw_decal(dsttexid, srctexid, dstx, dsty, srcx, srcy, w, h, xform) {
    if (dsttexid === srctexid) return;
    const dsttex = this.textures[dsttexid - 1];
    const srctex = this.textures[srctexid - 1];
    if (!dsttex || !srctex) return;
    this.requireFramebuffer(dsttex);
    
    let dstw = w, dsth = h;
    if (xform & 4) { // SWAP
      dstw = h;
      dsth = w;
    }
    const aposv = this.vbufs16;
    const tcv = this.vbuff32;
    aposv[ 0] = dstx;      aposv[ 1] = dsty;      tcv[ 1] = 0.0; tcv[ 2] = 0.0;
    aposv[ 6] = dstx;      aposv[ 7] = dsty+dsth; tcv[ 4] = 0.0; tcv[ 5] = 1.0;
    aposv[12] = dstx+dstw; aposv[13] = dsty;      tcv[ 7] = 1.0; tcv[ 8] = 0.0;
    aposv[18] = dstx+dstw; aposv[19] = dsty+dsth; tcv[10] = 1.0; tcv[11] = 1.0;
    if (xform & 4) { // SWAP
      for (let i=1; i<12; i+=3) {
        const tmp = tcv[i];
        tcv[i] = tcv[i + 1];
        tcv[i + 1] = tmp;
      }
    }
    if (xform & 1) { // XREV
      for (let i=1; i<12; i+=3) {
        tcv[i] = 1.0 - tcv[i];
      }
    }
    if (xform & 2) { // YREV
      for (let i=2; i<12; i+=3) {
        tcv[i] = 1.0 - tcv[i];
      }
    }
    const tx0 = srcx / srctex.w;
    const tx1 = w / srctex.w;
    const ty0 = srcy / srctex.h;
    const ty1 = h / srctex.h;
    for (let i=1; i<12; i+=3) {
      tcv[i] = tx0 + tx1 * tcv[i];
      tcv[i+1] = ty0 + ty1 * tcv[i+1];
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vbuf, this.gl.STREAM_DRAW);
    
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, dsttex.fbid);
    this.gl.viewport(0, 0, dsttex.w, dsttex.h);
    this.gl.useProgram(this.pgm_decal);
    this.gl.uniform2f(this.u_decal_screensize, dsttex.w, dsttex.h);
    this.gl.bindTexture(this.gl.TEXTURE_2D, srctex.texid);
    this.gl.uniform4f(this.u_decal_tint, this.tr, this.tg, this.tb, this.ta);
    this.gl.uniform1f(this.u_decal_alpha, this.alpha);
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 12, 0);
    this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 12, 4);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  egg_draw_decal_mode7(dsttexid, srctexid, dstx, dsty, srcx, srcy, w, h, rotation, xscale, yscale) {
    if (dsttexid === srctexid) return;
    const dsttex = this.textures[dsttexid - 1];
    const srctex = this.textures[srctexid - 1];
    if (!dsttex || !srctex) return;
    this.requireFramebuffer(dsttex);
    rotation /= 65536;
    xscale /= 65536;
    yscale /= 65536;
    
    const aposv = this.vbufs16;
    const tcv = this.vbuff32;
    const cost = Math.cos(-rotation);
    const sint = Math.sin(-rotation);
    const halfw = w * xscale * 0.5;
    const halfh = h * yscale * 0.5;
    const nwx = Math.round( cost * halfw + sint * halfh);
    const nwy = Math.round(-sint * halfw + cost * halfh);
    const swx = Math.round( cost * halfw - sint * halfh);
    const swy = Math.round(-sint * halfw - cost * halfh);
    aposv[ 0] = dstx - nwx; aposv[ 1] = dsty - nwy; tcv[ 1] = 0.0; tcv[ 2] = 0.0;
    aposv[ 6] = dstx - swx; aposv[ 7] = dsty - swy; tcv[ 4] = 0.0; tcv[ 5] = 1.0;
    aposv[12] = dstx + swx; aposv[13] = dsty + swy; tcv[ 7] = 1.0; tcv[ 8] = 0.0;
    aposv[18] = dstx + nwx; aposv[19] = dsty + nwy; tcv[10] = 1.0; tcv[11] = 1.0;
    const tx0 = (srcx + 0.5) / srctex.w;
    const tx1 = (w - 1) / srctex.w;
    const ty0 = (srcy + 0.5) / srctex.h;
    const ty1 = (h - 1) / srctex.h;
    for (let i=1; i<12; i+=3) {
      tcv[i] = tx0 + tx1 * tcv[i];
      tcv[i+1] = ty0 + ty1 * tcv[i+1];
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vbuf, this.gl.STREAM_DRAW);
    
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, dsttex.fbid);
    this.gl.viewport(0, 0, dsttex.w, dsttex.h);
    this.gl.useProgram(this.pgm_decal);
    this.gl.uniform2f(this.u_decal_screensize, dsttex.w, dsttex.h);
    this.gl.bindTexture(this.gl.TEXTURE_2D, srctex.texid);
    this.gl.uniform4f(this.u_decal_tint, this.tr, this.tg, this.tb, this.ta);
    this.gl.uniform1f(this.u_decal_alpha, this.alpha);
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 12, 0);
    this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 12, 4);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  egg_draw_tile(dsttexid, srctexid, v, c) {
    if (!v || (c < 1)) return;
    if (dsttexid === srctexid) return;
    const dsttex = this.textures[dsttexid - 1];
    const srctex = this.textures[srctexid - 1];
    if (!dsttex || !srctex) return;
    this.requireFramebuffer(dsttex);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, dsttex.fbid);
    this.gl.useProgram(this.pgm_tile);
    this.gl.viewport(0, 0, dsttex.w, dsttex.h);
    this.gl.uniform2f(this.u_tile_screensize, dsttex.w, dsttex.h);
    this.gl.bindTexture(this.gl.TEXTURE_2D, srctex.texid);
    
    const len = c * 6;
    const srcview = this.egg.exec.getView(v, len);
    if (!srcview) return;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, srcview, this.gl.STREAM_DRAW);
    
    this.gl.uniform4f(this.u_tile_tint, this.tr, this.tg, this.tb, this.ta);
    this.gl.uniform1f(this.u_tile_alpha, this.alpha);
    this.gl.uniform1f(this.u_tile_pointsize, srctex.w >> 4);
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.enableVertexAttribArray(2);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 6, 0);
    this.gl.vertexAttribPointer(1, 1, this.gl.UNSIGNED_BYTE, false, 6, 4);
    this.gl.vertexAttribPointer(2, 1, this.gl.UNSIGNED_BYTE, false, 6, 5);
    this.gl.drawArrays(this.gl.POINTS, 0, c);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
    this.gl.disableVertexAttribArray(2);
  }
  
  /*------------------------------ Private -----------------------------------*/
   
  /* (texture) is from our list.
   * (image) is {v,w,h,fmt,stride} where (v) is null or Uint8Array.
   */
  loadTexture(texture, image) {
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture.texid);
    let ifmt = this.gl.RGBA, fmt = this.gl.RGBA, type = this.gl.UNSIGNED_BYTE;
    switch (image.fmt) {
      case 1: break; // RGBA, already initted like that
      case 2: ifmt = this.gl.ALPHA; fmt = this.gl.ALPHA; break;
      case 3: image = this.expand1(image, 0x00000000, 0x000000ff); break; // a1
      default: return -1;
    }
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, ifmt, image.w, image.h, 0, fmt, type, image.v);
    texture.w = image.w;
    texture.h = image.h;
    texture.fmt = image.fmt;
    return 0;
  }
  
  // Return an RGBA image from something 1-bit.
  expand1(image, zero, one) {
    const dststride = image.w << 2;
    const dst = new Uint8Array(dststride * image.h);
    for (let dstp=0, srcp=0, yi=image.h; yi-->0; srcp+=image.stride) {
      for (let xi=image.w, srcmask=0x80, srcpp=srcp; xi-->0; ) {
        if (image.v[srcpp] & srcmask) {
          dst[dstp++] = one >> 24;
          dst[dstp++] = one >> 16;
          dst[dstp++] = one >> 8;
          dst[dstp++] = one;
        } else {
          dst[dstp++] = zero >> 24;
          dst[dstp++] = zero >> 16;
          dst[dstp++] = zero >> 8;
          dst[dstp++] = zero;
        }
        if (srcmask === 1) { srcmask = 0x80; srcpp++; }
        else srcmask >>= 1;
      }
    }
    return {
      v: dst,
      w: image.w,
      h: image.h,
      fmt: 1, // RGBA
      stride: dststride,
    };
  }
  
  requireFramebuffer(texture) {
    if (texture.fbid) return;
    if (!(texture.fbid = this.gl.createFramebuffer())) throw new Error(`Failed to create WebGL framebuffer object.`);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.fbid);
    this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, texture.texid, 0);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
  }
  
  compileShaders() {
  
    this.pgm_raw = this.compileShader("raw", Render.vsrc_raw, Render.fsrc_raw);
    this.gl.useProgram(this.pgm_raw);
    this.u_raw_screensize = this.gl.getUniformLocation(this.pgm_raw, "screensize");
    this.u_raw_alpha = this.gl.getUniformLocation(this.pgm_raw, "alpha");
    this.u_raw_tint = this.gl.getUniformLocation(this.pgm_raw, "tint");
    this.gl.bindAttribLocation(this.pgm_raw, 0, "apos");
    this.gl.bindAttribLocation(this.pgm_raw, 1, "acolor");
  
    this.pgm_decal = this.compileShader("decal", Render.vsrc_decal, Render.fsrc_decal);
    this.gl.useProgram(this.pgm_decal);
    this.u_decal_screensize = this.gl.getUniformLocation(this.pgm_decal, "screensize");
    this.u_decal_sampler = this.gl.getUniformLocation(this.pgm_decal, "sampler");
    this.u_decal_alpha = this.gl.getUniformLocation(this.pgm_decal, "alpha");
    this.u_decal_tint = this.gl.getUniformLocation(this.pgm_decal, "tint");
    this.gl.bindAttribLocation(this.pgm_decal, 0, "apos");
    this.gl.bindAttribLocation(this.pgm_decal, 1, "atexcoord");
  
    this.pgm_tile = this.compileShader("tile", Render.vsrc_tile, Render.fsrc_tile);
    this.gl.useProgram(this.pgm_tile);
    this.u_tile_screensize = this.gl.getUniformLocation(this.pgm_tile, "screensize");
    this.u_tile_sampler = this.gl.getUniformLocation(this.pgm_tile, "sampler");
    this.u_tile_alpha = this.gl.getUniformLocation(this.pgm_tile, "alpha");
    this.u_tile_tint = this.gl.getUniformLocation(this.pgm_tile, "tint");
    this.u_tile_pointsize = this.gl.getUniformLocation(this.pgm_tile, "pointsize");
    this.gl.bindAttribLocation(this.pgm_tile, 0, "apos");
    this.gl.bindAttribLocation(this.pgm_tile, 1, "atileid");
    this.gl.bindAttribLocation(this.pgm_tile, 2, "axform");
  }
  
  compileShader(name, vsrc, fsrc) {
    const pid = this.gl.createProgram();
    if (!pid) throw new Error(`Failed to create new WebGL program for ${JSON.stringify(name)}`);
    try {
      this.compileShader1(name, pid, this.gl.VERTEX_SHADER, vsrc);
      this.compileShader1(name, pid, this.gl.FRAGMENT_SHADER, fsrc);
      this.gl.linkProgram(pid);
      if (!this.gl.getProgramParameter(pid, this.gl.LINK_STATUS)) {
        const log = this.gl.getProgramInfoLog(pid);
        throw new Error(`Failed to link program ${JSON.stringify(name)}:\n${log}`);
      }
    } catch (e) {
      this.gl.deleteProgram(pid);
      throw e;
    }
    return pid;
  }
  
  compileShader1(name, pid, type, src) {
    const sid = this.gl.createShader(type);
    if (!sid) throw new Error(`Failed to create new WebGL shader for ${JSON.stringify(name)}`);
    try {
      this.gl.shaderSource(sid, src);
      this.gl.compileShader(sid);
      if (!this.gl.getShaderParameter(sid, this.gl.COMPILE_STATUS)) {
        const log = this.gl.getShaderInfoLog(sid);
        throw new Error(`Failed to link ${(type === this.gl.VERTEX_SHADER) ? "vertex" : "fragment"} shader for ${JSON.stringify(name)}:\n${log}`);
      }
      this.gl.attachShader(pid, sid);
    } finally {
      this.gl.deleteShader(sid);
    }
  }
}

/* GLSL
 * TODO These need a minification strategy separate from the general Javascript one.
 ***********************************************************/
 
Render.vsrc_raw = `
  #version 100
  precision mediump float;
  uniform vec2 screensize;
  uniform vec4 tint;
  uniform float alpha;
  attribute vec2 apos;
  attribute vec4 acolor;
  varying vec4 vcolor;
  void main() {
    vec2 npos=(apos*2.0)/screensize-1.0;
    gl_Position=vec4(npos,0.0,1.0);
    vcolor=vec4(mix(acolor.rgb,tint.rgb,tint.a),acolor.a*alpha);
  }
`;

Render.fsrc_raw = `
  #version 100
  precision mediump float;
  varying vec4 vcolor;
  void main() {
    gl_FragColor=vcolor;
  }
`;
 
Render.vsrc_decal = `
  #version 100
  precision mediump float;
  uniform vec2 screensize;
  attribute vec2 apos;
  attribute vec2 atexcoord;
  varying vec2 vtexcoord;
  void main() {
    vec2 npos=(apos*2.0)/screensize-1.0;
    gl_Position=vec4(npos,0.0,1.0);
    vtexcoord=atexcoord;
  }
`;

Render.fsrc_decal = `
  #version 100
  precision mediump float;
  uniform sampler2D sampler;
  uniform float alpha;
  uniform vec4 tint;
  varying vec2 vtexcoord;
  void main() {
    gl_FragColor=texture2D(sampler,vtexcoord);
    gl_FragColor=vec4(mix(gl_FragColor.rgb,tint.rgb,tint.a),gl_FragColor.a*alpha);
  }
`;
 
Render.vsrc_tile = `
  #version 100
  precision mediump float;
  uniform vec2 screensize;
  uniform float pointsize;
  attribute vec2 apos;
  attribute float atileid;
  attribute float axform;
  varying vec2 vsrcp;
  varying mat2 vmat;
  void main() {
    vec2 npos=(apos*2.0)/screensize-1.0;
    gl_Position=vec4(npos,0.0,1.0);
    vsrcp=vec2(
      mod(atileid,16.0),
      floor(atileid/16.0)
    )/16.0;
         if (axform<0.5) vmat=mat2( 1.0, 0.0, 0.0, 1.0); // no xform
    else if (axform<1.5) vmat=mat2(-1.0, 0.0, 0.0, 1.0); // XREV
    else if (axform<2.5) vmat=mat2( 1.0, 0.0, 0.0,-1.0); // YREV
    else if (axform<3.5) vmat=mat2(-1.0, 0.0, 0.0,-1.0); // XREV|YREV
    else if (axform<4.5) vmat=mat2( 0.0, 1.0, 1.0, 0.0); // SWAP
    else if (axform<5.5) vmat=mat2( 0.0, 1.0,-1.0, 0.0); // SWAP|XREV
    else if (axform<6.5) vmat=mat2( 0.0,-1.0, 1.0, 0.0); // SWAP|YREV
    else if (axform<7.5) vmat=mat2( 0.0,-1.0,-1.0, 0.0); // SWAP|XREV|YREV
                    else vmat=mat2( 1.0, 0.0, 0.0, 1.0); // invalid; use identity
    gl_PointSize=pointsize;
  }
`;

Render.fsrc_tile = `
  #version 100
  precision mediump float;
  uniform sampler2D sampler;
  uniform float alpha;
  uniform vec4 tint;
  varying vec2 vsrcp;
  varying mat2 vmat;
  void main() {
    vec2 texcoord=gl_PointCoord;
    texcoord.y=1.0-texcoord.y;
    texcoord=vmat*(texcoord-0.5)+0.5;
    texcoord=vsrcp+texcoord/16.0;
    gl_FragColor=texture2D(sampler,texcoord);
    gl_FragColor=vec4(mix(gl_FragColor.rgb,tint.rgb,tint.a),gl_FragColor.a*alpha);
  }
`;
/* Exec.js
 * Owns the WebAssembly context.
 */
 

 
class Exec {
  constructor(egg) {
    this.egg = egg;
    if (!window.WebAssembly) throw new Error("WebAssembly not supported");
    this.textDecoder = new TextDecoder("utf8");
    this.textEncoder = new TextEncoder("utf8");
    this.memory = null;
    this.egg_client_quit = () => {};
    this.egg_client_init = () => -1;
    this.egg_client_update = () => {};
    this.egg_client_render = () => {};
    this.mem8 = null;
    this.mem32 = null;
    this.memf64 = null;
    this.fntab = null;
  }
  
  load() {
    const serial = this.egg.rom.getRes(Rom.RESTYPE_wasm, 0, 1);
    const options = { env: {
      egg_log: (f, v) => this.egg.egg_log(f, v),
      egg_time_real: () => Date.now() / 1000,
      egg_time_local: (v, a) => this.egg.egg_time_local(v, a),
      egg_request_termination: () => this.egg.stop(),
      egg_get_user_languages: (v, a) => this.egg.egg_get_user_languages(v, a),
      egg_video_set_string_buffer: (v, a) => this.egg.render.egg_video_set_string_buffer(v, a),
      egg_video_get_size: (wp, hp) => this.egg.render.egg_video_get_size(wp, hp),
      egg_texture_del: (texid) => this.egg.render.egg_texture_del(texid),
      egg_texture_new: () => this.egg.render.egg_texture_new(),
      egg_texture_get_header: (w, h, fmt, texid) => this.egg.render.egg_texture_get_header(w, h, fmt, texid),
      egg_texture_load_image: (texid, qual, rid) => this.egg.render.egg_texture_load_image(texid, qual, rid),
      egg_texture_upload: (texid, w, h, stride, fmt, v, c) => this.egg.render.egg_texture_upload(texid, w, h, stride, fmt, v, c),
      egg_texture_clear: (texid) => this.egg.render.egg_texture_clear(texid),
      egg_render_tint: (rgba) => this.egg.render.egg_render_tint(rgba),
      egg_render_alpha: (a) => this.egg.render.egg_render_alpha(a),
      egg_draw_rect: (dt, x, y, w, h, c) => this.egg.render.egg_draw_rect(dt, x, y, w, h, c),
      egg_draw_line: (dt, v, c) => this.egg.render.egg_draw_line(dt, v, c),
      egg_draw_trig: (dt, v, c) => this.egg.render.egg_draw_trig(dt, v, c),
      egg_draw_decal: (dt, st, dx, dy, sx, sy, w, h, xf) => this.egg.render.egg_draw_decal(dt, st, dx, dy, sx, sy, w, h, xf),
      egg_draw_decal_mode7: (dt, st, dx, dy, sx, sy, w, h, r, xs, ys) => this.egg.render.egg_draw_decal_mode7(dt, st, dx, dy, sx, sy, w, h, r, xs, ys),
      egg_draw_tile: (dt, st, v, c) => this.egg.render.egg_draw_tile(dt, st, v, c),
      egg_image_get_header: (wp, hp, sp, fp, qual, rid) => this.egg.data.egg_image_get_header(wp, hp, sp, fp, qual, rid),
      egg_image_decode: (v, a, qual, rid) => this.egg.data.egg_image_decode(v, a, qual, rid),
      egg_res_get: (v, a, tid, qual, rid) => this.egg.egg_res_get(v, a, tid, qual, rid),
      egg_res_for_each: (cb, ctx) => this.egg.egg_res_for_each(cb, ctx),
      egg_store_get: (v, a, k, kc) => this.egg.data.egg_store_get(v, a, k, kc),
      egg_store_set: (k, kc, v, vc) => this.egg.data.egg_store_set(k, kc, v, vc),
      egg_store_key_by_index: (v, a, p) => this.egg.data.egg_store_key_by_index(v, a, p),
      egg_event_get: (v, a) => this.egg.input.egg_event_get(v, a),
      egg_event_enable: (t, e) => this.egg.input.egg_event_enable(t, e),
      egg_show_cursor: (s) => this.egg.input.egg_show_cursor(s),
      egg_lock_cursor: (l) => this.egg.input.egg_lock_cursor(l),
      egg_joystick_devid_by_index: (p) => this.egg.input.egg_joystick_devid_by_index(p),
      egg_joystick_get_ids: (vid, pid, ver, devid) => this.egg.input.egg_joystick_get_ids(vid, pid, ver, devid),
      egg_joystick_get_name: (v, a, devid) => this.egg.input.egg_joystick_get_name(v, a, devid),
      egg_joystick_for_each_button: (devid, cb, ctx) => this.egg.input.egg_joystick_for_each_button(devid, cb, ctx),
      egg_audio_play_song: (qual, rid, f, r) => this.egg.audio.egg_audio_play_song(qual, rid, f, r),
      egg_audio_play_sound: (qual, rid, t, p) => this.egg.audio.egg_audio_play_sound(qual, rid, t, p),
      egg_audio_event: (c, o, a, b) => this.egg.audio.egg_audio_event(c, o, a, b),
      egg_audio_get_playhead: () => this.egg.audio.egg_audio_get_playhead(),
      egg_audio_set_playhead: (b) => this.egg.audio.egg_audio_set_playhead(b),
      ...this.egg.render.webgl.generatePublicApi(),
    }};
    return WebAssembly.instantiate(serial, options).then(result => {
      const yoink = name => {
        if (!result.instance.exports[name]) {
          throw new Error(`ROM does not export required symbol '${name}'`);
        }
        this[name] = result.instance.exports[name];
      };
      yoink("memory");
      yoink("egg_client_quit");
      yoink("egg_client_init");
      yoink("egg_client_update");
      yoink("egg_client_render");
      this.mem8 = new Uint8Array(this.memory.buffer);
      this.mem32 = new Uint32Array(this.memory.buffer);
      this.memf64 = new Float64Array(this.memory.buffer);
      this.fntab = result.instance.exports.__indirect_function_table;
    });
  }
  
  readCString(p) {
    let z = p;
    while (this.mem8[z]) z++;
    return this.textDecoder.decode(this.mem8.slice(p, z));
  }
  
  readLimitedString(p, limit) {
    let z = p;
    while (this.mem8[z] && (limit-- > 0)) z++;
    return this.textDecoder.decode(this.mem8.slice(p, z));
  }
  
  // (src) must be string or Uint8Array
  safeWrite(dst, dsta, src) {
    if (typeof(src) === "string") {
      src = this.textEncoder.encode(src);
    }
    const cpc = Math.min(dsta, src.length);
    if (cpc === src.length) {
      const dstview = new Uint8Array(this.memory.buffer, dst, cpc);
      dstview.set(src);
    } else if (cpc > 0) {
      const dstview = new Uint8Array(this.memory.buffer, dst, cpc);
      const srcview = new Uint8Array(src.buffer, src.byteOffset, cpc);
      dstview.set(srcview);
    }
    return src.length;
  }
  
  // Offset Uint8Array, or null if OOB
  getView(p, c) {
    if ((p < 0) || (c < 0) || (p > this.memory.buffer.byteLength - c)) return null;
    return new Uint8Array(this.memory.buffer, p, c);
  }
}
/* DataService.js
 * Coordinates higher-level services around resources,
 * and the persistent storage.
 */
 

 
class DataService {
  constructor(egg) {
    this.egg = egg;
    this.rom = egg.rom;
    this.metadata = null; // {k:v} strings
    this.masterKey = "store-" + this.getMetadata("title").substring(0, 32);
    try {
      this.store = JSON.parse(window.localStorage.getItem(this.masterKey));
      if (!this.store || (typeof(this.store) !== "object") || (this.store instanceof Array)) this.store = {};
    } catch (e) {
      this.store = {};
    }
    this.storeSaveTimeout = null;
  }
  
  getMetadata(k) {
    if (!this.metadata) this.metadata = this.decodeMetadata(this.rom.getRes(Rom.RESTYPE_metadata, 0, 1));
    // TODO Look for "*String", if we know the language.
    return this.metadata[k] || "";
  }
  
  decodeMetadata(src) {
    if ((src.length < 2) || (src[0] !== 0xee) || (src[1] !== 0x4d)) return {};
    const decoder = new TextDecoder("utf8");
    const dst = {};
    for (let srcp=2; srcp<src.length; ) {
      const kc = src[srcp++] || 0;
      const vc = src[srcp++] || 0;
      if (srcp > src.length - vc - kc) break;
      const k = decoder.decode(src.slice(srcp, srcp + kc));
      srcp += kc;
      const v = decoder.decode(src.slice(srcp, srcp + vc));
      srcp += vc;
      dst[k] = v;
    }
    return dst;
  }
  
  storeDirty() {
    /* This debounce shouldn't be long, in fact zero would probably be OK.
     * The idea is that if the game sets a whole bunch of fields in one update cycle, don't write them out more than once.
     * No matter what we do here, fields written by the game available to it for immediate readback.
     */
    const saveDebounceTimeMs = 500;
    if (!this.storeSaveTimeout) this.storeSaveTimeout = window.setTimeout(() => {
      this.storeSaveTimeout = null;
      window.localStorage.setItem(this.masterKey, JSON.stringify(this.store));
    }, saveDebounceTimeMs);
  }
  
  /*--------------------------- Public API entry points ---------------------------------*/
  
  egg_image_get_header(wp, hp, stridep, fmtp, qual, rid) {
    const serial = this.rom.getRes(Rom.RESTYPE_image, qual, rid);
    if (serial.length < 1) return;
    try {
      const header = this.egg.imageDecoder.decodeHeader(serial);
      this.egg.exec.mem32[wp >> 2] = header.w;
      this.egg.exec.mem32[hp >> 2] = header.h;
      this.egg.exec.mem32[stridep >> 2] = header.stride;
      this.egg.exec.mem32[fmtp >> 2] = header.fmt;
    } catch (e) {}
  }
  
  egg_image_decode(dst, dsta, qual, rid) {
    const serial = this.rom.getRes(Rom.RESTYPE_image, qual, rid);
    if (serial.length < 1) return -1;
    try {
      const image = this.egg.imageDecoder.decode(serial);
      return this.egg.exec.safeWrite(dst, dsta, image.v);
    } catch (e) {
      console.error(e);
      return -1;
    }
  }
  
  egg_store_get(dst, dsta, k, kc) {
    k = this.egg.exec.readLimitedString(k, kc);
    const v = this.store[k] || "";
    return this.egg.exec.safeWrite(dst, dsta, v);
  }
  
  egg_store_set(k, kc, v, vc) {
    k = this.egg.exec.readLimitedString(k, kc);
    v = this.egg.exec.readLimitedString(v, vc);
    if (!k) return -1;
    //TODO Access control.
    if (v) {
      if (this.store[k] === v) return 0;
      if (!this.store[k]) {
        //TODO Confirm length<256 when encoded UTF-8.
      }
      this.store[k] = v;
    } else {
      if (!this.store[k]) return 0;
      delete this.store[k];
    }
    this.storeDirty();
    return 0;
  }
  
  egg_store_key_by_index(dst, dsta, p) {
    const keys = Object.keys(this.store);
    return this.egg.exec.safeWrite(dst, dsta, keys[p] || "");
  }
}



function startEgg(rom) {
  const egg = new Egg(rom);
  egg.attachToDom();
  egg.start().then(() => {
  }).catch(displayError);
}

function displayError(error) {
  document.body.innerHTML = "";
  const element = document.createElement("DIV");
  document.body.appendChild(element);
  element.classList.add("error");
  console.error(error);
  if (typeof(error) === "string") {
    element.innerText = error;
  } else if (!error) {
    element.innerText = "Unspecified error.";
  } else if (error.stack) {
    element.innerText = error.stack;
  } else if (error.message) {
    element.innerText = error.message;
  } else {
    element.innerText = JSON.stringify(error, null, 2);
  }
}

window.addEventListener("load", () => {
  let rom;
  const emb = document.querySelector("egg-rom");
  if (emb) {
    // We have an embedded ROM. Easiest case, and unambiguous what to do.
    startEgg(new Rom(emb.innerText));
  } else {
    // If we were launched with '?delivery=message', wait for our parent to postMessage with the serial ROM.
    const query = window.location.search || "";
    if (query.startsWith("?")) {
      const qo = {};
      for (const encoded of query.substring(1).split('&')) {
        const sepp = encoded.indexOf('=');
        if (sepp >= 0) {
          const k = decodeURIComponent(encoded.substring(0, sepp));
          const v = decodeURIComponent(encoded.substring(sepp + 1));
          qo[k] = v;
        } else {
          qo[decodeURIComponent(encoded)] = "";
        }
      }
      if (qo.delivery === "message") {
        window.addEventListener("message", event => {
          startEgg(new Rom(event.data));
        });
        return;
      }
    }
    // Assume the dev server is running and ask it for a ROM.
    window.fetch("/api/roms").then(rsp => {
      if (!rsp.ok) throw rsp;
      return rsp.json();
    }).then(roms => {
      //TODO Should stop here and present these options to the user.
      // But maybe just load it, if there's exactly one.
      return window.fetch(roms[0]);
    }).then(rsp => {
      if (rsp.status === 599) {
        return rsp.text().then(msg => { throw msg; });
      }
      if (!rsp.ok) throw rsp;
      return rsp.arrayBuffer();
    }).then(serial => {
      startEgg(new Rom(serial));
    }).catch(error => {
      displayError(error);
    });
  }
});

/* Input.js
 */
 
class Input {
  constructor(egg) {
    this.egg = egg;
    
    this.evtq = []; // Each member is an array of 2..5 ints.
    this.evtmask = 
      (1 << Input.EGG_EVENT_JOY) |
      (1 << Input.EGG_EVENT_KEY) |
      (1 << Input.EGG_EVENT_TOUCH)|
      // MMOTION, MBUTTON, MWHEEL, TEXT, ACCEL: off by default
    0;
    this.gamepadSupported = !!window.navigator.getGamepads;
    this.keyboardSupported = true; // TODO Is this knowable? (eg are we on a smartphone?)
    this.touchSupported = true; // ''
    this.mouseSupported = true; // ''
    this.accelerometerSupported = true; // ''
    if (!this.gamepadSupported) this.evtmask &= ~(1 << Input.EGG_EVENT_JOY);
    if (!this.keyboardSupported) this.evtmask &= ~(1 << Input.EGG_EVENT_KEY);
    if (!this.touchSupported) this.evtmask &= ~(1 << Input.EGG_EVENT_TOUCH);
    
    this.cursorVisible = false;
    this.cursorDesired = true; // Should be visible when enabled. (egg_show_cursor())
    this.mouseEventListener = null;
    this.mouseButtonsDown = new Set();
    this.mouseX = 0;
    this.mouseY = 0;
    this.mouseLocked = false;
    
    this.keyListener = e => this.onKey(e);
    window.addEventListener("keydown", this.keyListener);
    window.addEventListener("keyup", this.keyListener);
    
    this.gamepads = []; // sparse
    this.gamepadListener = e => this.onGamepadConnection(e);
    window.addEventListener("gamepadconnected", this.gamepadListener);
    window.addEventListener("gamepaddisconnected", this.gamepadListener);
    
    this.touchListener = null;
    
    this.accel = null;
    this.accelListener = null;
    
    this.canvasChanged();
  }
  
  canvasChanged() {
    const canvas = this.egg.canvas;
    if (this.touchListener && (this.canvas !== canvas)) {
      this.canvas.removeEventListener("touchstart", this.touchListener);
      this.canvas.removeEventListener("touchend", this.touchListener);
      this.canvas.removeEventListener("touchcancel", this.touchListener);
      this.canvas.removeEventListener("touchmove", this.touchListener);
      this.touchListener = null;
    }
    if (canvas) {
      this.canvas = canvas;
      if (!this.touchListener) {
        this.touchListener = e => this.onTouch(e);
        canvas.addEventListener("touchstart", this.touchListener);
        canvas.addEventListener("touchend", this.touchListener);
        canvas.addEventListener("touchcancel", this.touchListener);
        canvas.addEventListener("touchmove", this.touchListener);
      }
    }
  }
  
  detach() {
    this._unlistenMouse();
    if (this.keyListener) {
      window.removeEventListener("keydown", this.keyListener);
      window.removeEventListener("keyup", this.keyListener);
      this.keyListener = null;
    }
    if (this.gamepadListener) {
      window.removeEventListener("gamepadconnected", this.gamepadListener);
      window.removeEventListener("gamepaddisconnected", this.gamepadListener);
      this.gamepadListener = null;
    }
    if (this.touchListener) {
      this.canvas.removeEventListener("touchstart", this.touchListener);
      this.canvas.removeEventListener("touchend", this.touchListener);
      this.canvas.removeEventListener("touchcancel", this.touchListener);
      this.canvas.removeEventListener("touchmove", this.touchListener);
      this.touchListener = null;
    }
    if (this.accel) {
      if (this.accelListener) {
        this.accel.removeEventListener("reading", this.accelListener);
        this.accelListener = null;
      }
      this.accel.stop();
    }
  }
  
  update() {
    this._updateGamepads();
  }
  
  // (v) is an array of 2..5 integers; see egg_input.h
  pushEvent(v) {
    if (!(this.evtmask & (1 << v[0]))) return;
    this.evtq.push(v);
  }
  
  reset() {
    this.evtq = [];
    const initialMask =
      (1 << Input.EGG_EVENT_JOY) |
      (1 << Input.EGG_EVENT_KEY) |
      (1 << Input.EGG_EVENT_TOUCH)|
    0;
    if (initialMask !== this.evtmask) {
      for (let i=0; i<30; i++) {
        if ((initialMask & (1 << i)) !== (this.evtmask & (1 << i))) {
          this.event_enable(i, initialMask & (1 << i));
        }
      }
    }
  }
  
  /* Touch.
   ********************************************************************/
   
  onTouch(e) {
    if (!e.changedTouches) return;
    if (!this.canvas) return;
    const bounds = this.canvas.getBoundingClientRect();
    let state;
    switch (e.type) {
      case "touchstart": state = 1; break;
      case "touchend":
      case "touchcancel": state = 0; break;
      case "touchmove": state = 2; break;
    }
    for (const touch of e.changedTouches) {
      const x = ((touch.clientX - bounds.x) * this.canvas.width) / bounds.width;
      const y = ((touch.clientY - bounds.y) * this.canvas.height) / bounds.height;
      this.pushEvent([Input.EGG_EVENT_TOUCH, this.eggSafeTouchId(touch.identifier), state, x, y]);
    }
  }
  
  // The spec doesn't constain Touch.identifier beyond saying it must be an integer.
  // For Egg, it must be a *positive* integer. I've seen zero.
  eggSafeTouchId(id) {
    return (id < 1) ? ((id & 0x7fffffff) | 0x00001000) : id;
  }
  
  /* Gamepad.
   * We will use (gamepad.index+1) as (devid) for reporting to the client.
   ******************************************************************************/
   
  _updateGamepads() {
    if (!window.navigator.getGamepads) return;
    for (const gamepad of window.navigator.getGamepads()) {
      if (!gamepad) continue;
      const local = this.gamepads[gamepad.index];
      if (!local) continue;
      
      for (let i=local.axes.length; i-->0; ) {
        const pv = local.axes[i];
        const nx = gamepad.axes[i] ? Math.floor(gamepad.axes[i] * 127) : 0;
        if (pv === nx) continue;
        local.axes[i] = nx;
        this.pushEvent([Input.EGG_EVENT_JOY, local.devid, local.axisBase + i, nx]);
        this.pushEvent([Input.EGG_EVENT_RAW, local.devid, local.axisBase + i, nx]);
      }
      
      for (let i=local.buttons.length; i-->0; ) {
        const pv = local.buttons[i];
        const nx = gamepad.buttons[i].value;
        if (pv === nx) continue;
        local.buttons[i] = nx;
        this.pushEvent([Input.EGG_EVENT_JOY, local.devid, local.buttonBase + i, nx]);
        this.pushEvent([Input.EGG_EVENT_RAW, local.devid, local.buttonBase + i, nx]);
      }
    }
  }
  
  onGamepadConnection(e) {
    switch (e.type) {
    
      case "gamepadconnected": {
          let axisBase, buttonBase;
          if (e.gamepad.mapping === "standard") {
            axisBase = 0x40;
            buttonBase = 0x80;
          } else {
            axisBase = 0x100;
            buttonBase = 0x200;
          }
          this.gamepads[e.gamepad.index] = {
            devid: e.gamepad.index + 1,
            index: e.gamepad.index,
            id: e.gamepad.id,
            axes: (e.gamepad.axes || []).map(v => v),
            buttons: (e.gamepad.buttons || []).map(v => 0),
            mapping: e.gamepad.mapping,
            axisBase,
            buttonBase,
          };
          this.pushEvent([Input.EGG_EVENT_JOY, e.gamepad.index + 1, 0, 1]);
          this.pushEvent([Input.EGG_EVENT_RAW, e.gamepad.index + 1, 0, 1]);
        } break;
        
      case "gamepaddisconnected": {
          const local = this.gamepads[e.gamepad.index];
          if (local) {
            delete this.gamepads[e.gamepad.index];
            this.pushEvent([Input.EGG_EVENT_JOY, local.devid, 0, 0]);
            this.pushEvent([Input.EGG_EVENT_RAW, local.devid, 0, 0]);
          }
        } break;
    }
  }
  
  /* Mouse.
   ********************************************************************************/
  
  _checkCursorVisibility(show) {
    const enableEvents = show;
    if (this.cursorDesired) show = !!show;
    else show = false;
    if (show !== this.cursorVisible) {
      this.cursorVisible = show;
      if (this.canvas) {
        if (show) {
          this.canvas.style.cursor = "pointer";
        } else {
          this.canvas.style.cursor = "none";
        }
      }
    }
    if (enableEvents) {
      if (!this.mouseListener) {
        this._listenMouse();
      }
    } else {
      if (this.mouseListener) {
        this._unlistenMouse();
      }
    }
  }
  
  _listenMouse() {
    if (this.mouseEventListener) return;
    this.mouseEventListener = e => this.onMouseEvent(e);
    window.addEventListener("mousewheel", this.mouseEventListener);
    window.addEventListener("mousemove", this.mouseEventListener);
    window.addEventListener("mouseup", this.mouseEventListener);
    if (this.canvas) {
      this.canvas.addEventListener("mousedown", this.mouseEventListener);
      this.canvas.addEventListener("contextmenu", this.mouseEventListener);
    }
  }
  
  _unlistenMouse() {
    if (this.mouseEventListener) {
      window.removeEventListener("mousewheel", this.mouseEventListener);
      window.removeEventListener("mousemove", this.mouseEventListener);
      window.removeEventListener("mouseup", this.mouseEventListener);
      if (this.canvas) {
        this.canvas.removeEventListener("mousedown", this.mouseEventListener);
        this.canvas.removeEventListener("contextmenu", this.mouseEventListener);
      }
      this.mouseEventListener = null;
    }
  }
  
  onMouseEvent(e) {
    if (!this.canvas) return;
    const bounds = this.canvas.getBoundingClientRect();
    const x = Math.floor(((e.x - bounds.x) * this.canvas.width) / bounds.width);
    const y = Math.floor(((e.y - bounds.y) * this.canvas.height) / bounds.height);
    switch (e.type) {
      case "mousemove": {
          if (this.mouseLocked) {
            if (e.movementX || e.movementY) {
              this.pushEvent([Input.EGG_EVENT_MMOTION, e.movementX, e.movementY]);
            }
          } else {
            if ((x === this.mouseX) && (y === this.mouseY)) return;
            this.mouseX = x;
            this.mouseY = y;
            this.pushEvent([Input.EGG_EVENT_MMOTION, x, y]);
          }
        } break;
      case "mousedown": {
          if (e.target !== this.canvas) return;
          let button;
          switch (e.button) {
            case 0: button = Input.EGG_MBUTTON_LEFT; break;
            case 1: button = Input.EGG_MBUTTON_MIDDLE; break;
            case 2: button = Input.EGG_MBUTTON_RIGHT; break;
            default: button = e.button;
          }
          if (this.mouseButtonsDown.has(button)) return;
          this.mouseButtonsDown.add(button);
          e.preventDefault();
          this.pushEvent([Input.EGG_EVENT_MBUTTON, x, y, button, 1]);
        } break;
      case "mouseup": {
          let button;
          switch (e.button) {
            case 0: button = Input.EGG_MBUTTON_LEFT; break;
            case 1: button = Input.EGG_MBUTTON_MIDDLE; break;
            case 2: button = Input.EGG_MBUTTON_RIGHT; break;
            default: button = e.button;
          }
          if (!this.mouseButtonsDown.has(button)) return;
          this.mouseButtonsDown.delete(button);
          this.pushEvent([Input.EGG_EVENT_MBUTTON, x, y, button, 0]);
        } break;
      case "contextmenu": e.preventDefault(); break;
      case "mousewheel": {
          if ((x < 0) || (y < 0) || (x >= bounds.width) || (y >= bounds.height)) return;
          let dx = e.deltaX, dy = e.deltaY;
          if (e.wheelDeltaX) dx /= Math.abs(e.wheelDeltaX);
          if (e.wheelDeltaY) dy /= Math.abs(e.wheelDeltaY);
          if (e.wheelDelta && !e.wheelDeltaX && !e.wheelDeltaY) {
            dx /= Math.abs(e.wheelDelta);
            dy /= Math.abs(e.wheelDelta);
          }
          if (e.shiftKey) { // I like Shift+Wheel to mean X instead of Y.
            let tmp = dx;
            dx = dy;
            dy = tmp;
          }
          if (dx || dy) {
            this.pushEvent([Input.EGG_EVENT_MWHEEL, x, y, dx, dy]);
          }
          //event.preventDefault(); // It's installed as passive... why is that? (Chrome Linux)
        } break;
    }
  }
  
  /* Keyboard.
   **************************************************************************/
  
  onKey(e) {
    
    // Ignore all keyboard events when Alt or Ctrl is held.
    if (e.ctrlKey || e.altKey) {
      return;
    }
    
    // TODO We might be too heavy-handed with event suppression. Bear in mind that we are listening on Window.
    
    // If we recognize the key and user wants key events, pass it on and suppress it in browser.
    if (this.evtmask & (1 << Input.EGG_EVENT_KEY)) {
      const usage = this.hidUsageByKeyCode(e.code);
      if (usage) {
        const v = (e.type === "keyup") ? 0 : e.repeat ? 2 : 1;
        this.pushEvent([Input.EGG_EVENT_KEY, usage, v]);
        e.preventDefault();
        e.stopPropagation();
      }
    }
    
    // Likewise, if user wants text and it looks like text. (but not for "keyup" of course).
    if (e.type !== "keyup") {
      if (this.evtmask & (1 << Input.EGG_EVENT_TEXT)) {
        switch (e.key) {
          case "Backspace": this.pushEvent([Input.EGG_EVENT_TEXT, 0x08]); e.preventDefault(); e.stopPropagation(); break;
          case "Tab":       this.pushEvent([Input.EGG_EVENT_TEXT, 0x09]); e.preventDefault(); e.stopPropagation(); break;
          case "Enter":     this.pushEvent([Input.EGG_EVENT_TEXT, 0x0a]); e.preventDefault(); e.stopPropagation(); break;
          case "Escape":    this.pushEvent([Input.EGG_EVENT_TEXT, 0x1b]); e.preventDefault(); e.stopPropagation(); break;
          default: if (e.key?.length === 1) {
              this.pushEvent([Input.EGG_EVENT_TEXT, e.key.charCodeAt(0)]);
              e.preventDefault();
              e.stopPropagation();
            } break;
        }
      }
    }
  }
  
  hidUsageByKeyCode(code) {
    if (!code) return 0;
  
    // "KeyA".."KeyZ" => 0x04..0x1d
    if ((code.length === 4) && code.startsWith("Key")) {
      const ch = code.charCodeAt(3);
      if ((ch >= 0x41) && (ch <= 0x5a)) return 0x00070004 + ch - 0x41;
    }
    
    // "Digit1".."Digit9" => 0x1e..0x25, some jackass put "0" on the right side... why...
    if ((code.length === 6) && code.startsWith("Digit")) {
      const ch = code.charCodeAt(5);
      if ((ch >= 0x31) && (ch <= 0x39)) return 0x0007001e + ch - 0x31;
      if (ch === 0x30) return 0x00070027; // zero
    }
    
    // "F1".."F12" => 0x3a..0x45
    // "F13".."F24" => 0x68..0x73
    if (((code.length === 2) || (code.length === 3)) && (code[0] === 'F')) {
      const v = +code.substring(1);
      if ((v >= 1) && (v <= 12)) return 0x0007003a + v - 1;
      if ((v >= 13) && (v <= 24)) return 0x00070068 + v - 13;
    }
    
    // "Numpad1".."Numpad9" => 0x59..0x61, again with zero on top because Jesus hates me.
    if ((code.length === 7) && code.startsWith("Numpad")) {
      const v = +code[7];
      if ((v >= 1) && (v <= 9)) return 0x00070059 + v - 1;
      if (v === 0) return 0x00070062;
    }
    
    // And finally a not-too-crazy set of one-off names.
    switch (code) {
      case "Enter":          return 0x00070028;
      case "Escape":         return 0x00070029;
      case "Backspace":      return 0x0007002a;
      case "Tab":            return 0x0007002b;
      case "Space":          return 0x0007002c;
      case "Minus":          return 0x0007002d;
      case "Equal":          return 0x0007002e;
      case "BracketLeft":    return 0x0007002f;
      case "BracketRight":   return 0x00070039;
      case "Backslash":      return 0x00070031;
      case "Semicolon":      return 0x00070033;
      case "Quote":          return 0x00070034;
      case "Backquote":      return 0x00070035;
      case "Comma":          return 0x00070036;
      case "Period":         return 0x00070037;
      case "Slash":          return 0x00070038;
      case "CapsLock":       return 0x00070039;
      case "Pause":          return 0x00070048;
      case "Insert":         return 0x00070049;
      case "Home":           return 0x0007004a;
      case "PageUp":         return 0x0007004b;
      case "Delete":         return 0x0007004c;
      case "PageDown":       return 0x0007004e;
      case "ArrowRight":     return 0x0007004f;
      case "ArrowLeft":      return 0x00070050;
      case "ArrowDown":      return 0x00070051;
      case "ArrowUp":        return 0x00070052;
      case "NumLock":        return 0x00070053;
      case "NumpadDivide":   return 0x00070054;
      case "NumpadMultiply": return 0x00070055;
      case "NumpadSubtract": return 0x00070056;
      case "NumpadAdd":      return 0x00070057;
      case "NumpadEnter":    return 0x00070058;
      case "NumpadDecimal":  return 0x00070063;
      case "ContextMenu":    return 0x00070076;
      case "ShiftLeft":      return 0x000700e1;
      case "ShiftRight":     return 0x000700e5;
      case "ControlLeft":    return 0x000700e0;
      case "ControlRight":   return 0x000700e4;
      case "AltLeft":        return 0x000700e2;
      case "AltRight":       return 0x000700e6;
    }
    return 0;
  }
  
  /* Accelerometer.
   **************************************************************************/
   
  accelerometerEnable() {
    this._accelerometerEnableInternal().then(() => {
      if (!this.accelListener) {
        this.accelListener = () => this.onAccelerometer();
        this.accel.addEventListener("reading", this.accelListener);
      }
      this.accel.start();
    }).catch(() => {});
  }
  
  _accelerometerEnableInternal() {
    if (this.accel) return Promise.resolve();
    if (!window.navigator.permissions) return Promise.reject();
    return window.navigator.permissions.query({ name: "accelerometer" }).then(result => {
      if (result.state === "denied") throw null;
      if (!this.accel) {
        this.accel = new Accelerometer({ referenceFrame: "device", frequency: 60 });
      }
    });
  }
  
  accelerometerDisable() {
    if (!this.accel) return;
    if (this.accelListener) {
      this.accel.removeEventListener("reading", this.accelListener);
      this.accelListener = null;
    }
    this.accel.stop();
  }
  
  onAccelerometer() {
    if (!this.accel) return;
    const x = ~~(this.accel.x * 65536.0);
    const y = ~~(this.accel.y * 65536.0);
    const z = ~~(this.accel.z * 65536.0);
    this.pushEvent([Input.EGG_EVENT_ACCEL, x, y, z]);
  }
  
  /*--------------------------- Public API entry points -----------------------------------*/
  
  egg_event_get(v, a) {
    const eventSizeWords = 5;//TODO Can we assert that this is sizeof(union egg_event)/sizeof(int)?
    const cpc = Math.min(a, this.evtq.length);
    if (cpc < 1) return 0;
    let dst = this.egg.exec.mem32;
    let dstp = v >> 2;
    for (let i=0; i<cpc; i++) {
      const e = this.evtq[i];
      for (let j=0; j<eventSizeWords; j++) {
        dst[dstp++] = e[j];
      }
    }
    this.evtq.splice(0, cpc);
    return cpc;
  }
  
  egg_event_enable(type, enable) {
    if (!type) return 0;
    const bit = 1 << type;
    if (enable) {
      if (this.evtmask & bit) return 1;
      this.evtmask |= bit;
    } else {
      if (!(this.evtmask & bit)) return 0;
      this.evtmask &= ~bit;
    }
    switch (type) {
      case Input.EGG_EVENT_RAW: break;
      case Input.EGG_EVENT_JOY: {
          if (!this.gamepadSupported) return 0;
        } break;
      case Input.EGG_EVENT_KEY:
      case Input.EGG_EVENT_TEXT: {
          if (!this.keyboardSupported) return 0;
        } break;
      case Input.EGG_EVENT_MMOTION:
      case Input.EGG_EVENT_MBUTTON:
      case Input.EGG_EVENT_MWHEEL: {
          if (!this.mouseSupported) return 0;
          const mouseEvents = (1 << Input.EGG_EVENT_MMOTION) | (1 << Input.EGG_EVENT_MBUTTON) | (1 << Input.EGG_EVENT_MWHEEL);
          this._checkCursorVisibility(this.evtmask & mouseEvents);
        } break;
      case Input.EGG_EVENT_TOUCH: {
          if (!this.touchSupported) return 0;
        } break;
      case Input.EGG_EVENT_ACCEL: {
          if (!this.accelerometerSupported) return 0;
          if (enable) {
            this.accelerometerEnable();
          } else {
            this.accelerometerDisable();
          }
        } break;
    }
    return enable ? 1 : 0;
  }
  
  egg_show_cursor(show) {
    this.cursorDesired = !!show;
    const mouseEvents = (1 << Input.EGG_EVENT_MMOTION) | (1 << Input.EGG_EVENT_MBUTTON) | (1 << Input.EGG_EVENT_MWHEEL);
    this._checkCursorVisibility(this.evtmask & mouseEvents);
  }
  
  egg_lock_cursor(lock) {
    if (!this.canvas || !this.canvas.requestPointerLock) return 0;
    if (lock) {
      if (this.mouseLocked) return 1;
      this.mouseLocked = true;
      this.canvas.requestPointerLock(/*{
        unadjustedMovement: true, // Not supported in Chrome/Linux, and the whole request gets rejected for it.
      }*/).then(rsp => {
      }).catch(e => {
        this.mouseLocked = false;
      });
    } else if (this.mouseLocked) {
      this.mouseLocked = false;
      document.exitPointerLock();
    }
    return 1;
  }
  
  egg_joystick_devid_by_index(p) {
    if (p < 0) return 0;
    for (let i=0; i<this.gamepads.length; i++) {
      if (!this.gamepads[i]) continue;
      if (!p--) return i + 1;
    }
    return 0;
  }
  
  egg_joystick_get_ids(vidp, pidp, verp, devid) {
    const local = this.gamepads[devid - 1];
    if (!local || (local.devid !== devid)) return;
    // Linux Chrome: Microsoft X-Box 360 pad (STANDARD GAMEPAD Vendor: 045e Product: 028e)
    // Not at all sure how standard that formatting is, but we don't have much else to go on...
    let vid=0, pid=0, version=0;
    let match;
    if (match = local.id.match(/Vendor: ([0-9a-fA-F]{4})/)) {
      vid = parseInt(match[1], 16);
    }
    if (match = local.id.match(/Product: ([0-9a-fA-F]{4})/)) {
      pid = parseInt(match[1], 16);
    }
    if (match = local.id.match(/Version: ([0-9a-fA-F]{4})/)) {
      // This one doesn't exist for me. And not sure whether they'd break it out as MAJOR.MINOR.REVISION.
      // 0xf000=MAJOR, 0x0f00=MINOR, 0x00ff=REVISION
      version = parseInt(match[1], 16);
    }
    if (vidp) this.egg.exec.mem32[vidp >> 2] = vid;
    if (pidp) this.egg.exec.mem32[pidp >> 2] = pid;
    if (verp) this.egg.exec.mem32[verp >> 2] = version;
  }
  
  egg_joystick_get_name(dst, dsta, devid) {
    const local = this.gamepads[devid - 1];
    if (!local || (local.devid !== devid)) return 0;
    const name = local.id.split('(')[0].trim();
    return name || local.id;
    return this.egg.exec.safeWrite(dst, dsta, name);
  }
  
  egg_joystick_for_each_button(devid, cb, ctx) {
    // int (*cb)(int btnid,int usage,int lo,int hi,int value,void *userdata)
    if (!(cb = this.egg.exec.fntab.get(cb))) return 0;

    const local = this.gamepads[devid - 1];
    if (!local || (local.devid !== devid)) return null;
    
    for (let i=0; i<local.axes.length; i++) {
      let hidusage = 0;
      if (local.mapping === "standard") {
        hidusage = Input.STANDARD_AXIS_USAGE[i] || 0;
      }
      const err = cb(local.axisBase + i, hidusage, -128, 127, 0, ctx);
      if (err) return err;
    }
    
    for (let i=0; i<local.buttons.length; i++) {
      let hidusage = 0x00090000 + i;
      if (local.mapping === "standard") {
        const alt = Input.STANDARD_BUTTON_USAGE[i];
        if (alt) hidusage = alt;
      }
      const err = cb(local.buttonBase + i, hidusage, 0, 1, 0, ctx);
    }
    
    return 0;
  }
}

Input.EGG_EVENT_JOY = 1;
Input.EGG_EVENT_KEY = 2;
Input.EGG_EVENT_TEXT = 3;
Input.EGG_EVENT_MMOTION = 4;
Input.EGG_EVENT_MBUTTON = 5;
Input.EGG_EVENT_MWHEEL = 6;
Input.EGG_EVENT_TOUCH = 7;
Input.EGG_EVENT_ACCEL = 8;
Input.EGG_EVENT_RAW = 9;

Input.EGG_JOYBTN_LX    = 0x40;
Input.EGG_JOYBTN_LY    = 0x41;
Input.EGG_JOYBTN_RX    = 0x42;
Input.EGG_JOYBTN_RY    = 0x43;
Input.EGG_JOYBTN_SOUTH = 0x80;
Input.EGG_JOYBTN_EAST  = 0x81;
Input.EGG_JOYBTN_WEST  = 0x82;
Input.EGG_JOYBTN_NORTH = 0x83;
Input.EGG_JOYBTN_L1    = 0x84;
Input.EGG_JOYBTN_R1    = 0x85;
Input.EGG_JOYBTN_L2    = 0x86;
Input.EGG_JOYBTN_R2    = 0x87;
Input.EGG_JOYBTN_AUX2  = 0x88;
Input.EGG_JOYBTN_AUX1  = 0x89;
Input.EGG_JOYBTN_LP    = 0x8a;
Input.EGG_JOYBTN_RP    = 0x8b;
Input.EGG_JOYBTN_UP    = 0x8c;
Input.EGG_JOYBTN_DOWN  = 0x8d;
Input.EGG_JOYBTN_LEFT  = 0x8e;
Input.EGG_JOYBTN_RIGHT = 0x8f;
Input.EGG_JOYBTN_AUX3  = 0x90;

Input.EGG_MBUTTON_LEFT = 1;
Input.EGG_MBUTTON_RIGHT = 2;
Input.EGG_MBUTTON_MIDDLE = 3;

Input.EGG_TOUCH_END = 0;
Input.EGG_TOUCH_BEGIN = 1;
Input.EGG_TOUCH_MOVE = 2;

Input.STANDARD_AXIS_USAGE = [
  0x00010030, // lx
  0x00010031, // ly
  0x00010033, // rx
  0x00010034, // ry
];

Input.STANDARD_BUTTON_USAGE = [
  0x00050037, // south
  0x00050037, // east
  0x00050037, // west
  0x00050037, // north
  0x00050039, // l1
  0x00050039, // r1
  0x00050039, // l2
  0x00050039, // r2
  0x0001003e, // select
  0x0001003d, // start
  0x00090000, // lp
  0x00090001, // rp
  0x00010090, // dup
  0x00010091, // ddown
  0x00010093, // dleft
  0x00010092, // dright
  0x00010085, // heart -- "System Main Menu", debatable.
];
// Do not edit! Generated from src/opt/synth/synth_builtin.c.
const Instruments = [
{"mode":"fmrel","fmRate":2,"fmRangeScale":4,"fmRangeEnv":36808,"levelTiny":132},
0,
{"mode":"fmrel","fmRate":2,"fmRangeScale":4,"fmRangeEnv":36808,"levelTiny":132},
{"mode":"fmrel","fmRate":1.5,"fmRangeScale":4,"fmRangeEnv":65410,"levelTiny":139},
{"mode":"rock","wave":[0,0.5019607843137255,0.7529411764705882,0.25098039215686274,0.12549019607843137,0.03137254901960784],"mix":3968,"levelTiny":139},
{"mode":"fmabs","fmRate":128,"fmRangeScale":0.0625,"fmRangeEnv":3888,"levelTiny":84},
{"mode":"fmrel","fmRate":5,"fmRangeScale":5,"fmRangeEnv":65520,"levelTiny":5},
{"mode":"fmrel","fmRate":4,"fmRangeScale":5,"fmRangeEnv":36608,"levelTiny":69},
{"mode":"fmrel","fmRate":7.625,"fmRangeScale":8.4375,"fmRangeEnv":63610,"levelTiny":6},
{"mode":"fmrel","fmRate":3,"fmRangeScale":4,"fmRangeEnv":65524,"levelTiny":3},
{"mode":"fmrel","fmRate":6.125,"fmRangeScale":8,"fmRangeEnv":65412,"levelTiny":5},
{"mode":"fmrel","fmRate":4,"fmRangeScale":4,"fmRangeEnv":4084,"levelTiny":13},
{"mode":"fmrel","fmRate":8,"fmRangeScale":3,"fmRangeEnv":65524,"levelTiny":5},
null,
{"mode":"fmrel","fmRate":3.5,"fmRangeScale":6.4375,"fmRangeEnv":63743,"levelTiny":14},
{"mode":"fmrel","fmRate":6,"fmRangeScale":7,"fmRangeEnv":36740,"levelTiny":6},
{"mode":"rock","wave":[0,1,0.00784313725490196,0.3333333333333333,0.00392156862745098,0.2,0,0.06666666666666667],"mix":12172,"levelTiny":213},
{"mode":"rock","wave":[0,0,0.7529411764705882,0.01568627450980392,0.25098039215686274,0.00392156862745098],"mix":49908,"levelTiny":69},
{"mode":"rock","wave":[0,0.7529411764705882,0,0.3764705882352941,0,0.18823529411764706,0,0.09411764705882353],"mix":3972,"levelTiny":148},
{"mode":"rock","wave":[0,0.7529411764705882,0.6274509803921569,0.3764705882352941,0,0.18823529411764706,0,0.09411764705882353],"mix":65520,"levelTiny":158},
{"mode":"rock","wave":[0,0,0.48627450980392156,0.6470588235294118,0.5019607843137255,0.2,0.3764705882352941,0.06666666666666667,0],"mix":4080,"levelTiny":147},
16,
16,
16,
{"mode":"fmrel","fmRate":2,"fmRangeScale":1,"fmRangeEnv":20416,"levelTiny":5},
{"mode":"fx","fmRangeEnv":3968,"fmRangeLfo":0,"fmRangeLfoDepth":0,"fmRate":6,"fmRangeScale":7.5,"detuneRate":4,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.06274509803921569,"levelTiny":68},
{"mode":"fx","fmRangeEnv":4095,"fmRangeLfo":1,"fmRangeLfoDepth":0.5,"fmRate":2,"fmRangeScale":4,"detuneRate":4,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":0,"delayDepth":0,"levelTiny":68},
{"mode":"fx","fmRangeEnv":32644,"fmRangeLfo":2,"fmRangeLfoDepth":1,"fmRate":2,"fmRangeScale":4,"detuneRate":1,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":0.5,"delayDepth":0.25098039215686274,"levelTiny":76},
{"mode":"fx","fmRangeEnv":4080,"fmRangeLfo":2,"fmRangeLfoDepth":2,"fmRate":2,"fmRangeScale":4,"detuneRate":1,"detuneDepth":0.06274509803921569,"overdrive":0.06274509803921569,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":68},
{"mode":"fx","fmRangeEnv":65408,"fmRangeLfo":4,"fmRate":2,"fmRangeScale":3,"levelTiny":76,"detuneRate":4,"detuneDepth":0.00784313725490196,"overdrive":0.3764705882352941,"delayRate":1,"delayDepth":0.12549019607843137},
{"mode":"fx","fmRangeEnv":65348,"fmRangeLfo":2,"fmRangeLfoDepth":0.5,"fmRate":0.5,"fmRangeScale":3,"detuneRate":1,"detuneDepth":0.06274509803921569,"overdrive":0.8784313725490196,"delayRate":1,"delayDepth":0.06274509803921569,"levelTiny":93},
{"mode":"fx","fmRangeEnv":4080,"fmRangeLfo":0,"fmRangeLfoDepth":0,"fmRate":7.4375,"fmRangeScale":8,"detuneRate":1,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.06274509803921569,"levelTiny":93},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":4,"fmRangeEnv":63624,"levelTiny":221},
{"mode":"fx","fmRangeEnv":36804,"fmRangeLfo":2,"fmRangeLfoDepth":0.25,"fmRate":0.5,"fmRangeScale":2,"detuneRate":0,"detuneDepth":0,"overdrive":0,"delayRate":0,"delayDepth":0,"levelTiny":67},
{"mode":"wave","wave":[0,0.7529411764705882,0.7529411764705882,0.18823529411764706,0,0.06274509803921569,0.5019607843137255,0.25098039215686274,0.12549019607843137],"levelTiny":75},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":2,"fmRangeEnv":20352,"levelTiny":156},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":2.5,"fmRangeEnv":28513,"levelTiny":75},
{"mode":"rock","wave":[0,0.25098039215686274,1,0.7529411764705882,0.5019607843137255,0.25098039215686274,0.06274509803921569,0.03137254901960784,0.00784313725490196],"mix":3904,"levelTiny":84},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":3,"fmRangeEnv":20418,"levelTiny":82},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":5,"fmRangeEnv":36848,"levelTiny":76},
{"mode":"rock","wave":[0,0.12549019607843137,0.7529411764705882,0.4392156862745098,0.34509803921568627,0.25098039215686274,0.12549019607843137,0.03137254901960784],"mix":36800,"levelTiny":221},
{"mode":"rock","wave":[0,1,0.5019607843137255,0.3333333333333333,0.25098039215686274,0.2,0.12549019607843137,0.03137254901960784],"mix":36800,"levelTiny":221},
{"mode":"rock","wave":[0,0.25098039215686274,1,0.5019607843137255,0.3333333333333333,0.25098039215686274,0.2,0.12549019607843137,0.03137254901960784],"mix":36800,"levelTiny":220},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":4,"fmRangeEnv":63624,"levelTiny":221},
{"mode":"fx","fmRangeEnv":4036,"fmRangeLfo":0.5,"fmRangeLfoDepth":0.125,"fmRate":1,"fmRangeScale":2,"detuneRate":0,"detuneDepth":0,"overdrive":0,"delayRate":0,"delayDepth":0,"levelTiny":198},
{"mode":"fx","fmRangeEnv":4036,"fmRangeLfo":0.5,"fmRangeLfoDepth":0.5,"fmRate":1,"fmRangeScale":3,"detuneRate":0.25,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.06274509803921569,"levelTiny":5},
{"mode":"fx","fmRangeEnv":36804,"fmRangeLfo":0,"fmRangeLfoDepth":0,"fmRate":3,"fmRangeScale":3,"detuneRate":0.25,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":6},
{"mode":"sub","subQ1":83.33333333333333,"subQ2":96.66666666666667,"subGain":150,"levelTiny":11},
{"mode":"fx","fmRangeEnv":36804,"fmRangeLfo":4,"fmRangeLfoDepth":0.5,"fmRate":1.5,"fmRangeScale":2,"detuneRate":1,"detuneDepth":0.03137254901960784,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":213},
48,
{"mode":"fx","fmRangeEnv":53220,"fmRangeLfo":4,"fmRangeLfoDepth":0.5,"fmRate":0.5,"fmRangeScale":5,"detuneRate":1,"detuneDepth":0.03137254901960784,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":213},
48,
48,
48,
48,
48,
{"mode":"rock","wave":[0,0.12549019607843137,0.7529411764705882,0.3764705882352941,0.3137254901960784,0.25098039215686274,0.06274509803921569,0.03137254901960784,0.00784313725490196],"mix":61684,"levelTiny":219},
56,
56,
56,
56,
56,
56,
56,
{"mode":"fmrel","fmRate":4,"fmRangeScale":3,"fmRangeEnv":20418,"levelTiny":148},
64,
64,
64,
64,
64,
64,
{"mode":"rock","wave":[0,0.12549019607843137,0.5490196078431373,0.8784313725490196,0,0.45098039215686275,0,0.19215686274509805,0],"mix":255,"levelTiny":76},
"blip",
72,
{"mode":"wave","wave":[0,0.5019607843137255,0.06274509803921569,0.9607843137254902,0,0.2,0,0.06666666666666667,0.01568627450980392],"levelTiny":163},
72,
{"mode":"sub","subQ1":91.66666666666667,"subQ2":95,"subGain":45,"levelTiny":140},
{"mode":"fmrel","fmRate":4.1875,"fmRangeScale":1.5,"fmRangeEnv":3888,"levelTiny":84},
72,
{"mode":"fmrel","fmRate":2,"fmRangeScale":2.5,"fmRangeEnv":36608,"levelTiny":213},
{"mode":"wave","wave":[0,1,0,0.3333333333333333,0,0.2,0,0.06274509803921569],"levelTiny":139},
{"mode":"wave","wave":[0,1,0.5019607843137255,0.3333333333333333,0.25098039215686274,0.2,0.12549019607843137,0.06274509803921569,0.03137254901960784],"levelTiny":147},
{"mode":"rock","wave":[0,0,1,0.12549019607843137],"mix":3968,"levelTiny":141},
"blip",
{"mode":"rock","wave":[0,0,1,0.25098039215686274,0.12549019607843137,0.06274509803921569,0.03137254901960784],"mix":255,"levelTiny":140},
{"mode":"fmrel","fmRate":2.5,"fmRangeScale":2,"fmRangeEnv":63684,"levelTiny":220},
{"mode":"fmrel","fmRate":1.5,"fmRangeScale":4,"fmRangeEnv":36804,"levelTiny":156},
{"mode":"rock","wave":[0,0,0,0,1],"mix":52992,"levelTiny":148},
{"mode":"fx","fmRangeEnv":65535,"fmRangeLfo":8,"fmRangeLfoDepth":2,"fmRate":1,"fmRangeScale":1,"detuneRate":1,"detuneDepth":0.09411764705882353,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":199},
{"mode":"wave","wave":[0,1,0.06274509803921569,0.03137254901960784,0.00784313725490196],"levelTiny":195},
{"mode":"fx","fmRangeEnv":53056,"fmRangeLfo":4,"fmRangeLfoDepth":1,"fmRate":1,"fmRangeScale":4,"detuneRate":4,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":213},
{"mode":"sub","subQ1":86.66666666666667,"subQ2":91.66666666666667,"subGain":40,"levelTiny":220},
{"mode":"sub","subQ1":93.33333333333333,"subQ2":86.66666666666667,"subGain":30,"levelTiny":213},
{"mode":"fx","fmRangeEnv":65520,"fmRangeLfo":4,"fmRangeLfoDepth":0.25,"fmRate":7.375,"fmRangeScale":3,"detuneRate":8,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.03137254901960784,"levelTiny":214},
{"mode":"rock","wave":[0,0,1,0.12549019607843137,0.06274509803921569,0.03137254901960784,0.01568627450980392,0.00784313725490196,0.00392156862745098],"mix":1264,"levelTiny":222},
{"mode":"fx","fmRangeEnv":65535,"fmRangeLfo":4,"fmRangeLfoDepth":2,"fmRate":4,"fmRangeScale":3,"detuneRate":4,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.03137254901960784,"levelTiny":214},
{"mode":"fx","fmRangeEnv":36848,"fmRangeLfo":8,"fmRangeLfoDepth":8,"fmRate":3.5,"fmRangeScale":6,"detuneRate":0,"detuneDepth":0,"overdrive":0,"delayRate":0.5,"delayDepth":0.6274509803921569,"levelTiny":19},
96,
96,
96,
96,
{"mode":"fx","fmRangeEnv":36848,"fmRangeLfo":4,"fmRangeLfoDepth":4,"fmRate":0.5,"fmRangeScale":4,"detuneRate":0,"detuneDepth":0,"overdrive":0.25098039215686274,"delayRate":1,"delayDepth":0.5019607843137255,"levelTiny":83},
{"mode":"fx","fmRangeEnv":61695,"fmRangeLfo":4,"fmRangeLfoDepth":8,"fmRate":2,"fmRangeScale":1,"detuneRate":1,"detuneDepth":0.12549019607843137,"overdrive":0,"delayRate":0.5,"delayDepth":0.6274509803921569,"levelTiny":83},
{"mode":"fx","fmRangeEnv":4095,"fmRangeLfo":8,"fmRangeLfoDepth":1.5,"fmRate":2,"fmRangeScale":6,"detuneRate":1,"detuneDepth":0.03137254901960784,"overdrive":0.03137254901960784,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":205},
"blip",
104,
104,
104,
104,
104,
104,
104,
{"mode":"fmrel","fmRate":9,"fmRangeScale":10,"fmRangeEnv":65423,"levelTiny":6},
{"mode":"fmrel","fmRate":5.4375,"fmRangeScale":4,"fmRangeEnv":65535,"levelTiny":5},
{"mode":"fmrel","fmRate":5.5,"fmRangeScale":4,"fmRangeEnv":61695,"levelTiny":13},
{"mode":"fmrel","fmRate":1.5,"fmRangeScale":2,"fmRangeEnv":4095,"levelTiny":2},
{"mode":"fmrel","fmRate":0.25,"fmRangeScale":3,"fmRangeEnv":61695,"levelTiny":13},
{"mode":"fmrel","fmRate":1.5,"fmRangeScale":3.5,"fmRangeEnv":63728,"levelTiny":11},
{"mode":"fx","fmRangeLfo":0.625,"fmRangeLfoDepth":2,"fmRate":0.5,"fmRangeScale":2,"fmRangeEnv":65408,"detuneRate":0.5,"detuneDepth":0.01568627450980392,"levelTiny":3},
112,
{"mode":"fmrel","fmRate":5.5,"fmRangeScale":10,"fmRangeEnv":63631,"levelTiny":28},
{"mode":"sub","subQ1":86.66666666666667,"subQ2":86.66666666666667,"subGain":30,"levelTiny":91},
{"mode":"sub","subQ1":33.33333333333333,"subQ2":66.66666666666666,"subGain":5,"levelTiny":223},
{"mode":"fmabs","fmRate":128,"fmRangeScale":1.125,"fmRangeEnv":62464,"levelTiny":77},
{"mode":"fmabs","fmRate":256,"fmRangeScale":0.5,"fmRangeEnv":53184,"levelTiny":27},
{"mode":"fmabs","fmRate":128,"fmRangeScale":1,"fmRangeEnv":4080,"levelTiny":141},
"blip",
null,
];
/* ImageDecoder.js
 * Would be awesome if we could use browser facilities for this but alas
 * that is not possible because we have to be synchronous.
 * We could add image formats. But I think we'll advise devs to use PNG exclusively.
 */
 

 
class ImageDecoder {
  constructor() {
  }
  
  /* Returns {w,h,stride,fmt} or throws.
   * We reject images larger than 32767 on either axis, even if otherwise valid.
   */
  decodeHeader(src) {
    if (this.isPng(src)) return this.decodeHeaderPng(src);
    throw new Error(`Image format unknown`);
  }
  
  /* Returns {w,h,stride,fmt,v:Uint8Array} or throws.
   * We reject images larger than 32767 on either axis, even if otherwise valid.
   */
  decode(src) {
    if (this.isPng(src)) return this.decodePng(src);
    throw new Error(`Image format unknown`);
  }
  
  /* PNG.
   ***************************************************************************/
   
  isPng(src) {
    return (
      (src.length >= 8) &&
      (src[0] === 0x89) &&
      (src[1] === 0x50) &&
      (src[2] === 0x4e) &&
      (src[3] === 0x47) &&
      (src[4] === 0x0d) &&
      (src[5] === 0x0a) &&
      (src[6] === 0x1a) &&
      (src[7] === 0x0a)
    );
  }
   
  decodeHeaderPng(src) {
    // We require IHDR to be the first chunk.
    // The spec does say that, but I've seen violations before.
    if (src.length < 26) throw new Error("Invalid PNG");
    const w = (src[16] << 24) | (src[17] << 16) | (src[18] << 8) | src[19];
    const h = (src[20] << 24) | (src[21] << 16) | (src[22] << 8) | src[23];
    if ((w < 1) || (h < 1) || (w > 0x7fff) || (h > 0x7fff)) throw new Error("Invalid PNG");
    let depth = src[24];
    const colortype = src[25];
    switch (colortype) {
      case 0: break;
      case 2: depth *= 3; break;
      case 3: break;
      case 4: depth *= 2; break;
      case 6: depth *= 4; break;
      default: throw new Error("Invalid PNG");
    }
    let fmt;
    switch (depth) {
      case 1: fmt = 3; break;
      case 8: fmt = 2; break;
      case 32: fmt = 1; break;
      // Anything that isn't 1, 8, or 32 bits/pixel, we coerce to 32 at decode.
      case 2: case 4: case 16: case 24: case 48: case 64: fmt = 1; depth = 32; break;
      default: throw new Error("Invalid PNG");
    }
    const stride = (w * depth + 7) >> 3;
    return {w, h, stride, fmt};
  }
  
  decodePng(src) {
    const chunks = this.dechunkPng(src);
    const ihdr = this.decodePngIhdr(chunks.ihdr);
    let fmt;
    switch (ihdr.pixelsize) {
      case 32: fmt = 1; break;
      case 8: fmt = 2; break;
      case 1: fmt = 3; break;
      default: fmt = 0; // force RGBA after preliminary decode
    }
    const filtered = new Zlib.Inflate(chunks.idat).decompress();
    let dst = new Uint8Array(ihdr.stride * ihdr.h);
    this.unfilterPng(dst, filtered, ihdr.stride, ihdr.xstride);
    if (!fmt) {
      const rgbastride = ihdr.w << 2;
      const rgba = new Uint8Array(rgbastride * ihdr.h);
      this.forceRgba(rgba, rgbastride, dst, ihdr, chunks.plte);
      dst = rgba;
      ihdr.stride = rgbastride;
      fmt = 1;
    }
    return {
      w: ihdr.w,
      h: ihdr.h,
      stride: ihdr.stride,
      fmt,
      v: dst,
    };
  }
  
  dechunkPng(src) {
    const chunks = {};
    for (let srcp=8; srcp<src.length; ) {
      const len = (src[srcp] << 24) | (src[srcp+1] << 16) | (src[srcp+2] << 8) | src[srcp+3];
      srcp += 4;
      const cid = (src[srcp] << 24) | (src[srcp+1] << 16) | (src[srcp+2] << 8) | src[srcp+3];
      srcp += 4;
      switch (cid) {
        case 0x49484452: chunks.ihdr = src.slice(srcp, srcp + len); break;
        case 0x504c5445: chunks.plte = src.slice(srcp, srcp + len); break;
        case 0x49444154: { // IDAT
            if (chunks.idat) {
              const nv = new Uint8Array(chunks.idat.length + len);
              nv.set(chunks.idat);
              const dstview = new Uint8Array(nv.buffer, chunks.idat.length, len);
              dstview.set(src.slice(srcp, srcp + len));
              chunks.idat = nv;
            } else {
              chunks.idat = src.slice(srcp, srcp + len);
            }
          } break;
      }
      srcp += len;
      srcp += 4;
    }
    return chunks;
  }
  
  decodePngIhdr(src) {
    if (!src || (src.length < 13)) throw new Error("Invalid PNG");
    const w = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
    const h = (src[4] << 24) | (src[5] << 16) | (src[6] << 8) | src[7];
    if ((w < 1) || (h < 1) || (w > 0x7fff) || (h > 0x7fff)) throw new Error("Invalid PNG");
    const depth = src[8];
    const colortype = src[9];
    if (src[10] || src[11] || src[12]) {
      // We're not supporting interlaced PNG. Compression and filter, there's only one defined for each.
      throw new Error(`Unsupported PNG compression, filter, or interlace (${src[10]}, ${src[11]}, ${src[12]}`);
    }
    let pixelsize = depth;
    switch (colortype) {
      case 0: break;
      case 2: pixelsize *= 3; break;
      case 3: break;
      case 4: pixelsize *= 2; break;
      case 6: pixelsize *= 4; break;
      default: throw new Error("Invalid PNG");
    }
    const xstride = Math.max(1, pixelsize >> 3);
    const stride = (pixelsize * w + 7) >> 3;
    return { w, h, stride, depth, colortype, pixelsize, xstride };
  }
  
  unfilterPng(dst, src, dststride, xstride) {
    const srcstride = 1 + dststride;
    let dstp=0, srcp=0, dstppv=0;
    const paeth = (a, b, c) => {
      const p = a + b - c;
      const pa = Math.abs(p - a);
      const pb = Math.abs(p - b);
      const pc = Math.abs(p - c);
      if ((pa <= pb) && (pa <= pc)) return a;
      if (pb <= pc) return b;
      return c;
    };
    while (dstp < dst.length) {
      const filter = src[srcp++];
      if (dstp) dstppv = dstp - dststride;
      switch (filter) {
        case 0: {
            for (let i=dststride; i-->0; dstp++, srcp++) dst[dstp] = src[srcp];
          } break;
        case 1: {
            let i=0;
            for (; i<xstride; i++, dstp++, srcp++) dst[dstp] = src[srcp];
            for (; i<dststride; i++, dstp++, srcp++) dst[dstp] = src[srcp] + dst[dstp-xstride];
          } break;
        case 2: {
            if (dstp) {
              for (let i=dststride; i-->0; dstp++, dstppv++, srcp++) dst[dstp] = src[srcp] + dst[dstppv];
            } else {
              for (let i=dststride; i-->0; dstp++, srcp++) dst[dstp] = src[srcp];
            }
          } break;
        case 3: {
            let i=0;
            if (dstp) {
              for (; i<xstride; i++, dstp++, srcp++, dstppv++) dst[dstp] = src[srcp] + (dst[dstppv] >> 1);
              for (; i<dststride; i++, dstp++, srcp++, dstppv++) dst[dstp] = src[srcp] + ((dst[dstp-xstride] + dst[dstppv]) >> 1);
            } else {
              for (; i<xstride; i++, dstp++, srcp++) dst[dstp] = src[srcp];
              for (; i<dststride; i++, dstp++, srcp++) dst[dstp] = src[srcp] + (dst[dstp-xstride] >> 1);
            }
          } break;
        case 4: {
            let i=0;
            if (dstp) {
              for (; i<xstride; i++, dstp++, srcp++, dstppv++) dst[dstp] = src[srcp] + dst[dstppv];
              for (; i<dststride; i++, dstp++, srcp++, dstppv++) dst[dstp] = src[srcp] + paeth(dst[dstp-xstride], dst[dstppv], dst[dstppv-xstride]);
            } else { // PAETH is exactly SUB on the first row, but it is legal.
              for (; i<xstride; i++, dstp++, srcp++) dst[dstp] = src[srcp];
              for (; i<dststride; i++, dstp++, srcp++) dst[dstp] = src[srcp] + dst[dstp-xstride];
            }
          } break;
      }
    }
  }
  
  forceRgba(dst, dststride, src, ihdr, plte) {
    for (
      let dstrowp=0, yi=ihdr.h, srciter=this.iteratePng(src, ihdr, plte);
      yi-->0;
      dstrowp+=dststride
    ) {
      for (let dstp=dstrowp, xi=ihdr.w; xi-->0; ) {
        const rgba = srciter();
        dst[dstp++] = rgba >> 24;
        dst[dstp++] = rgba >> 16;
        dst[dstp++] = rgba >> 8;
        dst[dstp++] = rgba;
      }
    }
  }
  
  // Returns a function that returns every pixel LRTB as 32-bit big-endian RGBA.
  // TODO We're not accepting tRNS chunks. Should we?
  iteratePng(src, ihdr, plte) {
    let rowp=0, p=0, xi=ihdr.w, yi=ihdr.h, mask=0x80, shift;
    
    if (plte && (ihdr.colortype === 3)) { // INDEX
      switch (ihdr.depth) {
        case 1: return () => {
            if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; mask = 0x80; } xi--;
            let ix = (src[p] & mask) ? 1 : 0;
            ix *= 3;
            if (mask === 1) { mask = 0x80; p++; }
            else mask >>= 1;
            return (plte[ix] << 24) | (plte[ix+1] << 16) | (plte[ix+2] << 8) | 0xff;
          };
        case 2: shift = 6; return () => {
            if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; shift = 6; } xi--;
            let ix = (src[p] >> shift) & 3;
            ix *= 3;
            if (shift) shift -= 2;
            else { shift = 6; p++; }
            return (plte[ix] << 24) | (plte[ix+1] << 16) | (plte[ix+2] << 8) | 0xff;
          };
        case 4: shift = 4; return () => {
            if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; shift = 4; } xi--;
            let ix = (src[p] >> shift) & 15;
            ix *= 3;
            if (shift) shift = 0;
            else { shift = 6; p++; }
            return (plte[ix] << 24) | (plte[ix+1] << 16) | (plte[ix+2] << 8) | 0xff;
          };
        case 8: return () => {
            if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
            let ix = src[p++];
            ix *= 3;
            return (plte[ix] << 24) | (plte[ix+1] << 16) | (plte[ix+2] << 8) | 0xff;
          };
      }
      
    } else switch (ihdr.colortype) {
      case 0: case 3: switch (ihdr.depth) { // GRAY (or INDEX with missing PLTE)
          case 1: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; mask = 0x80; } xi--;
              const luma = (src[p] & mask) ? 0xff : 0;
              if (mask === 1) { mask = 0x80; p++; }
              else mask >>= 1;
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
          case 2: shift = 6; return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; shift = 6; } xi--;
              let luma = (src[p] >> shift) & 3;
              luma |= luma << 2;
              luma |= luma << 4;
              if (shift) shift -= 2;
              else { shift = 6; p++; }
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
          case 4: shift = 4; return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; shift = 4; } xi--;
              let luma = (src[p] >> shift) & 15;
              luma |= luma << 4;
              if (shift) shift = 0;
              else { shift = 6; p++; }
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
          case 8: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const luma = src[p++];
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
          case 16: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const luma = src[p];
              p += 2;
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
        } break;
      case 2: switch (ihdr.depth) { // RGB
          case 8: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const r = src[p++];
              const g = src[p++];
              const b = src[p++];
              return (r << 24) | (g << 16) | (b << 8) | 0xff;
            };
          case 16: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const r = src[p++]; p++;
              const g = src[p++]; p++;
              const b = src[p++]; p++;
              return (r << 24) | (g << 16) | (b << 8) | 0xff;
            };
        } break;
      case 4: switch (ihdr.depth) { // YA
          case 8: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const luma = src[p++];
              const alpha = src[p++];
              return (luma << 24) | (luma << 16) | (luma << 8) | alpha;
            };
          case 16: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const luma = src[p++]; p++;
              const alpha = src[p++]; p++;
              return (luma << 24) | (luma << 16) | (luma << 8) | alpha;
            };
        } break;
      case 6: switch (ihdr.depth) { // RGBA
          case 8: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const r = src[p++];
              const g = src[p++];
              const b = src[p++];
              const a = src[p++];
              return (r << 24) | (g << 16) | (b << 8) | a;
            };
          case 16: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const r = src[p++]; p++;
              const g = src[p++]; p++;
              const b = src[p++]; p++;
              const a = src[p++]; p++;
              return (r << 24) | (g << 16) | (b << 8) | a;
            };
        } break;
    }
    return () => 0;
  }
}
 /* Audio.js
 * Implements our synthesizer and exposes the public API.
 */




 
class Audio {
  constructor(egg) {
    this.egg = egg;
    
    this.rate = 44100; // TODO configurable?
    this.context = null;
    this.song = null;
    this.channels = [
      null, null, null, null,
      null, null, null, null,
      null, null, null, null,
      null, null, null, null,
    ];
    this.voices = [];
    this.sounds = {}; // key:"QUAL.RID", value:AudioBuffer
    this.soundEffects = [];
    this.noise = null; // AudioBuffer, null until we need it.
    
    this.hzByNoteid = [];
    for (let noteid=0; noteid<0x80; noteid++) {
      this.hzByNoteid.push(440 * Math.pow(2, (noteid - 69) / 12));
    }
  }
  
  start() {
    if (!window.AudioContext) return;
    this.context = new window.AudioContext({
      sampleRate: this.rate,
      latencyHint: "interactive",
    });
    if (this.context.state === "suspended") {
      this.context.resume();
    }
  }
  
  stop() {
    this.endSong();
    //TODO
  }
  
  update() {
    for (let i=this.voices.length; i-->0; ) {
      const voice = this.voices[i];
      if (!voice.isFinished()) continue;
      voice.terminate();
      this.voices.splice(i, 1);
    }
    if (this.song) {
      this.song.update();
    }
  }
  
  /* Public API.
   *****************************************************************/
  
  egg_audio_play_song(qual, songid, force, repeat) {
    if (!force && this.song && this.song.isResource(qual, songid)) return;
    this.endSong();
    const serial = this.egg.rom.getRes(Rom.RESTYPE_song, qual, songid);
    if (!serial || !serial.length) return;
    try {
      this.song = new Song(serial, this, repeat, qual, songid);
    } catch (e) {
      console.error(`Failed to play song:${qual}:${songid}.`, e);
      return;
    }
    this.beginSong();
  }
  
  egg_audio_play_sound(qual, soundid, trim, pan, when) {
    if (!this.context) return;
    trim /= 65536;
    pan /= 65536;
    if (!when) when = this.context.currentTime;
    const pcm = this.acquireSound(qual, soundid);
    if (!pcm) return;
    const node = new AudioBufferSourceNode(this.context, {
      buffer: pcm,
      channelCount: 1,
    });
    const gain = new GainNode(this.context, { gain: trim });
    node.connect(gain);
    gain.connect(this.context.destination);
    node.start(when);
    node.eggStartTime = when;
    this.soundEffects.push(node);
    node.onended = () => {
      const p = this.soundEffects.indexOf(node);
      if (p >= 0) this.soundEffects.splice(p, 1);
    };
  }
  
  egg_audio_event(chid, opcode, a, b) {
    switch (opcode) {
      case 0x80: this.endNote(chid, a, b); break;
      case 0x90: this.playNote(chid, a, b, 5.0, 0/*this.context.currentTime*/); break;
    }
  }
  
  egg_audio_get_playhead() {
    if (!this.song) return -1;
    let elapsed = this.context.currentTime - this.song.startTime;
    if (this.song.durations) elapsed %= this.song.durations;
    return (elapsed * 1000) / this.song.msperqnote;
  }
  
  egg_audio_set_playhead(beat) {
    if (!this.song) return;
    this.stopVoices();
    //TODO Set playhead. This is actually pretty tough to manage. Punt.
  }
  
  /* Internals.
   ******************************************************************/
   
  endSong() {
    if (!this.song) return;
    this.song = null;
    this.stopVoices();
  }
  
  stopVoices() {
    for (const voice of this.voices) voice.release();
    for (let chid=0; chid<8; chid++) {
      if (this.channels[chid]) {
        this.channels[chid].stop();
        this.channels[chid] = null;
      }
    }
    const now = this.context.currentTime;
    for (let i=this.soundEffects.length; i-->0; ) {
      const node = this.soundEffects[i];
      if (node.eggStartTime && (node.eggStartTime >= now)) {
        node.disconnect();
        this.soundEffects.splice(i, 1);
      }
    }
  }
  
  beginSong() {
    if (!this.song) return;
    for (let i=0; i<8; i++) {
      this.channels[i] = null;
      const src = this.song.channels[i];
      if (!src.volume) continue;
      this.channels[i] = new Channel(this, src.pid, src.volume, src.pan);
    }
  }
  
  acquireSound(qual, rid) {
    if (!this.context) return null;
    const key = `${qual}.${rid}`;
    if (key in this.sounds) return this.sounds[key];
    let v = null;
    const serial = this.egg.rom.getRes(Rom.RESTYPE_sound, qual, rid);
    if (serial && serial.length) {
      const fv = new SfgPrinter(serial, this.rate).print();
      if (fv && fv.length) {
        v = new AudioBuffer({
          length: fv.length,
          numberOfChannels: 1,
          sampleRate: this.rate,
          channelCount: 1,
        });
        v.copyToChannel(fv, 0);
      }
    }
    this.sounds[key] = v;
    return v;
  }
  
  endNote(chid, noteid, velocity) {
    const p = this.voices.findIndex(v => ((v.eggChid === chid) && (v.eggNoteid = noteid)));
    if (p < 0) return;
    const voice = this.voices[p];
    voice.eggChid = -1;
    voice.eggNoteid = -1;
    voice.release();
  }
  
  // (velocity) in 0..127 like MIDI. (when) in AudioContext time.
  playNote(chid, noteid, velocity, durs, when) {
    let channel = this.channels[chid];
    //console.log(`Audio.playNote`, { chid, noteid, velocity, durs, when, channel });
    if (!channel) {
      if ((chid < 0) || (chid >= 16)) return;
      channel = this.channels[chid] = new Channel(this, 0x00, 0x80, 0x80);
    }
    const voice = channel.playNote(this, noteid, velocity / 127.0, durs, when);
    if (!voice) return;
    voice.eggChid = chid;
    voice.eggNoteid = noteid;
  }
  
  // (v) in 0..0x3fff like MIDI. (when) in AudioContext time.
  changeWheel(chid, v, when) {
    const channel = this.channels[chid];
    if (!channel) return;
    if (!channel.wheelRange) return;
    if (v === channel.wheel) return;
    channel.wheel = v;
    channel.wheelCents = ((v - 0x2000) * channel.wheelRange) / 0x2000;
    //TODO Apply to in-flight voices. Must respect (when) too!
  }
  
  requireNoise() {
    if (this.noise) return;
    const fv = new Float32Array(this.rate);
    for (let i=fv.length; i-->0; ) fv[i] = Math.random() * 2 - 1;
    this.noise = new AudioBuffer({
      length: fv.length,
      numberOfChannels: 1,
      sampleRate: this.rate,
      channelCount: 1,
    });
    this.noise.copyToChannel(fv, 0);
  }
}

/* Song.
 **********************************************************************/
 
const SONG_READAHEAD_WINDOW_S = 0.500;
 
class Song {
  constructor(src, audio, repeat, qual, songid) {
    this.audio = audio;
    this.repeat = repeat;
    this.qual = qual;
    this.songid = songid;
    if (!(src instanceof Uint8Array)) throw new Error(`Expected Uint8Array`);
    if (src.length < 42) throw new Error(`Invalid song`);
    if ((src[0] !== 0xbe) || (src[1] !== 0xee) || (src[2] !== 0xee) || (src[3] !== 0x50)) throw new Error(`Invalid song`);
    this.msperqnote = (src[4] << 8) | src[5];
    this.startp = (src[6] << 8) | src[7];
    this.loopp = (src[8] << 8) | src[9];
    if ((this.startp < 42) || (this.loopp < this.startp) || (this.loopp >= src.length)) throw new Error(`Invalid song`);
    this.src = src;
    this.channels = [];
    for (let srcp=10; srcp<42; srcp+=4) {
      this.channels.push({
        pid: src[srcp],
        volume: src[srcp+1],
        pan: src[srcp+2],
        rsv: src[srcp+3],
      });
    }
    this.startTime = audio.context.currentTime;
    this.readp = this.startp;
    this.readTime = this.startTime;
    this.durations = 0; // Zero until the first loop.
    this.durationPending = 0;
  }
  
  isResource(qual, songid) {
    return ((qual === this.qual) && (songid === this.songid));
  }
  
  update() {
    const now = this.audio.context.currentTime;
    const later = now + SONG_READAHEAD_WINDOW_S;
    while (this.readTime < later) {
      const event = this.readEvent();
      
      // End of song?
      if (!event) {
        this.audio.endSong();
        return;
      }
      
      // Delay?
      if (typeof(event) === "number") {
        this.readTime += event;
        if (!this.durations) this.durationPending += event;
        continue;
      }
      
      // Anything else, readEvent() dispatched it. Carry on.
    }
  }
  
  /* Advance readp and return one event:
   *  - null: EOF and not repeating.
   *  - number: Delay, seconds. Never zero.
   *  - "ok": Processed one event (we dispatch it from here).
   */
  readEvent() {
    const lead = this.src[this.readp++];
    
    // Zero or end of input is End of Song.
    if (!lead) {
      if (!this.durations) this.durations = this.durationPending;
      if (!this.repeat) return null;
      this.readp = this.loopp;
      // Must delay a little, in case the song has no explicit delays, so we don't loop forever.
      // Note that if this happens, it's a disaster no matter what.
      return 0.010;
    }
    
    // High bit unset is a delay in ms.
    if (!(lead & 0x80)) {
      return lead / 1000;
    }

    // 1000vvvv cccnnnnn nntttttt : NOTE. duration=(t<<5)ms (~2s max)
    if ((lead & 0xf0) === 0x80) {
      const a = this.src[this.readp++] || 0;
      const b = this.src[this.readp++] || 0;
      let velocity = (lead & 0x0f) << 3;
      velocity |= velocity >> 4;
      const chid = a >> 5;
      const noteid = ((a & 0x1f) << 2) | (b >> 6);
      const durms = ((b & 0x3f) << 5);
      this.audio.playNote(chid, noteid, velocity, durms / 1000, this.readTime);
      return "ok";
    }
    
    // 1001vvcc cnnnnnnn : FIREFORGET. Same as NOTE but duration zero (and coarser velocity).
    if ((lead & 0xf0) === 0x90) {
      const a = this.src[this.readp++] || 0;
      let velocity = ((lead & 0x0c) << 2);
      velocity |= velocity >> 2;
      velocity |= velocity >> 4;
      const chid = ((lead & 0x03) << 1) | (a >> 7);
      const noteid = (a & 0x7f);
      this.audio.playNote(chid, noteid, velocity, 0, this.readTime);
      return "ok";
    }
    
    // 10100ccc wwwwwwww : WHEEL. 8 bits unsigned. 0x40 by default.
    if ((lead & 0xf8) === 0xa0) {
      const a = this.src[this.readp++] || 0;
      const chid = lead & 0x07;
      const v = (a << 6) | (a >> 2);
      this.audio.changeWheel(chid, v, this.readTime);
      return "ok";
    }
    
    // Anything else is reserved and illegal. End the song.
    console.log(`Illegal song command ${lead}.`);
    return null;
  }
}

/* Channel.
 *********************************************************************/
 
class Channel {
  constructor(audio, pid, volume, pan) {
    this.audio = audio;
    this.pid = pid;
    this.volume = volume / 255.0;
    this.master = 0.250;
    this.pan = (pan - 0x80) / 128.0;
    this.mode = "noop";
    this.wheelRange = 200; // cents
    this.wheel = 0; // Last value, 0..0x3fff
    this.wheelCents = 0;
    
    if (this.pid < 0x00) this._initNoop();
    else if (this.pid < 0x80) this._initBuiltin(audio);
    else if (this.pid < 0x100) this._initDrum();
    else this._initNoop();
  }
  
  _initNoop() {
    this.mode = "noop";
    this.wheelRange = 0;
  }
  
  _initDrum() {
    this.mode = "drum";
    this.wheelRange = 0;
    this.drumBase = (this.pid - 0x80) * 0x80;
  }
  
  _initBuiltin(audio) {
    let cfg = Instruments[this.pid];
    if (typeof(cfg) === "number") {
      cfg = Instruments[cfg];
    }
    if (!cfg) return this._initNoop();
    if (typeof(cfg) === "string") {
      this.mode = cfg;
      return;
    }
    for (const k of Object.keys(cfg)) {
      this[k] = cfg[k];
    }
    if (this.wave) {
      this.wave = new PeriodicWave(audio.context, { real: this.wave });
    }
    if (this.mode === "fx") {
      this.fxBegin(audio);
    }
  }
  
  // (velocity) normalized
  playNote(audio, noteid, velocity, durs, when) {
    switch (this.mode) {
      case "noop": break;
      
      case "drum": {
          const soundid = this.drumBase + noteid;
          const trim = 0.200 + (this.volume * this.master * velocity) * 0.900;
          audio.egg_audio_play_sound(0, soundid, trim * 65536.0, this.pan, when);
        } break;
        
      case "blip": {
          const attackTime = 0.010;
          const releaseTime = 0.050;
          const level = this.volume * this.master * (velocity + 0.079) * 0.400;
          const voice = new Voice(audio);
          voice.oscillateShape("square", audio.hzByNoteid[noteid], this.wheelCents);
          voice.plateauLevel(when, attackTime, level, durs, releaseTime);
          voice.begin();
          return voice;
        }
        
      case "wave": {
          const voice = new Voice(audio);
          voice.oscillateWave(this.wave, audio.hzByNoteid[noteid], this.wheelCents);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
          return voice;
        }
        
      case "rock": {
          const voice = new Voice(audio);
          voice.oscillateMix(this.wave, this.mix, audio.hzByNoteid[noteid], this.wheelCents);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
          return voice;
        }
        
      case "fmrel": {
          const voice = new Voice(audio);
          voice.oscillateFmRelative(audio.hzByNoteid[noteid], this.wheelCents, this.fmRate, this.fmRangeScale, this.fmRangeEnv);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
          return voice;
        }
        
      case "fmabs": {
          const voice = new Voice(audio);
          voice.oscillateFmAbsolute(audio.hzByNoteid[noteid], this.wheelCents, this.fmRate, this.fmRangeScale, this.fmRangeEnv);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
          return voice;
        }
        
      case "sub": {
          const voice = new Voice(audio);
          voice.oscillateSubtractive(audio.hzByNoteid[noteid], this.wheelCents, this.subQ1, this.subQ2, this.subGain);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
          return voice;
        }
        
      case "fx": {
          return this.fxNote(audio, when, noteid, velocity, durs);
        }
    }
  }
  
  stop() {
    switch (this.mode) {
      case "fx": this.fxStop(); break;
    }
  }
  
  fxBegin(audio) {
    this.audio = audio;
    this.fxMaster = new GainNode(audio.context);
    this.fxMaster.gain.setValueAtTime(this.volume * this.master, 0);
    this.fxMaster.connect(audio.context.destination);
    this.fxVoices = [];
    this.fxAttach = this.fxMaster;
    
    //TODO detune. Can't do it in post like the C implementation, but I think we can vary the voice's frequencies.
    
    if ((this.fmRangeLfo > 0) && (this.fmRangeLfoDepth > 0)) {
      let beatRate = 2;
      if (this.audio.song && (this.audio.song.msperqnote > 0)) {
        beatRate = 1000 / this.audio.song.msperqnote;
      }
      const osc = new OscillatorNode(this.audio.context, {
        type: "sine",
        frequency: beatRate / this.fmRangeLfo,
      });
      const gain = new GainNode(this.audio.context, {
        gain: this.fmRangeLfoDepth * 100, // TODO No idea why this *100 is needed.
      });
      osc.connect(gain);
      osc.start();
      this.fmLfo = osc;
      this.fmLfoOut = gain;
    }
    
    if ((this.delayRate > 0) && (this.delayDepth > 0) && this.audio.song && (this.audio.song.msperqnote > 0)) {
      const wetLevel = this.delayDepth * 0.500;
      const dryLevel = 1 - wetLevel;
      const period = (this.delayRate * this.audio.song.msperqnote) / 1000;
      const delay = new DelayNode(this.audio.context, { delayTime: period });
      
      const intake = new GainNode(this.audio.context, { gain: 1 });
      const output = new GainNode(this.audio.context, { gain: 1 });
      const dryGain = new GainNode(this.audio.context, { gain: dryLevel });
      const wetGain = new GainNode(this.audio.context, { gain: wetLevel });
      intake.connect(dryGain);
      dryGain.connect(output);
      intake.connect(delay);
      delay.connect(wetGain);
      wetGain.connect(delay);
      wetGain.connect(output);
      output.connect(this.fxAttach);
      this.fxAttach = intake;
    }
    
    if (this.overdrive > 0) {
      const len = 99;
      const odrange = 8;
      const midp = len >> 1;
      const odscaled = 0.5 + this.overdrive * (odrange - 0.5);
      const odcurved = 1 / odscaled; // Now in (1/odrange)..2
      const odnormed = (odcurved - 1 / odrange) / (2 - 1 / odrange);
      const ramplen = midp * odnormed;
      const vv = new Float32Array(len);
      for (let i=0; i<ramplen; i++) {
        vv[midp + i + 1] = Math.sin((i * Math.PI / 2) / ramplen);
      }
      for (let i=midp+ramplen+1; i<len; i++) {
        vv[i] = 1;
      }
      for (let dst=midp, src=midp+1; dst-->0; src++) {
        vv[dst] = -vv[src];
      }
      const shaper = new WaveShaperNode(this.audio.context, {
        curve: vv,
      });
      // Also some attenuation, after the wave-shape, since we're raising its average level.
      if (this.overdrive >= 0.25) {
        const drop = new GainNode(this.audio.context, {
          gain: 1 - (this.overdrive - 0.25) * 0.8,
        });
        shaper.connect(drop);
        drop.connect(this.fxAttach);
      } else {
        shaper.connect(this.fxAttach);
      }
      this.fxAttach = shaper;
    }
  }
  
  fxStop() {
    if (this.fxMaster) {
      this.fxMaster.disconnect();
      this.fxMaster = null;
    }
    if (this.fmLfo) {
      this.fmLfo.stop();
      this.fmLfo.disconnect();
      this.fmLfo = null;
    }
    if (this.fmLfoOut) {
      this.fmLfoOut.disconnect();
      this.fmLfoOut = null;
    }
  }
  
  fxNote(audio, when, noteid, velocity, durs) {
    const voice = new Voice(this.audio);
    voice.oscillateFmRelative(this.audio.hzByNoteid[noteid], this.wheelCents, this.fmRate, this.fmRangeScale, this.fmRangeEnv, this.fmLfoOut);
    voice.tinyEnv(when, this.levelTiny, durs, velocity, 1);
    voice.begin(this.fxAttach);
    return voice;
  }
}

/* Voice.
 *******************************************************************/
 
class Voice {
  constructor(audio) {
    this.audio = audio;
    this.osc = null;
    this.env = null;
    this.endTime = 0;
  }
  
  isFinished() {
    if (!this.audio || !this.audio.context || !this.env) return true;
    return (this.audio.context.currentTime > this.endTime);
  }
  
  terminate() {
    if (this.env) {
      this.env.disconnect();
      this.env = null;
    }
    if (this.osc) {
      if (this.osc.stop) this.osc.stop();
      this.osc.disconnect();
      this.osc = null;
    }
    if (this.oscDry) {
      this.oscDry.stop();
      this.oscDry.disconnect();
      this.oscDry = null;
    }
    if (this.oscWet) {
      this.oscWet.stop();
      this.oscWet.disconnect();
      this.oscWet = null;
    }
    if (this.modosc) {
      this.modosc.stop();
      this.modosc.disconnect();
      this.modosc = null;
    }
    if (this.noiseNode) {
      this.noiseNode.stop();
      this.noiseNode.disconnect();
      this.noiseNode = null;
    }
    if (this.post) {
      this.post.disconnect();
      this.post = null;
    }
  }
  
  release() {
    if (!this.audio || !this.audio.context) {
      this.terminate();
      return;
    }
    const now = this.audio.context.currentTime;
    if (this.startTime && (this.startTime <= now)) {
      this.terminate();
      return;
    }
    const endTime = now + 0.100;
    if (this.env) {
      this.env.gain.setValueAtTime(this.env.gain.value, now);
      this.env.gain.linearRampToValueAtTime(0, endTime);
    }
    this.endTime = endTime;
  }
  
  begin(dst) {
    if (!this.audio || !this.env) return;
    if (!dst) dst = this.audio.context.destination;
    if (this.osc) {
      this.osc.connect(this.env);
      if (this.osc.start) this.osc.start();
    } else if (this.gainDry) {
      this.gainDry.connect(this.env);
      this.gainWet.connect(this.env);
      this.oscDry.start();
      this.oscWet.start();
    } else {
      return;
    }
    if (this.post) this.post.connect(dst);
    else this.env.connect(dst);
    this.audio.voices.push(this);
  }
  
  oscillateShape(type, frequency, detune) {
    this.osc = new OscillatorNode(this.audio.context, {
      type,
      frequency,
      detune,
    });
  }
  
  oscillateWave(periodicWave, frequency, detune) {
    this.osc = new OscillatorNode(this.audio.context, {
      periodicWave,
      frequency,
      detune,
    });
  }
  
  // (mix) is 4 levels, 4 bits each, big-endian. eg 0xf842 = [1.0, 0.5, 0.25, 0.125]
  oscillateMix(periodicWave, mix, frequency, detune) {
    this.oscDry = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency,
      detune,
    });
    this.oscWet = new OscillatorNode(this.audio.context, {
      periodicWave,
      frequency,
      detune,
    });
    this.gainDry = new GainNode(this.audio.context);
    this.gainWet = new GainNode(this.audio.context);
    this.oscDry.connect(this.gainDry);
    this.oscWet.connect(this.gainWet);
    this.mix = mix;
  }
  
  oscillateFmRelative(frequency, detune, rate, scale, env, lfo) {
    this.osc = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency,
      detune,
    });
    this.modosc = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency: frequency * rate * Math.pow(2, detune / 1200),
    });
    this.modgain = new GainNode(this.audio.context);
    if (lfo) {
      this.fmGainLfo = lfo;
      this.fmGainLfo.connect(this.modgain.gain);
      this.modgain.gain.setValueAtTime(1, 0);
      this.modgain.connect(this.osc.frequency);
    } else {
      this.modgain.connect(this.osc.frequency);
    }
    this.modgainPeak = scale * frequency;
    this.fmRangeEnv = env;
    this.modosc.connect(this.modgain);
    this.modosc.start();
  }
  
  oscillateFmAbsolute(frequency, detune, rate, scale, env) {
    this.osc = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency,
      detune,
    });
    this.modosc = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency: rate,
    });
    this.modgain = new GainNode(this.audio.context);
    this.modgainPeak = scale * frequency;
    this.fmRangeEnv = env;
    this.modgain.connect(this.osc.frequency);
    this.modosc.connect(this.modgain);
    this.modosc.start();
  }
  
  oscillateSubtractive(frequency, detune, q1, q2, gain) {
    this.audio.requireNoise();
    this.noiseNode = new AudioBufferSourceNode(this.audio.context, {
      buffer: this.audio.noise,
      channelCount: 1,
      loop: true,
      loopStart: 0,
      loopEnd: this.audio.noise.duration,
    });
    const filter1 = new BiquadFilterNode(this.audio.context, {
      type: "bandpass",
      Q: q1,
      frequency,
    });
    const filter2 = new BiquadFilterNode(this.audio.context, {
      type: "bandpass",
      Q: q2,
      frequency,
    });
    const gainNode = new GainNode(this.audio.context);
    gainNode.gain.setValueAtTime(gain, 0);
    this.noiseNode.connect(filter1);
    filter1.connect(filter2);
    filter2.connect(gainNode);
    this.osc = gainNode;
    this.noiseNode.start();
  }
  
  plateauLevel(when, attackTimeRel, peakLevel, sustainTimeRel, releaseTimeRel) {
    this.startTime = when;
    if (!when) when = this.audio.context.currentTime;
    this.endTime = when + attackTimeRel + sustainTimeRel + releaseTimeRel;
    this.env = new GainNode(this.audio.context);
    this.env.gain.setValueAtTime(0, 0);
    this.env.gain.setValueAtTime(0, when);
    this.env.gain.linearRampToValueAtTime(peakLevel, when + attackTimeRel);
    this.env.gain.setValueAtTime(peakLevel, when + attackTimeRel + sustainTimeRel);
    this.env.gain.linearRampToValueAtTime(0, this.endTime);
  }
  
  /* A format I use in the C implementation for single-byte level envelopes:
   *   0xc0 Decay relative to attack:
   *         0x00 IMPULSE: Do not sustain.
   *         0x40 PLUCK: Heavy loss after attack.
   *         0x80 TONE: Attack noticeably louder than sustain.
   *         0xc0 BOW: No appreciable attack.
   *   0x38 Attack time: 0x00=Fast .. 0x38=Slow
   *   0x07 Release time: 0x00=Short .. 0x07=Long
   */
  tinyEnv(when, v, durs, velocity, trim) {
    this.startTime = when;
    if (!when) when = this.audio.context.currentTime;
    let attackTimeHi;
    switch (v & 0x38) {
      case 0x00: attackTimeHi = 0.005; break;
      case 0x08: attackTimeHi = 0.008; break;
      case 0x10: attackTimeHi = 0.012; break;
      case 0x18: attackTimeHi = 0.018; break;
      case 0x20: attackTimeHi = 0.030; break;
      case 0x28: attackTimeHi = 0.045; break;
      case 0x30: attackTimeHi = 0.060; break;
      case 0x38: attackTimeHi = 0.080; break;
    }
    let releaseTimeHi;
    switch (v & 0x07) {
      case 0x00: releaseTimeHi = 0.040; break;
      case 0x01: releaseTimeHi = 0.060; break;
      case 0x02: releaseTimeHi = 0.100; break;
      case 0x03: releaseTimeHi = 0.200; break;
      case 0x04: releaseTimeHi = 0.400; break;
      case 0x05: releaseTimeHi = 0.600; break;
      case 0x06: releaseTimeHi = 0.800; break;
      case 0x07: releaseTimeHi = 1.200; break;
    }
    let sustain = true;
    let attackValueHi = 1;
    let sustainValueHi;
    switch (v & 0xc0) {
      case 0x00: { // IMPULSE
          sustain = false;
          sustainValueHi = 0.250;
        } break;
      case 0x40: { // PLUCK
          sustainValueHi = 0.200;
        } break;
      case 0x80: { // TONE
          attackValueHi = 0.750;
          sustainValueHi = 0.400;
        } break;
      case 0xc0: { // BOW
          attackValueHi = 0.400;
          sustainValueHi = 0.400;
        } break;
    }
    let decayTimeHi = (attackTimeHi * 3) / 2;
    const attackTimeLo = attackTimeHi * 2;
    const decayTimeLo = decayTimeHi * 2;
    const releaseTimeLo = releaseTimeHi * 0.5;
    const attackValueLo = attackValueHi * 0.333;
    const sustainValueLo = sustainValueHi * 0.500;
    let a, b;
    if (velocity <= 0) { a=1; b=0; }
    else if (velocity >= 1) { a=0; b=1; }
    else { a = 1 - velocity; b = velocity; }
    const attackTime = attackTimeLo * a + attackTimeHi * b;
    const attackValue = (attackValueLo * a + attackValueHi * b) * trim;
    const decayTime = decayTimeLo * a + decayTimeHi * b;
    const sustainValue = (sustainValueLo * a + sustainValueHi * b) * trim;
    if (!sustain) durs = 0;
    const releaseTime = releaseTimeLo * a + releaseTimeHi * b;
    this.endTime = when + attackTime + decayTime + durs + releaseTime;
    
    this.env = new GainNode(this.audio.context);
    this.env.gain.setValueAtTime(0, 0);
    this.env.gain.setValueAtTime(0, when);
    this.env.gain.linearRampToValueAtTime(attackValue, when + attackTime);
    this.env.gain.linearRampToValueAtTime(sustainValue, when + attackTime + decayTime);
    this.env.gain.setValueAtTime(sustainValue, when + attackTime + decayTime + durs);
    this.env.gain.linearRampToValueAtTime(0, this.endTime);
    
    if (this.gainDry && this.gainWet) {
      const v0 = (this.mix >> 12) / 15.0;
      const v1 = ((this.mix >> 8) & 15) / 15.0;
      const v2 = ((this.mix >> 4) & 15) / 15.0;
      const v3 = (this.mix & 15) / 15.0;
      this.gainDry.gain.setValueAtTime(0, 0);
      this.gainDry.gain.setValueAtTime(1 - v0, when);
      this.gainDry.gain.linearRampToValueAtTime(1 - v1, when + attackTime);
      this.gainDry.gain.linearRampToValueAtTime(1 - v2, when + attackTime + decayTime);
      this.gainDry.gain.linearRampToValueAtTime(1 - v2, when + attackTime + decayTime + durs);
      this.gainDry.gain.linearRampToValueAtTime(1 - v3, this.endTime);
      this.gainWet.gain.setValueAtTime(0, 0);
      this.gainWet.gain.setValueAtTime(v0, when);
      this.gainWet.gain.linearRampToValueAtTime(v1, when + attackTime);
      this.gainWet.gain.linearRampToValueAtTime(v2, when + attackTime + decayTime);
      this.gainWet.gain.linearRampToValueAtTime(v2, when + attackTime + decayTime + durs);
      this.gainWet.gain.linearRampToValueAtTime(v3, this.endTime);
    }
    
    if (this.fmRangeEnv && !this.fmRangeLfo) {
      if (this.fmRangeEnv === 0xffff) {
        this.modgain.gain.setValueAtTime(this.modgainPeak, 0);
      } else {
        const v0hi = (this.modgainPeak * (this.fmRangeEnv >> 12)) / 15.0;
        const v1hi = (this.modgainPeak * ((this.fmRangeEnv >> 8) & 15)) / 15.0;
        const v2hi = (this.modgainPeak * ((this.fmRangeEnv >> 4) & 15)) / 15.0;
        const v3hi = (this.modgainPeak * (this.fmRangeEnv & 15)) / 15.0;
        const avg = (v0hi + v1hi + v2hi + v3hi) / 4;
        const v0lo = (v0hi + avg) / 2;
        const v1lo = (v1hi + avg) / 2;
        const v2lo = (v2hi + avg) / 2;
        const v3lo = (v3hi + avg) / 2;
        const v0 = v0lo * (1 - velocity) + v0hi * velocity;
        const v1 = v1lo * (1 - velocity) + v1hi * velocity;
        const v2 = v2lo * (1 - velocity) + v2hi * velocity;
        const v3 = v3lo * (1 - velocity) + v3hi * velocity;
        this.modgain.gain.setValueAtTime(v0, 0);
        this.modgain.gain.setValueAtTime(v0, when);
        this.modgain.gain.linearRampToValueAtTime(v1, when + attackTime);
        this.modgain.gain.linearRampToValueAtTime(v2, when + attackTime + decayTime);
        this.modgain.gain.setValueAtTime(v2, when + attackTime + decayTime + durs);
        this.modgain.gain.linearRampToValueAtTime(v3, this.endTime);
      }
    }
  }
}
/* SysExtra.js
 * Little helpers for the public API. Log, date, language...
 */
 
class SysExtra {
  constructor(window) {
    this.window = window;
    this.storage = null;
    this.storageKey = "egg"; // Set before the first access.
  }
  
  /* Returns:
   * {
   *   srcc: Length of (src) consumed.
   *   align: -1|0|1.
   *   fill: ' ' or '0'.
   *   len: integer or "*" to read from vargs.
   *   prec: integer or "*" to read from vargs, <0 if unspecified.
   *   value: null, you fill in from vargs.
   *   spec: Single character.
   * }
   * Or null if malformed.
   */
  parseLogFormatUnit(src, srcp) {
    const srcp0 = srcp;
    if (srcp >= src.length) return null;
    if (src[srcp++] !== '%') return null;
    
    let align = 1;
    if (src[srcp] === '-') {
      align = -1;
      srcp++;
    } else if (src[srcp] === '+') {
      align = 1;
      srcp++;
    } else if (src[srcp] === '=') {
      align = 0;
      srcp++;
    }
    
    let fill = ' ';
    if (src[srcp] === '0') {
      fill = '0';
      srcp++;
    }
    
    let len = 0;
    if (src[srcp] === '*') {
      len = '*';
      srcp++;
    } else while ((src[srcp] >= '0') && (src[srcp] <= '9')) {
      len *= 10;
      len += src.charCodeAt(srcp) - 0x30;
      srcp++;
    }
    
    let prec = -1;
    if (src[srcp] === '.') {
      srcp++;
      if (src[srcp] === '*') {
        prec = '*';
        srcp++;
      } else {
        prec = 0;
        while ((src[srcp] >= '0') && (src[srcp] <= '9')) {
          prec *= 10;
          prec += src.charCodeAt(srcp) - 0x30;
          srcp++;
        }
      }
    }
    
    let spec;
    switch (src[srcp]) {
      case 'd':
      case 'x':
      case 'p':
      case 'l':
      case 'f':
      case 's':
      case 'c': {
          spec = src[srcp];
          srcp++;
        } break;
      default: return null;
    }
    return { srcc: srcp - srcp0, fill, align, len, prec, spec, value: null };
  }
  
  applyLogFormatUnit(unit) {
    let pre = "";
    switch (unit.spec) {
      case 'u': pre = (~~unit.value || 0).toString(); break;
      case 'd': pre = (~~unit.value || 0).toString(); break;
      case 'x': pre = (~~unit.value || 0).toString(16); break;
      case 'p': pre = (~~unit.value || 0).toString(16); break;
      case 'l': pre = (~~unit.value || 0).toString(); break;
      case 'f': pre = (+unit.value).toString(); break; // TODO prec
      case 's': pre = (unit.value || "").toString(); if (unit.prec >= 0) pre = pre.substring(0, unit.prec); break;
      case 'c': pre = String.fromCharCode(~~unit.value || 0x3f); break;
    }
    let spaces = "                              ";
    if (unit.fill === '0') {
      spaces = "0000000000000000000000000000000000";
    }
    if (pre.length < unit.len) switch (unit.align) {
      case -1: pre += spaces.substring(0, unit.len - pre.length); break;
      case 0: {
          const addc = unit.len - pre.length;
          const each = addc >> 1;
          const more = addc & 1;
          pre = spaces.substring(0, each) + pre +spaces.substring(0, each + more);
        } break;
      case 1: pre = spaces.substring(0, unit.len - pre.length) + pre; break;
    }
    return pre;
  }
  
  /* (vargs) can be an array of values or an iterator function: (spec:[udxplfsc],prec) => any
   */
  applyLogFormat(fmt, vargs) {
    if (!fmt) return "";
    if (!vargs) return fmt;
    let fmtp=0, vargsp=0, dst="";
    while (fmtp < fmt.length) {
      let nextp = fmt.indexOf('%', fmtp);
      if (nextp < 0) nextp = fmt.length;
      if (nextp > fmtp) {
        dst += fmt.substring(fmtp, nextp);
        fmtp = nextp;
        if (fmtp >= fmt.length) break;
      }
      if (fmt[fmtp + 1] === '%') {
        dst += "%";
        fmtp += 2;
        continue;
      }
      const unit = this.parseLogFormatUnit(fmt, fmtp);
      if (!unit) {
        dst += fmt[fmtp++];
        continue;
      }
      fmtp += unit.srcc;
      if (typeof(vargs) === "function") {
        if (unit.len === "*") unit.len = vargs('u');
        if (unit.prec === "*") unit.prec = vargs('u');
        unit.value = vargs(unit.spec, unit.prec);
      } else {
        if (unit.len === "*") unit.len = vargs[vargsp++] || 0;
        if (unit.prec === "*") unit.prec = vargs[vargsp++] || 0;
        unit.value = vargs[vargsp++];
      }
      dst += this.applyLogFormatUnit(unit);
    }
    return dst;
  }
  
  getUserLanguages() {
    let list = this.window.navigator.languages;
    if (list && (list.length > 0)) {
      list = Array.from(new Set(list.map(l => this.evalLang(l)).filter(v => v)));
    }
    if (!list) list = [];
    if (!list.length) {
      const code = this.evalLang(this.window.navigator.language);
      if (code) list.push(code);
    }
    return list;
  }
  
  evalLang(src) {
    if (!src) return 0;
    if (src.length >= 2) {
      let a = src.charCodeAt(0);
      let b = src.charCodeAt(1);
      if ((a >= 0x61) && (a <= 0x7a)) a = a - 0x61 + 6;
      else if ((a >= 0x30) && (a <= 0x35)) a = a - 0x30;
      else return 0;
      if ((b >= 0x61) && (b <= 0x7a)) b = b - 0x61 + 6;
      else if ((b >= 0x30) && (b <= 0x35)) b = b - 0x30;
      else return 0;
      return (a << 5) | b;
    }
    return 0;
  }
}
/* Egg.js
 * Top level coordinator for the Egg Web Runtime.
 * You must provide a valid Rom at construction.
 */
 








 
class Egg {
  constructor(rom) {
    this.rom = rom;
    this.data = new DataService(this);
    this.sysExtra = new SysExtra(window);
    this.input = new Input(this);
    this.audio = new Audio(this);
    this.imageDecoder = new ImageDecoder();
    this.canvas = null;
    this.render = null;
    this.exec = null;
    this.running = false;
    this.loaded = false;
    this.pvtime = 0;
    this.pendingFrame = null;
    this.restoreTitle = document.title;
    this.directgl = false;
  }
  
  attachToDom() {
    const body = document.body;
    body.innerHTML = "";
    
    // Optional "terminate" button. XXX This shouldn't be in the final product; whoever embeds us should provide this.
    const terminate = document.createElement("INPUT");
    terminate.setAttribute("type", "button");
    terminate.setAttribute("value", "Terminate");
    terminate.addEventListener("click", () => this.stop());
    terminate.style.display = "block";
    body.appendChild(terminate);
    
    this.canvas = document.createElement("CANVAS");
    this.setCanvasSize();
    body.appendChild(this.canvas);
    this.render = new Render(this);
    this.exec = new Exec(this);
    this.retitlePerRom();
  }
  
  setCanvasSize() {
    const match = this.data.getMetadata("framebuffer").match(/^(\d+)x(\d+)\s?(.*)/);
    if (!match) throw new Error("ROM does not declare its framebuffer size.");
    this.canvas.width = +match[1];
    this.canvas.height = +match[2];
    this.directgl = false;
    for (const token of match[3].split(/\s+/)) {
      if (token === "gl") this.directgl = true;
    }
    this.input.canvasChanged();
  }
  
  retitlePerRom() {
    document.title = this.data.getMetadata("title");
    let url = "";
    const iconImageId = +this.data.getMetadata("iconImage");
    if (iconImageId) {
      const serial = this.rom.getRes(Rom.RESTYPE_image, 0, iconImageId);
      if (serial.length > 0) {
        const crop = new Uint8Array(serial.length);
        crop.set(serial);
        const blob = new Blob([crop.buffer], { type: "image/png" });
        url = URL.createObjectURL(blob);
      }
    }
    for (const link of window.document.querySelectorAll("link[rel='icon']")) link.remove();
    if (url) {
      const link = window.document.createElement("LINK");
      link.setAttribute("data-egg-favicon", "");
      link.setAttribute("rel", "icon");
      link.setAttribute("type", "image/png");
      link.setAttribute("href", url);
      window.document.head.appendChild(link);
    }
  }
  
  retitleDefault() {
    document.title = this.restoreTitle;
    for (const link of window.document.querySelectorAll("link[rel='icon']")) link.remove();
  }
  
  start() {
    if (this.running) return;
    this.running = true;
    this.loaded = false;
    this.pvtime = 0;
    this.audio.start();
    return this.exec.load().then(() => {
      this.loaded = true;
      if (this.exec.egg_client_init() < 0) {
        throw new Error("Game aborted during startup.");
      }
      this.exec.egg_client_init = () => -1;
      this.pendingFrame = window.requestAnimationFrame(() => this.update());
    });
  }
  
  stop() {
    if (!this.running) return;
    this.audio.stop();
    this.input.detach();
    this.running = false;
    if (this.loaded) {
      this.exec.egg_client_quit();
      this.exec.egg_client_quit = () => {};
      this.loaded = false;
    }
    if (this.pendingFrame) {
      window.cancelAnimationFrame(this.pendingFrame);
      this.pendingFrame = null;
    }
    if (this.render) this.render.stop();
    this.retitleDefault();
  }
  
  update() {
    this.pendingFrame = null;
    if (!this.running) return;
    this.audio.update();
    this.input.update();
    const elapsed = this.tick();
    if (elapsed >= 0) {
      this.exec.egg_client_update(elapsed);
      if (!this.running) return;
      this.render.begin();
      this.exec.egg_client_render();
      this.render.end();
    }
    this.pendingFrame = window.requestAnimationFrame(() => this.update());
  }
  
  tick() {
    if (!this.pvtime) { // Very first update only, we update with zero time elapsed.
      this.pvtime = Date.now();
      return 0;
    }
    const now = Date.now();
    let elapsed = (now - this.pvtime) / 1000;
    if (elapsed < 0.015) return -1; // skip a frame (eg high-frequency monitors, don't let us run at 200 Hz or whatever)
    this.pvtime = now;
    return Math.min(0.050, elapsed); // Very long elapsed time, clamp at 50 ms.
  }
  
  /*------------------------ Public API entry points ------------------------*/
  
  egg_log(fmt, vargs) {
    const msg = this.sysExtra.applyLogFormat(
      this.exec.readCString(fmt),
      (spec, prec) => { // udxplfsc
        switch (spec) {
          case 'u': case 'd': case 'x': case 'c': case 'p': {
              const v = this.exec.mem32[vargs >> 2] || 0;
              vargs += 4;
              return v;
            }
          case 'l': {
              const v = this.exec.mem32[vargs >> 2] | (this.exec.mem32[(vargs+4) >> 2] * 4294967296);
              vargs += 8;
              return v;
            }
          case 'f': {
              if (vargs & 7) vargs = (vargs + 8) & ~7;
              const v = this.exec.memf64[vargs >> 3];
              vargs += 8;
              return v;
            }
          case 's': {
              let v;
              const p = this.exec.mem32[vargs >> 2];
              if (prec >= 0) v = this.exec.readLimitedString(p, prec);
              else v = this.exec.readCString(p);
              vargs += 4;
              return v;
            }
        }
      }
    );
    console.log(`GAME: ${msg}`);
  }
  
  egg_time_local(v, a) {
    if (a < 1) return;
    v >>= 2;
    const now = new Date();
    this.exec.mem32[v++] = now.getFullYear();
    if (a < 2) return;
    this.exec.mem32[v++] = 1 + now.getMonth();
    if (a < 3) return;
    this.exec.mem32[v++] = now.getDate();
    if (a < 4) return;
    this.exec.mem32[v++] = now.getHours();
    if (a < 5) return;
    this.exec.mem32[v++] = now.getMinutes();
    if (a < 6) return;
    this.exec.mem32[v++] = now.getSeconds();
    if (a < 7) return;
    this.exec.mem32[v++] = now.getMilliseconds();
  }
  
  egg_get_user_languages(v, a) {
    const src = this.sysExtra.getUserLanguages();
    const cpc = Math.min(a, src.length);
    for (let i=0, dstp=v>>2; i<cpc; i++, dstp++) {
      this.exec.mem32[dstp] = src[i];
    }
    return src.length;
  }
  
  egg_res_get(dst, dsta, tid, qual, rid) {
    const serial = this.rom.getRes(tid, qual, rid);
    return this.exec.safeWrite(dst, dsta, serial);
  }
  
  egg_res_for_each(cb, ctx) {
    if (!(cb = this.exec.fntab.get(cb))) return 0;
    for (const { tid, qual, rid, v } of this.rom.resv) {
      const err = cb(tid, qual, rid, v.length, ctx);
      if (err) return err;
    }
    return 0;
  }
}
</script>
</head>
<body>
</body>
</html>

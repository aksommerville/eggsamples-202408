<!DOCTYPE html>
<html>
<head>
<style>
canvas {
  width: 512px; /*TODO Pick an appropriate default size per rom. */
  image-rendering: pixelated; /*TODO It's a matter of opinion; let the game and user override. */
}
</style>
<egg-rom style="display:none">
r3c(7k0FCXRpdGxlRWdnIFNobXVwBg5hdXRob3JBSyBTb21tZXJ2aWxsZQsHZnJhbWVidWZmZXIxMjh4MTI4)t0r1eff(AGFzbQEAAAABVQ1gBn9/
f39/fwBgAAF8YAABf2ADf39/AX9gB39/f39/f38Bf2AJf39/f39/f39/AGAEf39/fwF/YAR/f39/AGACf38Bf2ABfwF/YAAAYAF/
AGABfAAC8AIQA2Vudg1lZ2dfZHJhd19yZWN0AAADZW52DWVnZ190aW1lX3JlYWwAAQNlbnYPZWdnX3RleHR1cmVfbmV3AAIDZW52
FmVnZ190ZXh0dXJlX2xvYWRfaW1hZ2UAAwNlbnYSZWdnX3RleHR1cmVfdXBsb2FkAAQDZW52DmVnZ19kcmF3X2RlY2FsAAUDZW52
DWVnZ19zdG9yZV9nZXQABgNlbnYTZWdnX2F1ZGlvX3BsYXlfc29uZwAHA2VudhBlZ2dfZXZlbnRfZW5hYmxlAAgDZW52D2VnZ19s
b2NrX2N1cnNvcgAJA2Vudg1lZ2dfZXZlbnRfZ2V0AAgDZW52F2VnZ19yZXF1ZXN0X3Rlcm1pbmF0aW9uAAoDZW52DWVnZ19zdG9y
ZV9zZXQABgNlbnYUZWdnX2F1ZGlvX3BsYXlfc291bmQABwNlbnYNZWdnX2RyYXdfdGlsZQAHA2Vudg9lZ2dfcmVuZGVyX3RpbnQA
CwMMCwoKCgILCgoCDAoKBAUBcAEBAQUDAQBBBgkBfwFBwJWAAgsHcgYGbWVtb3J5AgAZX19pbmRpcmVjdF9mdW5jdGlvbl90YWJs
ZQEAD2VnZ19jbGllbnRfcXVpdAAWD2VnZ19jbGllbnRfaW5pdAAXEWVnZ19jbGllbnRfdXBkYXRlABgRZWdnX2NsaWVudF9yZW5k
ZXIAGgrMNAsCAAuBAQECf0HgeSEAA0AgAEGwjoCAAGoQk4CAgABB/wBxNgIAIABBtI6AgABqEJOAgIAAQf8AcTYCACAAQbiOgIAA
ahCTgICAAEEDbyIBQQFqNgIAAkAgAUECSw0AIABBvI6AgABqIAFBgKDAgAFsQf+hwIABajYCAAsgAEEQaiIADQALC7QCAgF8BX8C
QAJAQQArA7iOgIAARAAAAAAAQH9AoiIAmUQAAAAAAADgQWNFDQAgAKohAQwBC0GAgICAeCEBC0EBQQBBAEGAAUGAAUH/gYB4IAFB
ACABQQBKG0EYdEH/AXIgAUH/AUobEICAgIAAQeB5IQEDQCABQbSOgIAAaiICIAIoAgAgAUG4joCAAGoiAygCACIEaiIFNgIAAkAg
BUGAAUgNABCTgICAACEEIAJBADYCACABQbCOgIAAaiAEQf8AcTYCACADEJOAgIAAQQNvIgVBAWoiBDYCACAFQQJLDQAgAUG8joCA
AGogBUGAoMCAAWxB/6HAgAFqNgIAC0EBIAFBsI6AgABqKAIAIAIoAgBBASAEQQFqIAFBvI6AgABqKAIAEICAgIAAIAFBEGoiAQ0A
Cws5AQF/QQBBACgCsI6AgAAiAEENdCAAcyIAQRF2IABzIgBBBXQgAHMiADYCsI6AgAAgAEH/////B3ELDQBBACAANgKwjoCAAAud
AQIBfAV/AkACQBCBgICAAEQAAAAAAECPQKIiAJlEAAAAAAAA4EFjRQ0AIACqIQEMAQtBgICAgHghAQtB8f8DIQICQANAAkAgAUUN
AEEAIQMgASEEA0AgBEEBcSADaiEDIARBAUshBSAEQQF2IQQgBQ0ACyADQXZqQQtJDQILIAIgAXMhASACQfH/A2ohAgwACwtBACAB
NgKwjoCAAAsCAAu8AwEGfyOAgICAAEEQayIAJICAgIAAQQAQgoCAgAAiATYCwI6AgAAgAUEAQQEQg4CAgAAaQQAQgoCAgAAiATYC
xI6AgAAgAUGAAUGAAUGABEEBQQBBABCEgICAABpBACgCxI6AgABBACgCwI6AgABBAEEAQRNBAEEwQQhBABCFgICAAAJAIABBDGpB
BEGAiICAAEEHEIaAgIAAIgJBf2pBBE8NAEEAIQECQCAALAAMIgNBRmpB/wFxQfYBSSIEDQAgA0EAKALIjoCAAEEKbGpBUGohAwJA
IAJBAUYNAEEAIQEgACwADSIFQUZqQf8BcUH2AUkiBA0BIAUgA0EKbGpBUGohAyACQQJGDQBBACEBIAAsAA4iBUFGakH/AXFB9gFJ
IgQNASAFIANBCmxqQVBqIQMgAkEDRg0AQQAhASAALAAPIgJBRmpB/wFxQfYBSSIEDQEgAiADQQpsakFQaiEDC0EAIAMgBBshAQtB
ACABNgLIjoCAAAtBAEEBQQBBARCHgICAAEEEQQEQiICAgAAaQQVBARCIgICAABpBARCJgICAABoQlYCAgAAQkYCAgAAgAEEQaiSA
gICAAEEAC+UaBQR/AXwFfwF8AX8jgICAgABB0AJrIgEkgICAgAACQANAIAFBEBCKgICAACICQQFIDQEgAkEBaiEDIAEhBANAAkAC
QAJAAkACQAJAIAQoAgBBf2oOBQEABQIDBQsCQAJAAkACQCAEQQRqKAIAQdf/Y2oOKAAICAEICAgICAgICAgICAgICAgICAgICAgI
CAgICAgICAgICAgIAgMICyAEQQhqKAIARQ0HEIuAgIAADAcLIARBCGooAgBBAUYNBQwGCwJAIARBCGooAgBFDQBBAEEBNgLMjoCA
AAwGC0EAKALMjoCAAEEBSA0FQQBBADYCzI6AgAAMBQsCQCAEQQhqKAIARQ0AQQBBfzYCzI6AgAAMBQtBACgCzI6AgABBf0oNBEEA
QQA2AsyOgIAADAQLAkACQAJAAkAgBEEIaigCAEGAf2oOEAAHBwcHBwcHBwcHAwcHAgEHCyAEQQxqKAIADQUMBgsCQCAEQQxqKAIA
RQ0AQQBBATYCzI6AgAAMBgtBACgCzI6AgABBAUgNBUEAQQA2AsyOgIAADAULAkAgBEEMaigCAEUNAEEAQX82AsyOgIAADAULQQAo
AsyOgIAAQX9KDQRBAEEANgLMjoCAAAwECyAEQQxqKAIARQ0DEIuAgIAADAMLQQBBACsDiIiAgAAgBEEEaigCALegIgU5A4iIgIAA
AkAgBUQAAAAAAAAAAGNFDQBBACAFRAAAAAAAAGBAoDkDiIiAgAAMAwsgBUQAAAAAAABgQGZFDQJBACAFRAAAAAAAAGDAoDkDiIiA
gAAMAgsgBEEMaigCAEEBRw0BIARBEGooAgBBAUcNAQsQmYCAgAALIARBFGohBCADQX9qIgNBAUsNAAsgAkEPSg0ACwtBAEQAAAAA
AAAAAEEAKwPQjoCAACAAoSIFIAVEAAAAAAAAAABlGzkD0I6AgABBAEQAAAAAAAAAAEEAKwPYjoCAACAAoSIFIAVEAAAAAAAAAABl
GzkD2I6AgAACQEEALQDgjoCAAEUNAAJAQQAoAuSOgIAADQACQEEAKAKklICAACIEQQNHDQBBAEIANwP4kICAAEEAQgA3A+iQgIAA
QQBCADcD2JCAgABBAEIANwPIkICAAEEAQgA3A7iQgIAAQQBCADcDqJCAgABBAEIANwOYkICAAEEAQgA3A4iQgIAAQQBCADcD+I+A
gABBAEIANwPoj4CAAEEAQgA3A9iPgIAAQQBCADcDyI+AgABBAEIANwO4j4CAAEEAQgA3A6iPgIAAQQBCADcDmI+AgABBAEIANwOI
j4CAAEEAQQA2ApCUgIAAQQBBADoA4I6AgABBACgCgJGAgAAiBEEAKALIjoCAAEwNAUEAQQE6AKCUgIAAQQAgBEGPzgAgBEGPzgBI
GyIENgLIjoCAACABIARB6AdtQTBqOgDMAiABIARB5ABtQQpvQTBqOgDNAiABIARBCm0iA0EKb0EwajoAzgIgASAEIANBCmxrQTBq
OgDPAkGAiICAAEEHIAFBzAJqQQQQjICAgAAaDAELAkAgBEUNAEEALQCEkYCAAEEBcQ0AQQBCgICAgICAgITAADcD0I6AgABBAEEA
KAKAkYCAAEHoB2o2AoCRgIAAC0EAQoCAgICAgICEwAA3A9iOgIAAQQBCgIDggoAHNwO4lYCAAEEAQriAgICAiYAcNwOwlYCAAEEA
QqiA4IGAgIAcNwOolYCAAEEAQoCA4ICABzcDoJWAgABBAEKogICAgIGAHDcDmJWAgABBAELIgKCBgICALDcDkJWAgABBAEKAgOCB
gAU3A4iVgIAAQQBCqICAgICFgBQ3A4CVgIAAQQBCiICggYCAgAw3A/iUgIAAQQBCgIDggoADNwPwlICAAEEAQpiAgICAiYAMNwPo
lICAAEEAQqiA4ICAgIAcNwPglICAAEEAQoCA4ICAAzcD2JSAgABBAEKIgICAgIGADDcD0JSAgABBAELIgKCAgICALDcDyJSAgABB
AEKAgOCBgAE3A8CUgIAAQQBCiICAgICFgAQ3A7iUgIAAQQBCiICggICAgAw3A7CUgIAAQQAgBEEBajYCpJSAgABBAEEAOgCEkYCA
AEEAQQA6AKiUgIAAQQBBADYC5I6AgABBAEEYNgLkjoCAAAtBAEEAKwPojoCAACAAoSIFOQPojoCAAAJAIAVEAAAAAAAAAABlRQ0A
QQAgBUQAAAAAAADQP6A5A+iOgIAAQQAoAuSOgIAAIgNBAUgNACADQX9qIQZBsJSAgAAhBAJAIANBA3EiAkUNAANAIARBBGoiByAH
LQAAQQFzOgAAIARBBmohBCADQX9qIQMgAkF/aiICDQALCyAGQQNJDQAgBEEWaiEEIANBf2ohAwNAIAQgBC0AAEEBczoAACAEQW5q
IgIgAi0AAEEBczoAACAEQXRqIgIgAi0AAEEBczoAACAEQXpqIgIgAi0AAEEBczoAACAEQRhqIQQgA0F8aiIDQX5JDQALC0EAQQAr
A/COgIAAIAChIgU5A/COgIAAAkAgBUQAAAAAAAAAAGVFDQBBACAFRJqZmZmZmbk/oDkD8I6AgABBACgC5I6AgAAiCEEBSA0AQQAu
AbCUgIAAIglBAC4BspSAgAAiBCAJIARKGyEEAkACQCAIQQFHDQAgCSECDAELIAhBAWohBkG2lICAACEHIAkhAgNAIAQgBy4BACID
IAQgAyAEQRB0QRB1ShsgAyACQRB0QRB1SCIKGyEEIAMgAiAKGyECIAdBBmohByAGQX9qIgZBAksNAAsLAkACQEEALQColICAACID
DQAgBEEQdEEQdUH3AEoNASAIQQFIDQJBACAJQQFqOwGwlICAACAIQQFGDQIgCEEBaiEDQbaUgIAAIQQDQCAEIAQvAQBBAWo7AQAg
BEEGaiEEIANBf2oiA0ECSw0ADAMLCyACQRB0QRB1QQhIDQAgCEEBSA0BQQAgCUF/ajsBsJSAgAAgCEEBRg0BIAhBAWohA0G2lICA
ACEEA0AgBCAELwEAQX9qOwEAIARBBmohBCADQX9qIgNBAksNAAwCCwtBAEEBOgCEkYCAAEEAIANBAXM6AKiUgIAACwJAQQAoAsyO
gIAAIgRFDQBBACAEt0QAAAAAAABZQKIgAKJBACsDiIiAgACgIgU5A4iIgIAARAAAAAAAAGBAIQsCQCAFRAAAAAAAAAAAYw0ARAAA
AAAAAGDAIQsgBUQAAAAAAABgQGZFDQELQQAgBSALoDkDiIiAgAALQYCPgIAAIQJBDyEEIABEAAAAAABAb8CiIQsDQCAEIQoCQCAC
KwMIIgVEAAAAAAAAAABlDQAgAiALIAWgIgU5AwgCQAJAIAVEAAAAAAAAAABlRQ0AQQBCgICAgICAgPA/NwO4joCAAEEAQQE6AISR
gIAAQQBBACgCgJGAgABBAXU2AoCRgIAAQQMhBAwBC0EAKALkjoCAACIMQQFIDQEgDEEGbCEEAkACQCAFmUQAAAAAAADgQWNFDQAg
BaohAwwBC0GAgICAeCEDCyAEQaqUgIAAaiEEIANBdmohCCACLwEAQXtqIQcgDCEDA0ACQCAHIAQuAQAiBmtB//8DcUH3/wNJDQAg
CCAEQQJqLgEAIglrQf//A3FB9/8DSQ0AAkBBACgCkJSAgAAiB0EXSg0AQQAgB0EBajYCkJSAgAAgB0EEdCIHQZiRgIAAakKAgICA
gICA+D83AwAgB0GUkYCAAGogCTYCACAHQZCRgIAAaiAGNgIAC0EAIAxBf2oiBjYC5I6AgAACQCADIAxODQAgA0F/aiEDA0AgBEEE
aiAEQQpqLwEAOwEAIAQgBEEGaiIHKAEANgEAIAchBCADQQFqIgMgBkgNAAsLIAJCADcDCEEAQQAoAoCRgIAAQeQAajYCgJGAgABB
AiEEDAILIARBemohBCADQX9qIgNBAWpBAUsNAAwCCwtBACAEQYCABEEAEI2AgIAACyAKQX9qIQQgAkEQaiECIAoNAAsCQEEAKAKQ
lICAACIGQQFIDQAgBkF/aiEKQZCRgIAAIQQCQAJAIAZBA3EiAg0AIAYhAwwBCyAGIQMDQCAEQQhqIgcgBysDACAAoTkDACAEQRBq
IQQgA0F/aiEDIAJBf2oiAg0ACwsgCkEDSQ0AIANBf2ohAyAEQThqIQQDQCAEIAQrAwAgAKE5AwAgBEFQaiICIAIrAwAgAKE5AwAg
BEFgaiICIAIrAwAgAKE5AwAgBEFwaiICIAIrAwAgAKE5AwAgBEHAAGohBCADQXxqIgNBfkkNAAsLAkAgBkUNACAGQX9qIQMgBkEE
dEGIkYCAAGohBANAIAQrAwBEAAAAAAAAAABlRQ0BQQAgAzYCkJSAgAAgBEFwaiEEIANBf2oiA0F/Rw0ACwtBAEEAKwOYlICAACAA
oSIFOQOYlICAAAJAIAVEAAAAAAAAAABlRQ0AQQAgBUSamZmZmZm5P6A5A5iUgIAAQQAoAoCRgIAAIgRBAUgNAEEAIARBf2o2AoCR
gIAAC0EARAAAAAAAAAAAQQArA7iOgIAAIAChIgUgBUQAAAAAAAAAAGUbOQO4joCAAAsgAUHQAmokgICAgAALjwUDAX8BfAF/AkBB
AC0A4I6AgABFDQBBgI+AgAAhAAJAAkBBACsDiI+AgABEAAAAAAAAAABlDQBBkI+AgAAhAEEAKwOYj4CAAEQAAAAAAAAAAGUNAEGg
j4CAACEAQQArA6iPgIAARAAAAAAAAAAAZQ0AQbCPgIAAIQBBACsDuI+AgABEAAAAAAAAAABlDQBBwI+AgAAhAEEAKwPIj4CAAEQA
AAAAAAAAAGUNAEHQj4CAACEAQQArA9iPgIAARAAAAAAAAAAAZQ0AQeCPgIAAIQBBACsD6I+AgABEAAAAAAAAAABlDQBB8I+AgAAh
AEEAKwP4j4CAAEQAAAAAAAAAAGUNAEGAkICAACEAQQArA4iQgIAARAAAAAAAAAAAZQ0AQZCQgIAAIQBBACsDmJCAgABEAAAAAAAA
AABlDQBBoJCAgAAhAEEAKwOokICAAEQAAAAAAAAAAGUNAEGwkICAACEAQQArA7iQgIAARAAAAAAAAAAAZQ0AQcCQgIAAIQBBACsD
yJCAgABEAAAAAAAAAABlDQBB0JCAgAAhAEEAKwPYkICAAEQAAAAAAAAAAGUNAEHgkICAACEAQQArA+iQgIAARAAAAAAAAAAAZQ0A
QfCQgIAAIQBBACsD+JCAgABEAAAAAAAAAABlRQ0BC0EAQQFBgIAEQQAQjYCAgAAgAEKAgICAgICwrsAANwMIAkACQEEAKwOIiICA
ACIBmUQAAAAAAADgQWNFDQAgAaohAgwBC0GAgICAeCECCyAAIAI7AQALDwtBAEEBOgDgjoCAAEEAQoCAgICAgICowAA3A4iIgIAA
QQBBADYCgJGAgABBAEEAOgCEkYCAAEEAQQA2AqSUgIAAQQBBADoAoJSAgAAL7QsDAX8BfAR/EJKAgIAAAkBBAC0A4I6AgABFDQBB
AUEAKALEjoCAAEGwlICAAEEAKALkjoCAABCOgICAAEGAfiEAA0ACQCAAQYiRgIAAaisDACIBRAAAAAAAAAAAZQ0AAkACQCABmUQA
AAAAAADgQWNFDQAgAaohAgwBC0GAgICAeCECC0EBQQAoAsCOgIAAIABBgJGAgABqLwEAQRB0QYCAfGpBEHUgAkEQdEGAgGxqQRB1
QRBBAEEDQQVBABCFgICAAAsgAEEQaiIADQALAkACQEEAKALMjoCAACIAQX9KDQACQAJAQQArA4iIgIAAIgGZRAAAAAAAAOBBY0UN
ACABqiEADAELQYCAgIB4IQALQQFBACgCwI6AgAAgAEF9akHuAEEJQQBBB0EIQQAQhYCAgAAMAQtBACgCwI6AgAAhAgJAAkBBACsD
iIiAgAAiAZlEAAAAAAAA4EFjRQ0AIAGqIQMMAQtBgICAgHghAwsCQCAARQ0AQQEgAiADQX1qQe4AQQlBAEEHQQhBARCFgICAAAwB
C0EBIAIgA0F8akHuAEEAQQBBCUEIQQAQhYCAgAALQQAoApCUgIAAIgBBAUgNACAAQQFqIQJBkJGAgAAhAANAAkAgAEEIaiIDKwMA
IgFEAAAAAAAAAABlDQACQAJAIAFEAAAAAAAAEMCiRAAAAAAAAAhAoCIBmUQAAAAAAADgQWNFDQAgAaohBAwBC0GAgICAeCEEC0EB
QQAoAsCOgIAAIAAoAgBBfGogAEEEaiIFKAIAQXxqIARBAyAEQQNIGyIEQQAgBEEAShtBA3RBI2pBAEEIQQhBABCFgICAACAFKAIA
IQQCQAJAIAMrAwBEAAAAAAAAJECiIgGZRAAAAAAAAOBBY0UNACABqiEDDAELQYCAgIB4IQMLQQFBACgCwI6AgAAgACgCAEF8aiAE
IANqQXRqQcMAQQBBC0EFQQAQhYCAgAALIABBEGohACACQX9qIgJBAUsNAAsLQQAoAoCRgIAAIgBBj84AIABBj84ASBsiAkEAIAJB
AEobIQICQAJAIABBACgCyI6AgABODQBBAC0AoJSAgABBAXFFDQELQf+B/AcQj4CAgAALQQFBACgCwI6AgABB5ABB+gAgAkH//wNx
IgBB6AduQQpwQQVsQQhBBUEFQQAQhYCAgABBAUEAKALAjoCAAEHqAEH6ACAAQeQAbkH/AXFBCnBBBWxBCEEFQQVBABCFgICAAEEB
QQAoAsCOgIAAQfAAQfoAIABBCm4iAEEKcEEFbEEIQQVBBUEAEIWAgIAAQQFBACgCwI6AgABB9gBB+gAgAiAAQQpsa0EFbEH//wNx
QQhBBUEFQQAQhYCAgABBABCPgICAAEEBQQAoAsCOgIAAQQpB+gBBACgCyI6AgABB6AdtQQpvQQVsQQhBBUEFQQAQhYCAgABBAUEA
KALAjoCAAEEQQfoAQQAoAsiOgIAAQeQAbUEKb0EFbEEIQQVBBUEAEIWAgIAAQQFBACgCwI6AgABBFkH6AEEAKALIjoCAAEEKbUEK
b0EFbEEIQQVBBUEAEIWAgIAAQQFBACgCwI6AgABBHEH6AEEAKALIjoCAAEEKb0EFbEEIQQVBBUEAEIWAgIAAAkBBACsD2I6AgABE
AAAAAAAAAABkRQ0AQQFBACgCwI6AgABBKkE+QTJBCEEZQQVBABCFgICAAEEBQQAoAsCOgIAAQcgAQT5BACgCpJSAgABBBWxBCEEF
QQVBABCFgICAAEEBQQAoAsCOgIAAQc4AQT5BywBBCEEFQQVBABCFgICAAEEBQQAoAsCOgIAAQdQAQT5BD0EIQQVBBUEAEIWAgIAA
CwJAQQArA9COgIAAIgFEAAAAAAAAAABkRQ0AAkACQCABRAAAAAAAACRAoiIBmUQAAAAAAADgQWNFDQAgAaohAAwBC0GAgICAeCEA
C0H/gXxB/4H8ByAAQQFxGxCPgICAAEEBQQAoAsCOgIAAQStBxQBBAEENQS1BBUEAEIWAgIAAQQAQj4CAgAALCwsdAgBBgAgLCGhp
c2NvcmUAAEGICAsIAAAAAAAAUEAA6QMEbmFtZQG6AxsADWVnZ19kcmF3X3JlY3QBDWVnZ190aW1lX3JlYWwCD2VnZ190ZXh0dXJl
X25ldwMWZWdnX3RleHR1cmVfbG9hZF9pbWFnZQQSZWdnX3RleHR1cmVfdXBsb2FkBQ5lZ2dfZHJhd19kZWNhbAYNZWdnX3N0b3Jl
X2dldAcTZWdnX2F1ZGlvX3BsYXlfc29uZwgQZWdnX2V2ZW50X2VuYWJsZQkPZWdnX2xvY2tfY3Vyc29yCg1lZ2dfZXZlbnRfZ2V0
CxdlZ2dfcmVxdWVzdF90ZXJtaW5hdGlvbgwNZWdnX3N0b3JlX3NldA0UZWdnX2F1ZGlvX3BsYXlfc291bmQODWVnZ19kcmF3X3Rp
bGUPD2VnZ19yZW5kZXJfdGludBARX193YXNtX2NhbGxfY3RvcnMRCnN0YXJzX2luaXQSDHN0YXJzX3JlbmRlchMEcmFuZBQFc3Jh
bmQVCnNyYW5kX2F1dG8WD2VnZ19jbGllbnRfcXVpdBcPZWdnX2NsaWVudF9pbml0GBFlZ2dfY2xpZW50X3VwZGF0ZRkKZmlyZV9s
YXNlchoRZWdnX2NsaWVudF9yZW5kZXIHEgEAD19fc3RhY2tfcG9pbnRlcgkRAgAHLnJvZGF0YQEFLmRhdGEAOAlwcm9kdWNlcnMB
DHByb2Nlc3NlZC1ieQEMVWJ1bnR1IGNsYW5nETE0LjAuMC0xdWJ1bnR1MS4x)t1r384(iVBORw0KGgoAAAANSUhEUgAAAFAAAAASCAYAAADM
gVnKAAADS0lEQVRYw9VYv2sUQRT+5jiWuxg2d0dYkMQtFJEzhbEUBAuxsLERIoKCTVohNvkb0mhhqV1ioZ3gHyA26TQp4oKCxeZs
lnh3WS7ccs1YnG8zOzdvdu8HIb5mZt578+bNt997u6yAJsFJKJsXfAFGTPaw60q/FgsA8KNVadoXenuF7LOQVtWTy/1I6HNdBoOK
dJwktV1/8v5l0TO+7zx6AQDlGeX8VgXnzbetjHH95mYGOM4+DoitqicBwATOcj8Sg0FFAoDjZO06aLocbK9trDz98Opge22DdKY1
zUs6u54/TrB7uG9kyb0HPySAjD3suvcBfP43AgAePtvKjKr0gnjEh3Q6QASSyeYdx/COY6g+NCfw1DnZHCdRwB0CqfqrogJlWs+K
gXsAOgDqBFBjH1jHZjr2ghjzTTfDONWnF5jZZSpBAo/EO47RWhj6qMwbZd1pDJWBNkaqrDOtAUBEwaL0mkciOAkzB3fbHdy6dENE
waIEAK95JHYP92WtUcdSdREHv3/iSu8ukouDql+Lk7DrVm4PLvdDb0/40aokVs03XZCOeh1npxLWmWcDEACiBTf14dhkK9upeuAf
/ysAn3Uc2oHdw46sNeoZW+VaCK80lwCAX4sTPxp9IbS18iUg23d+CQCYj1alCigBxvW45X4kWgunIKrgtaqedJxRFjpOIojJOuPU
NYEyjojgJJTddge1Rh3qCAAEGK1JR+uVpatwS3NpMirL1EM4/bRvWu4lojKRA4ubjyslAPj07gu67U5mBICd1x9TR11H66KfIrME
j4DjwBsyMRHEvLwynhQ8ABAAIKVMDxFCpMFIL4QQqk8Rnclu28/5m/z0nHV/U/7cPU352nLRY5f1TVJKyYGjbiY/XWd9WpbLcXZT
fnmg67lxcXSfvJz1WCPfgUU2mp6qCQzuYrqe01E8E1PyWGgTGzFMaz0//QGWxj1YvYDpQkIR3adIKXFlZwPSlGeRErcBy91Pj5N7
obEaKlM2nB9XjrY4eaXJxbLZTGWf17/TOUfpIg19Ev+iTd0Wq0jvOisp6wnqT4JLdhL/Ik2dK93zKmXbW/Es9P8DSIUZOE7TnZaB
RcE970Dn/o2xNfBJPx+oVLlPoGmBPkv5C0O6Pp5zjq8lAAAAAElFTkSuQmCC)t0r723(vu7uUAF8ACoAKlN0gABnUIAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAiA7FiCrGPz8/AYcRwoYshT8/PwGHDsWHLcQ/Pz8BiBHDiCrFPz8/AYYOxQmGLIU/PzeJEcSILcU/Pz8BiA7N
iCrGPz8/BYcshj8/N4ctxj8/PwWHDwmIKsQ/Pz8FhSyIPz8/AYctxz8/PIcPhokqRT8/PwGHEoGGLAU/Pz8Bhw+Fhy1EPz8/AYkS
g4gqRD8/P4cPhQiGLAU/PziIEoQIhy1GPz84hw+MiCpHPz8/AYYsBj8/PwGHLUY/Pz8BiA/MiCpFPz8/AYYsBT8/PwGHLUQ/Pz+I
D4WIKcc/Pz8BiBKChyuGPz8/AYcPhYcsxT8/PwGIEoSIKcY/Pz8Bhw+EhSuFPz8/AYgSgweHLMc/PzmID4aIKcU/Pz6GK4cCiBKD
Pz8+hyzGAYcPhT8/PwGJEoSIKcY/Pz8BiA+FhSuFPz8+hSzIAogShD8/PwGIDoWHKcY/Pz8BhxGDhSuGPz8/AYcOhIcsxT8/PwGI
EYOHKcU/Pz+HDoSGK4U/Pz8BiBGEiCzHPz8/AYcOlIgpxj8/PwGFK4Y/Pz8BhizGPz8/AYcpxj8/PwGFK4Y/Pz8BhizEPz8/iA7F
hyrIPz8/AYcRw4YshD8/PwGHDsWGLcU/Pz8BiBHEiSrFPz8/AYcOxYYshT8/PwGIEcQFhy3GPz87iA7NiCrGPz8/AYYshT8/P4ct
xT8/PwGIDwmIKsU/Pz8BhSyEPz8/Aoctxj8/P4cPhokqRT8/PwGIEoOFLAU/Pz8Bhw+Ghy1FPz8/AYkShIgqRT8/P4cPhYYsBD8/
PwGIEoQBiC1GPz8/iA+LiCpFPz8/AYYsBT8/PwGHLUc/Pz8BiA/HiSpGPz8/AYYsBT8/PwGHLUM/Pz+IEIaIKcc/Pz8BhxODhyuG
Pz8/AYcQhYYsxj8/PwGIE4SJKcU/Pz8BhxCEhiuFPz8/AYgThIcsxj8/PwGHEIWIKcU/Pz8BhhODhiuGPz8/hhCFhizFPz8/AYgT
g4gpxj8/PwGHEIaGK4Y/Pz8BhxOEhyzGPz8/AYcQw4cpxT8/O4UrhwWHE8M/Pz8BiBDEhizFPz8/iRPEiCnGPz8/AYcQxYYrhT8/
PwGIE8GGLMY/Pz8BiBDFiCnGPz8/AYgTwoYrhj8/PwGHEMGHLMY/Pz8BiRPEiSnGPz8/AYgQxYYrhT8/P4gTw4csxT8/PwGIEYWI
KQc/Pz8BhhSEhyrFPz8/AYgRhIcsBj8/PwGIFISJKQY/Pz8BiBGFhyrFPz8/AYcUhIcsBj8/PwGJEUSHKQU/Pz+HFEOHKsU/Pz8B
hxFEhywGPz8/AYkURIkpBT8/PwGHEUWHKsU/Pz6HLAcCiBRDPz8/AYkQxYgpBT8/PwGHE8SHKsY/Pz8BhxDFhywGPz8/iRPEiCkF
Pz8/AYgQxYcqxT8/PogsBQKJE8M/Pz6IKQkEiA8EPz8+hyrFB4cSBD8/O4csBQSHDwc/PzqJKQcCiRIDPz8+iCrGB4cPAz8/NogS
BQKHLAU/Pz8IiRFFiCnGPz8/AYgUQ4crhj8/OYcRQ4YsxD8/PwGIFEKJKcc/Pz8BiBFFhiuHPz8/AYkURIcsxj8/PwGIEUaJKcY/
Pz+IFEOGK4Y/Pz8BiBFFiCzFPz8/AYkURIkpxj8/PwGGK4YCiBFGPz8+hxRDhCzIPz8/AYkQxYkpxj8/PwGHE8SHK4Y/Pz8BiBDF
hyzFPz8/iRPDiCnGPz8/AYgQxQaGK4c/PzqIE8SHLMY/Pz8BiRDUiCnFPz8/AYYrhj8/PwGGLMY/Pz8BiCnGPz8/AYYrhj8/P4cs
xD8/PwGIEYWIKQY/Pz8BhxSChyrFPz8/AYcRhoYsBj8/PwGIFISIKQU/Pz8BiBGFiCrEPz8/AYYUgwSHLAY/PzyIEUSIKQU/Pz+H
FEEFhirGPz87hxFFBYcsBT8/O4gURASIKQc/PzyIEUQFhyrGPz8/AYgUQ4YsBz8/NogQxQmIKQU/PzyHE8EEhyrFPz88hxDFA4cs
BT8/PIkTxASIKQY/PzyIEMYFiCrGPz87iRPDBIcsBz8/PIkPBASHKQg/PzyIEgGHKsY/Pz8Bhw8EiCwFPz8/AYgSBYgpBz8/PwGH
DwWHKsY/Pz+JEgSHLAc/Pz8BiA+GiCmHPz8/AYgShIcrRT8/PwGID4SHLIU/Pz8BiRKEiCmFPz8/AYcPhYcrRj8/PoYshgKHEoM/
Pz+HD4WIKYU/Pz8BhxKDA4YrRT8/PYYPhQOHLIU/Pz2JEoSHKYY/Pz8Bhw+FAoYrRj8/PocSgwKGLIU/Pz6IEIWHKYU/Pz8BiBOD
AocrRj8/PYcQhQOHLIc/Pz2IE4SIKYU/Pz8BhxCFA4YrRz8/PYgThIcshj8/PwGJEI6IKY4/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8F)t0r1e(6+sA
+gAzEAOEAQD6AZABAAADABn//wBkMzMAfQAA)r2d(6+sA+gAUHAGAAgAAAAIAMv//AMgAAAGQAQD6AfQBAAADADL//wCWIAAAMgAA)r1e(6+sB
fAAzFACAAwAAyAABAAADAFD//wBkGZkAyAAA)
</egg-rom>
<script>
/* Webgl.js
 * Adapter that exposes GLES2 to the Wasm client, and implements in a WebGL context.
 */
 
class Webgl {
  constructor(egg, gl) {
    this.egg = egg;
    this.gl = gl;
    this.o = ["neverZero"]; // GL objects (mixed types), indexed by ID. Can be sparse.
    this.nextId = 1;
    this.glstrp = 0; // Storage for glGetString, set by Render.js.
    this.glstra = 0;
    this.locv = ["neverZero"]; // Uniform locations. TODO We never remove them. Will that be a problem?
  }
  
  generatePublicApi() {
    return {
      // Anything with no pointers or object names converts trivially.
      glActiveTexture: (a) => this.gl.activeTexture(a),
      glBlendColor: (a,b,c,d) => this.gl.blendColor(a,b,c,d),
      glBlendEquation: (a) => this.gl.blendEquation(a),
      glBlendEquationSeparate: (a,b) => this.gl.blendEquationSeparate(a,b),
      glBlendFunc: (a,b) => this.gl.blendFunc(a,b),
      glBlendFuncSeparate: (a,b,c,d) => this.gl.blendFuncSeparate(a,b,c,d),
      glCheckFramebufferStatus: (a) => this.gl.checkFramebufferStatus(a),
      glClear: (a) => this.gl.clear(a),
      glClearColor: (a,b,c,d) => this.gl.clearColor(a,b,c,d),
      glClearDepthf: (a) => this.gl.clearDepth(a),
      glClearStencil: (a) => this.gl.clearStencil(a),
      glColorMask: (a,b,c,d) => this.gl.colorMask(a,b,c,d),
      glCullFace: (a) => this.gl.cullFace(a),
      glDepthFunc: (a) => this.gl.depthFunc(a),
      glDepthMask: (a) => this.gl.depthMask(a),
      glDepthRangef: (a,b) => this.gl.depthRangef(a,b),
      glDisable: (a) => this.gl.disable(a),
      glDisableVertexAttribArray: (a) => this.gl.disableVertexAttribArray(a),
      glDrawArrays: (a,b,c) => this.gl.drawArrays(a,b,c),
      glDrawElements: (a,b,c,d) => this.gl.drawElements(a,b,c,d),
      glEnable: (a) => this.gl.enable(a),
      glEnableVertexAttribArray: (a) => this.gl.enableVertexAttribArray(a),
      glFinish: () => this.gl.finish(),
      glFlush: () => this.gl.flush(),
      glFrontFace: (a) => this.gl.frontFace(a),
      glGenerateMipmap: (a) => this.gl.generateMipmap(a),
      glGetError: () => this.gl.getError(),
      glHint: (a,b) => this.gl.hint(a,b),
      glIsEnabled: (a) => this.gl.isEnabled(a),
      glLineWidth: (a) => this.gl.lineWidth(a),
      glPixelStorei: (a,b) => this.gl.pixelStore(a,b),
      glPolygonOffset: (a,b) => this.gl.polygonOffset(a,b),
      glReleaseShaderCompiler: () => this.gl.releaseShaderCompiler(),
      glRenderbufferStorage: (a,b,c,d) => this.gl.renderbufferStorage(a,b,c,d),
      glSampleCoverage: (a,b) => this.gl.sampleCoverage(a,b),
      glScissor: (a,b,c,d) => this.gl.scissor(a,b,c,d),
      glStencilFunc: (a,b,c) => this.gl.stencilFunc(a,b,c),
      glStencilFuncSeparate: (a,b,c,d) => this.gl.stencilFuncSeparate(a,b,c,d),
      glStencilMask: (a) => this.gl.stencilMask(a),
      glStencilMaskSeparate: (a,b) => this.gl.stencilMaskSeparate(a,b),
      glStencilOp: (a,b,c) => this.gl.stencilOp(a,b,c),
      glStencilOpSeparate: (a,b,c,d) => this.gl.stencilOpSeparate(a,b,c,d),
      glTexParameterf: (a,b,c) => this.gl.texParameterf(a,b,c),
      glTexParameteri: (a,b,c) => this.gl.texParameteri(a,b,c),
      glUniform1f: (a,b) => this.gl.uniform1f(this.locv[a],b),
      glUniform1i: (a,b) => this.gl.uniform1i(this.locv[a],b),
      glUniform2f: (a,b,c) => this.gl.uniform2f(this.locv[a],b,c),
      glUniform2i: (a,b,c) => this.gl.uniform2i(this.locv[a],b,c),
      glUniform3f: (a,b,c,d) => this.gl.uniform3f(this.locv[a],b,c,d),
      glUniform3i: (a,b,c,d) => this.gl.uniform3i(this.locv[a],b,c,d),
      glUniform4f: (a,b,c,d,e) => this.gl.uniform4f(this.locv[a],b,c,d,e),
      glUniform4i: (a,b,c,d,e) => this.gl.uniform4i(this.locv[a],b,c,d,e),
      glVertexAttrib1f: (a,b) => this.gl.vertexAttrib1f(a,b),
      glVertexAttrib2f: (a,b,c) => this.gl.vertexAttrib2f(a,b,c),
      glVertexAttrib3f: (a,b,c,d) => this.gl.vertexAttrib3f(a,b,c,d),
      glVertexAttrib4f: (a,b,c,d,e) => this.gl.vertexAttrib4f(a,b,c,d,e),
      glViewport: (a,b,c,d) => this.gl.viewport(a,b,c,d),
      // All the rest are a little more interesting:
      glAttachShader: (a,b) => this.glAttachShader(a,b),
      glBindAttribLocation: (a,b,c) => this.glBindAttribLocation(a,b,c),
      glBindBuffer: (a,b) => this.glBindBuffer(a,b),
      glBindFramebuffer: (a,b) => this.glBindFramebuffer(a,b),
      glBindRenderbuffer: (a,b) => this.glBindRenderbuffer(a,b),
      glBindTexture: (a,b) => this.glBindTexture(a,b),
      glBufferData: (a,b,c,d) => this.glBufferData(a,b,c,d),
      glBufferSubData: (a,b,c,d) => this.glBufferSubData(a,b,c,d),
      glCompileShader: (a) => this.glCompileShader(a),
      glCompressedTexImage2D: (a,b,c,d,e,f,g,h) => this.glCompressedTexImage2D(a,b,c,d,e,f,g,h),
      glCompressedTexSubImage2D: (a,b,c,d,e,f,g,h,i) => this.glCompressedTexSubImage2D(a,b,c,d,e,f,g,h,i),
      glCopyTexImage2D: (a,b,c,d,e,f,g,h) => this.glCopyTexImage2D(a,b,c,d,e,f,g,h),
      glCopyTexSubImage2D: (a,b,c,d,e,f,g,h) => this.glCopyTexSubImage2D(a,b,c,d,e,f,g,h),
      glCreateProgram: () => this.glCreateProgram(),
      glCreateShader: (a) => this.glCreateShader(a),
      glDeleteBuffers: (a,b) => this.glDeleteBuffers(a,b),
      glDeleteFramebuffers: (a,b) => this.glDeleteFramebuffers(a,b),
      glDeleteProgram: (a) => this.glDeleteProgram(a),
      glDeleteRenderbuffers: (a,b) => this.glDeleteRenderbuffers(a,b),
      glDeleteShader: (a) => this.glDeleteShader(a),
      glDeleteTextures: (a,b) => this.glDeleteTextures(a,b),
      glDetachShader: (a,b) => this.glDetachShader(a,b),
      glFramebufferRenderbuffer: (a,b,c,d) => this.glFramebufferRenderbuffer(a,b,c,d),
      glFramebufferTexture2D: (a,b,c,d,e) => this.glFramebufferTexture2D(a,b,c,d,e),
      glGenBuffers: (a,b) => this.glGenBuffers(a,b),
      glGenFramebuffers: (a,b) => this.glGenFramebuffers(a,b),
      glGenRenderbuffers: (a,b) => this.glGenRenderbuffers(a,b),
      glGenTextures: (a,b) => this.glGenTextures(a,b),
      glGetActiveAttrib: (a,b,c,d,e,f,g) => this.glGetActiveAttrib(a,b,c,d,e,f,g),
      glGetActiveUniform: (a,b,c,d,e,f,g) => this.glGetActiveUniform(a,b,c,d,e,f,g),
      glGetAttachedShaders: (a,b,c,d) => this.glGetAttachedShaders(a,b,c,d),
      glGetAttribLocation: (a,b) => this.glGetAttribLocation(a,b),
      glGetBooleanv: (a,b) => this.glGetBooleanv(a,b),
      glGetBufferParameteriv: (a,b,c) => this.glGetBufferParameteriv(a,b,c),
      glGetFloatv: (a,b) => this.glGetFloatv(a,b),
      glGetFramebufferAttachmentParameteriv: (a,b,c,d) => this.glGetFramebufferAttachmentParameteriv(a,b,c,d),
      glGetIntegerv: (a,b) => this.glGetIntegerv(a,b),
      glGetProgramiv: (a,b,c) => this.glGetProgramiv(a,b,c),
      glGetProgramInfoLog: (a,b,c,d) => this.glGetProgramInfoLog(a,b,c,d),
      glGetRenderbufferParameteriv: (a,b,c) => this.glGetRenderbufferParameteriv(a,b,c),
      glGetShaderiv: (a,b,c) => this.glGetShaderiv(a,b,c),
      glGetShaderInfoLog: (a,b,c,d) => this.glGetShaderInfoLog(a,b,c,d),
      glGetShaderPrecisionFormat: (a,b,c,d) => this.glGetShaderPrecisionFormat(a,b,c,d),
      glGetShaderSource: (a,b,c,d) => this.glGetShaderSource(a,b,c,d),
      glGetString: (a) => this.glGetString(a),
      glGetTexParameterfv: (a,b,c) => this.glGetTexParameterfv(a,b,c),
      glGetTexParameteriv: (a,b,c) => this.glGetTexParameteriv(a,b,c),
      glGetUniformfv: (a,b,c) => this.glGetUniformfv(a,b,c),
      glGetUniformiv: (a,b,c) => this.glGetUniformiv(a,b,c),
      glGetUniformLocation: (a,b) => this.glGetUniformLocation(a,b),
      glGetVertexAttribfv: (a,b,c) => this.glGetVertexAttribfv(a,b,c),
      glGetVertexAttribiv: (a,b,c) => this.glGetVertexAttribiv(a,b,c),
      glGetVertexAttribPointerv: (a,b,c) => this.glGetVertexAttribPointerv(a,b,c),
      glIsBuffer: (a) => this.glIsBuffer(a),
      glIsFramebuffer: (a) => this.glIsFramebuffer(a),
      glIsProgram: (a) => this.glIsProgram(a),
      glIsRenderbuffer: (a) => this.glIsRenderbuffer(a),
      glIsShader: (a) => this.glIsShader(a),
      glIsTexture: (a) => this.glIsTexture(a),
      glLinkProgram: (a) => this.glLinkProgram(a),
      glReadPixels: (a,b,c,d,e,f,g) => this.glReadPixels(a,b,c,d,e,f,g),
      glShaderBinary: (a,b,c,d,e) => this.glShaderBinary(a,b,c,d,e),
      glShaderSource: (a,b,c,d) => this.glShaderSource(a,b,c,d),
      glTexImage2D: (a,b,c,d,e,f,g,h,i) => this.glTexImage2D(a,b,c,d,e,f,g,h,i),
      glTexParameterfv: (a,b,c) => this.glTexParameterfv(a,b,c),
      glTexParameteriv: (a,b,c) => this.glTexParameteriv(a,b,c),
      glTexSubImage2D: (a,b,c,d,e,f,g,h,i) => this.glTexSubImage2D(a,b,c,d,e,f,g,h,i),
      glUniform1fv: (a,b,c) => this.glUniform1fv(a,b,c),
      glUniform1iv: (a,b,c) => this.glUniform1iv(a,b,c),
      glUniform2fv: (a,b,c) => this.glUniform2fv(a,b,c),
      glUniform2iv: (a,b,c) => this.glUniform2iv(a,b,c),
      glUniform3fv: (a,b,c) => this.glUniform3fv(a,b,c),
      glUniform3iv: (a,b,c) => this.glUniform3iv(a,b,c),
      glUniform4fv: (a,b,c) => this.glUniform4fv(a,b,c),
      glUniform4iv: (a,b,c) => this.glUniform4iv(a,b,c),
      glUniformMatrix2fv: (a,b,c,d) => this.glUniformMatrix2fv(a,b,c,d),
      glUniformMatrix3fv: (a,b,c,d) => this.glUniformMatrix3fv(a,b,c,d),
      glUniformMatrix4fv: (a,b,c,d) => this.glUniformMatrix4fv(a,b,c,d),
      glUseProgram: (a) => this.glUseProgram(a),
      glValidateProgram: (a) => this.glValidateProgram(a),
      glVertexAttrib1fv: (a,b) => this.glVertexAttrib1fv(a,b),
      glVertexAttrib2fv: (a,b) => this.glVertexAttrib2fv(a,b),
      glVertexAttrib3fv: (a,b) => this.glVertexAttrib3fv(a,b),
      glVertexAttrib4fv: (a,b) => this.glVertexAttrib4fv(a,b),
      glVertexAttribPointer: (a,b,c,d,e,f) => this.glVertexAttribPointer(a,b,c,d,e,f),
    };
  }
  
  /* Create and delete objects.
   **********************************************************/
   
  objAlloc() {
    const p = this.o.indexOf(null);
    if (p >= 0) return p;
    return this.nextId++;
  }
  
  objDel(id) {
    if (id < 1) return;
    this.o[id] = null;
  }

  glCreateProgram() {
    const id = this.objAlloc();
    if (!(this.o[id] = this.gl.createProgram())) return 0;
    return id;
  }

  glCreateShader(a) {
    const id = this.objAlloc();
    if (!(this.o[id] = this.gl.createShader(a))) return 0;
    return id;
  }

  glGenBuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.objAlloc();
      this.o[id] = this.gl.createBuffer();
      this.egg.exec.mem32[p] = id;
    }
  }

  glGenFramebuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.objAlloc();
      this.o[id] = this.gl.createFramebuffer();
      this.egg.exec.mem32[p] = id;
    }
  }

  glGenRenderbuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.objAlloc();
      this.o[id] = this.gl.createRenderbuffer();
      this.egg.exec.mem32[p] = id;
    }
  }

  glGenTextures(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.objAlloc();
      this.o[id] = this.gl.createTexture();
      this.egg.exec.mem32[p] = id;
    }
  }

  glDeleteBuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.egg.exec.mem32[p];
      this.gl.deleteBuffer(this.o[id]);
      this.objDel(id);
    }
  }

  glDeleteFramebuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.egg.exec.mem32[p];
      this.gl.deleteFramebuffer(this.o[id]);
      this.objDel(id);
    }
  }

  glDeleteProgram(a) {
    this.gl.deleteProgram(this.o[a]);
    this.objDel(a);
  }

  glDeleteRenderbuffers(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.egg.exec.mem32[p];
      this.gl.deleteRenderbuffer(this.o[id]);
      this.objDel(id);
    }
  }

  glDeleteShader(a) {
    this.gl.deleteShader(this.o[a]);
    this.objDel(a);
  }

  glDeleteTextures(a,b) {
    let p = b >> 2;
    for (; a-->0; p++) {
      const id = this.egg.exec.mem32[p];
      this.gl.deleteTexture(this.o[id]);
      this.objDel(id);
    }
  }

  glIsBuffer(a) {
    return this.gl.isBuffer(this.o[a]);
  }

  glIsFramebuffer(a) {
    return this.gl.isFramebuffer(this.o[a]);
  }

  glIsProgram(a) {
    return this.gl.isProgram(this.o[a]);
  }

  glIsRenderbuffer(a) {
    return this.gl.isRenderbuffer(this.o[a]);
  }

  glIsShader(a) {
    return this.gl.isShader(this.o[a]);
  }

  glIsTexture(a) {
    return this.gl.isTexture(this.o[a]);
  }
   
  /* Miscellaneous.
   ***********************************************************/
  
  glAttachShader(pid, sid) {
    this.gl.attachShader(this.o[pid], this.o[sid]);
  }

  glBindAttribLocation(pid, index, namep) {
    const program = this.o[pid];
    const name = this.egg.exec.readCString(namep);
    this.gl.bindAttribLocation(program, index, name);
  }

  glBindBuffer(target, id) {
    const buffer = this.o[id];
    this.gl.bindBuffer(target, buffer);
  }

  glBindFramebuffer(target, id) {
    const fb = this.o[id];
    this.gl.bindFramebuffer(target, fb);
  }

  glBindRenderbuffer(target, id) {
    const rb = this.o[id];
    this.gl.bindRenderbuffer(target, rb);
  }

  glBindTexture(target, id) {
    const texture = this.o[id];
    this.gl.bindTexture(target, texture);
  }

  glBufferData(target, size, datap, usage) {
    if (datap) {
      const data = this.egg.exec.getView(datap, size);
      if (!data) return;
      this.gl.bufferData(target, data, usage);
    } else {
      this.gl.bufferData(target, size, usage);
    }
  }

  glBufferSubData(target, offset, size, datap) {
    const data = this.egg.exec.getView(datap, size);
    if (!data) return;
    this.gl.bufferSubData(target, offset, data);
  }

  glCompileShader(id) {
    const shader = this.o[id];
    this.gl.compileShader(shader);
  }

  glDetachShader(pid, sid) {
    const program = this.o[pid];
    const shader = this.o[sid];
    this.gl.detachShader(program, shader);
  }

  glFramebufferRenderbuffer(target, attachment, rbtarget, rbid) {
    const rb = this.o[rbid];
    this.gl.framebufferRenderbuffer(target, attachment, rbtarget, rb);
  }

  glFramebufferTexture2D(target, attachment, textarget, texid, level) {
    const texture = this.o[texid];
    this.gl.framebufferTexture2D(target, attachment, textarget, texture, level);
  }

  glGetActiveAttrib(pid, index, bufsize, lenp, sizep, typep, namep) {
    const program = this.o[pid];
    const attr = this.gl.getActiveAttrib(program, index);
    if (!attr) return;
    if (sizep) this.egg.exec.mem32[sizep >> 2] = attr.size;
    if (typep) this.egg.exec.mem32[typep >> 2] = attr.type;
    if (namep && (bufsize > 0)) {
      this.egg.exec.safeWrite(namep, bufsize, attr.name);
    }
  }

  glGetActiveUniform(pid, index, bufsize, lenp, sizep, typep, namep) {
    const program = this.o[pid];
    const attr = this.gl.getActiveUniform(program, index);
    if (!attr) return;
    if (sizep) this.egg.exec.mem32[sizep >> 2] = attr.size;
    if (typep) this.egg.exec.mem32[typep >> 2] = attr.type;
    if (namep && (bufsize > 0)) {
      this.egg.exec.safeWrite(namep, bufsize, attr.name);
    }
  }

  glGetAttachedShaders(pid, max, countp, dstp) {
    const program = this.o[pid];
    const shaders = this.gl.getAttachedShaders(program) || [];
    if (countp) this.egg.exec.mem32[countp >> 2] = shaders.length;
    const cpc = Math.min(shaders.length, max);
    for (let i=0; i<cpc; i++, dstp+=4) {
      let id = this.o.indexOf(shaders[i]);
      if (id < 0) id = 0;
      this.egg.exec.mem32[dstp >> 2] = id;
    }
  }

  glGetAttribLocation(pid, namep) {
    const program = this.o[pid];
    const name = this.egg.exec.readCString(namep);
    return this.gl.getAttribLocation(program, name);
  }

  glGetProgramInfoLog(pid, bufsize, lenp, dstp) {
    const program = this.o[pid];
    const src = this.gl.getProgramInfoLog(program) || "";
    this.egg.exec.mem32[lenp >> 2] = this.egg.exec.safeWrite(dstp, bufsize, src);
  }

  glGetShaderInfoLog(sid, bufsize, lenp, dstp) {
    const shader = this.o[sid];
    const src = this.gl.getShaderInfoLog(shader) || "";
    this.egg.exec.mem32[lenp >> 2] = this.egg.exec.safeWrite(dstp, bufsize, src);
  }

  glGetShaderPrecisionFormat(stype, ptype, rangep, precp) {
    const rsp = this.gl.getShaderPrecisionFormat(stype, ptype);
    if (!rsp) return;
    rangep >>= 2;
    this.egg.exec.mem32[rangep++] = rsp.rangeMin;
    this.egg.exec.mem32[rangep] = rsp.rangeMax;
    this.egg.exec.mem32[precp >> 2] = rsp.precision;
  }

  glGetShaderSource(sid, bufsize, lenp, dstp) {
    const shader = this.o[sid];
    const src = this.gl.getShaderSource(shader) || "";
    this.egg.exec.mem32[lenp >> 2] = this.egg.exec.safeWrite(dstp, bufsize, src);
  }

  glGetUniformLocation(pid, namep) {
    const program = this.o[pid];
    const name = this.egg.exec.readCString(namep);
    const loc = this.gl.getUniformLocation(program, name);
    if (!loc) return 0;
    const id = this.locv.length;
    this.locv.push(loc);
    return id;
  }

  glLinkProgram(pid) {
    const program = this.o[pid];
    this.gl.linkProgram(program);
  }

  glShaderBinary(count, dstp, bfmt, src, srcc) {
    // GL_APICALL void GL_APIENTRY glShaderBinary (GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length);
    // Evidently there is no such thing in WebGL.
  }

  glShaderSource(sid, count, stringsp, lensp) {
    const shader = this.o[sid];
    let glsl = "";
    stringsp >>= 2;
    lensp >>= 2;
    for (let i=0; i<count; i++, stringsp++, lensp++) {
      const srcp = this.egg.exec.mem32[stringsp];
      const srcc = this.egg.exec.mem32[lensp];
      const sub = this.egg.exec.readLimitedString(srcp, srcc);
      glsl += sub;
    }
    this.gl.shaderSource(shader, glsl);
  }

  glUseProgram(a) {
    this.gl.useProgram(this.o[a]);
  }

  glValidateProgram(a) {
    this.gl.validateProgram(this.o[a]);
  }
  
  /* Generic parameters.
   ******************************************************************************/
   
  paramAsInts(src) {
    if (!src) return [0];
    if (typeof(src) === "number") return [~~src];
    const p = this.o.indexOf(src);
    if (p > 0) return [p];
    if (src.length) return src.map(v => ~~v);
    return [0];
  }
  
  paramAsFloats(src) {
    if (!src) return [0];
    if (typeof(src) === "number") return [src];
    if (src.length) return src;
    return [0];
  }
  
  paramAsString(src) {
    if (!src) return "";
    if (typeof(src) === "string") return src;
    return "";
  }

  glGetBooleanv(pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getParameter(pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetIntegerv(pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getParameter(pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetFloatv(pname, dstp) {
    const rsp = this.paramAsFloats(this.gl.getParameter(pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.memf32[dstp] = rsp[i];
    }
  }
  
  glGetString(pname) {
    const rsp = this.paramAsString(this.gl.getParameter(pname));
    this.egg.exec.safeWrite(this.glstrp, this.glstra, rsp + "\0");
    return this.glstrp;
  }

  glGetBufferParameteriv(target, pname, dstp) {
    // Every defined field is a single int.
    const rsp = this.gl.getBufferParameter(target, pname);
    this.egg.exec.mem32[dstp >> 2] = rsp;
  }

  glGetFramebufferAttachmentParameteriv(target, attachment, pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getFramebufferAttachmentParameter(target, attachment, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetProgramiv(pid, pname, dstp) {
    // Every defined field is a single int.
    const program = this.o[pid];
    const rsp = this.gl.getProgramParameter(program, pname);
    this.egg.exec.mem32[dstp >> 2] = rsp;
  }

  glGetRenderbufferParameteriv(target, pname, dstp) {
    // Every defined field is a single int.
    const rsp = this.gl.getRenderbufferParameter(target, pname);
    this.egg.exec.mem32[dstp >> 2] = rsp;
  }

  glGetShaderiv(sid, pname, dstp) {
    // Every defined field is a single int.
    const shader = this.o[sid];
    const rsp = this.gl.getShaderParameter(shader, pname);
    this.egg.exec.mem32[dstp >> 2] = rsp;
  }

  glGetTexParameterfv(target, pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getTexParameter(target, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.memf32[dstp] = rsp[i];
    }
  }

  glGetTexParameteriv(target, pname, dstp) {
    const rsp = this.paramAsFloats(this.gl.getTexParameter(target, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetUniformfv(pid, id, dstp) {
    const program = this.o[pid];
    const rsp = this.paramAsFloats(this.gl.getUniform(program, this.locv[id]));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.memf32[dstp] = rsp[i];
    }
  }

  glGetUniformiv(pid, id, dstp) {
    const program = this.o[pid];
    const rsp = this.paramAsInts(this.gl.getUniform(program, this.locv[id]));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetVertexAttribfv(index, pname, dstp) {
    const rsp = this.paramAsFloats(this.gl.getVertexAttrib(index, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.memf32[dstp] = rsp[i];
    }
  }

  glGetVertexAttribiv(index, pname, dstp) {
    const rsp = this.paramAsInts(this.gl.getVertexAttrib(index, pname));
    dstp >>= 2;
    for (let i=0; i<rsp.length; i++, dstp++) {
      this.egg.exec.mem32[dstp] = rsp[i];
    }
  }

  glGetVertexAttribPointerv(index, pname, dstp) {
    const offset = this.gl.getVertexAttribOffset(index, pname);
    this.egg.exec.mem32[dstp >> 2] = offset;
  }

  glTexParameterfv(target, pname, srcp) {
    // No defined texture field uses a vector.
    this.gl.texParameterf(target, pname, this.egg.exec.memf32[srcp >> 2]);
  }

  glTexParameteriv(target, pname, srcp) {
    // No defined texture field uses a vector.
    this.gl.texParameteri(target, pname, this.egg.exec.mem32[srcp >> 2]);
  }

  glUniform1fv(id, c, p) {
    this.gl.uniform1fv(this.locv[id], this.egg.exec.memf32.slice(p >> 2, c));
  }

  glUniform1iv(id, c, p) {
    this.gl.uniform1iv(this.locv[id], this.egg.exec.mem32.slice(p >> 2, c));
  }

  glUniform2fv(id, c, p) {
    this.gl.uniform2fv(this.locv[id], this.egg.exec.memf32.slice(p >> 2, c * 2)); 
  }

  glUniform2iv(id, c, p) {
    this.gl.uniform2iv(this.locv[id], this.egg.exec.mem32.slice(p >> 2, c * 2));
  }

  glUniform3fv(id, c, p) {
    this.gl.uniform3fv(this.locv[id], this.egg.exec.memf32.slice(p >> 2, c * 3)); 
  }

  glUniform3iv(id, c, p) {
    this.gl.uniform3iv(this.locv[id], this.egg.exec.mem32.slice(p >> 2, c * 3));
  }

  glUniform4fv(id, c, p) {
    this.gl.uniform4fv(this.locv[id], this.egg.exec.memf32.slice(p >> 2, c * 4)); 
  }

  glUniform4iv(id, c, p) {
    this.gl.uniform4iv(this.locv[id], this.egg.exec.mem32.slice(p >> 2, c * 4));
  }

  glUniformMatrix2fv(id, c, trans, p) {
    this.gl.uniformMatrix2fv(this.locv[id], trans, this.egg.exec.memf32.slice(p >> 2, c * 4));
  }

  glUniformMatrix3fv(id, c, trans, p) {
    this.gl.uniformMatrix3fv(this.locv[id], trans, this.egg.exec.memf32.slice(p >> 2, c * 9));
  }

  glUniformMatrix4fv(id, c, trans, p) {
    this.gl.uniformMatrix4fv(this.locv[id], trans, this.egg.exec.memf32.slice(p >> 2, c * 16));
  }

  glVertexAttrib1fv(index, p) {
    this.gl.vertexAttrib1fv(index, this.egg.exec.memf32.slice(p >> 2, 1));
  }

  glVertexAttrib2fv(index, p) {
    this.gl.vertexAttrib2fv(index, this.egg.exec.memf32.slice(p >> 2, 2));
  }

  glVertexAttrib3fv(index, p) {
    this.gl.vertexAttrib3fv(index, this.egg.exec.memf32.slice(p >> 2, 3));
  }

  glVertexAttrib4fv(index, p) {
    this.gl.vertexAttrib4fv(index, this.egg.exec.memf32.slice(p >> 2, 4));
  }

  glVertexAttribPointer(index, size, type, norm, stride, p) {
    //TODO WebGL (p) is an offset in the bound vbo. GLES2 it can be an absolute pointer in client memory.
    this.gl.vertexAttribPointer(index, size, type, norm, stride, p);
  }
  
  /* Image operations.
   ****************************************************************************/
   
  measureImage(w, h, fmt, type) {
    if ((w < 1) || (w > 4096)) return 0;
    if ((h < 1) || (h > 4096)) return 0;
    let chanc = 0;
    switch (fmt) {
      case this.gl.STENCIL_INDEX8:
      case this.gl.DEPTH_COMPONENT:
      case this.gl.LUMINANCE:
      case this.gl.ALPHA: chanc=1; break;
      case this.gl.LUMINANCE_ALPHA: chanc=2; break;
      case this.gl.RGB: chanc=3; break;
      case this.gl.RGBA: chanc=4; break;
    }
    if (chanc < 1) return 0;
    let wordlen = 0;
    switch (type) {
      case this.gl.UNSIGNED_BYTE:
      case this.gl.BYTE:
        wordlen=1;
        break;
      case this.gl.UNSIGNED_SHORT:
      case this.gl.SHORT:
      case this.gl.UNSIGNED_SHORT_5_6_5:
      case this.gl.UNSIGNED_SHORT_4_4_4_4:
      case this.gl.UNSIGNED_SHORT_5_5_5_1:
        wordlen=2;
        break;
      case this.gl.UNSIGNED_INT:
      case this.gl.INT:
      case this.gl.FLOAT:
        wordlen=4;
        break;
    }
    if (wordlen < 1) return 0;
    return wordlen * chanc * w * h;
  }

  glCompressedTexImage2D(target, level, ifmt, w, h, border, size, srcp) {
    const src = this.egg.exec.getView(srcp, size);
    if (!src) return;
    this.gl.compressedTexImage2D(target, level, ifmt, w, h, border, src);
  }

  glCompressedTexSubImage2D(target, level, xo, yo, w, h, fmt, size, srcp) {
    const src = this.egg.exec.getView(srcp, size);
    if (!src) return;
    this.gl.compressedTexImage2D(target, level, xo, yo, w, h, fmt, src);
  }

  glCopyTexImage2D(target, level, ifmt, x, y, w, h, border) {
    this.gl.copyTexImage2D(target, level, ifmt, x, y, w, h, border);
  }

  glCopyTexSubImage2D(target, level, xo, yo, x, y, w, h) {
    this.gl.copyTexSubImage2D(target, level, xo, yo, x, y, w, h);
  }

  glReadPixels(x, y, w, h, fmt, type, dstp) {
    const len = this.measureImage(w, h, fmt, type);
    if (len < 1) return;
    const dst = this.egg.exec.getView(dstp, len);
    if (!dst) return;
    this.gl.readPixels(x, y, w, h, fmt, type, dst);
  }

  glTexImage2D(target, level, ifmt, w, h, border, fmt, type, srcp) {
    const len = this.measureImage(w, h, fmt, type);
    if (len < 1) return;
    const src = this.egg.exec.getView(srcp, len);
    if (!src) return;
    this.gl.texImage2D(target, level, ifmt, w, h, border, fmt, type, src);
  }

  glTexSubImage2D(target, level, xo, yo, w, h, fmt, type, srcp) {
    const len = this.measureImage(w, h, fmt, type);
    if (len < 1) return;
    const src = this.egg.exec.getView(srcp, len);
    if (!src) return;
    this.gl.texSubImage2D(target, level, xo, yo, w, h, fmt, type, src);
  }

}
class Rom {
  constructor(src) {
    this.resv = []; // {tid,qual,rid,v:Uint8Array}, sorted
    this.decode(src);
  }
  
  getRes(tid, qual, rid) {
    let lo=0, hi=this.resv.length;
    while (lo < hi) {
      const ck = (lo + hi) >> 1;
      const q = this.resv[ck];
           if (tid < q.tid) hi = ck;
      else if (tid > q.tid) lo = ck + 1;
      else if (qual < q.qual) hi = ck;
      else if (qual > q.qual) lo = ck + 1;
      else if (rid < q.rid) hi = ck;
      else if (rid > q.rid) lo = ck + 1;
      else return q.v;
    }
    return this.empty;
  }
  
  decode(src) {
    let tid=1, qual=0, rid=1, i=0;
    const rdch = () => {
      let ch;
      for (;;) {
        ch = src.charCodeAt(i++);
        if (ch > 0x20) return ch;
        if (i >= src.length) return 0;
      }
    };
    const rdn = () => {
      let n=0;
      while (i < src.length) {
        const ch = rdch();
        if (!ch) break;
        if ((ch >= 0x30) && (ch <= 0x39)) { n <<= 4; n |= ch - 0x30; continue; }
        if ((ch >= 0x61) && (ch <= 0x66)) { n <<= 4; n |= ch - 0x61 + 10; continue; }
        if ((ch >= 0x41) && (ch <= 0x46)) { n <<= 4; n |= ch - 0x41 + 10; continue; }
        i--;
        break;
      }
      return n;
    };
    while (i < src.length) {
      const cmd = rdch();
      if (!cmd) break;
      switch (cmd) {
        case 0x74: tid += rdn() + 1; qual = 0; rid = 1; break;
        case 0x71: qual += rdn() + 1; rid = 1; break;
        case 0x73: rid += rdn() + 1; break;
        case 0x72: {
            if ((tid > 0x63) || (qual > 0x3ff) || (rid > 0xffff)) {
              throw new Error(`Invalid res id ${tid}:${qual}:${rid} around ${i}/${src.length} in ROM`);
            }
            const len = rdn();
            const body = new Uint8Array(len);
            let bodyp = 0;
            if (rdch() !== 0x28) throw new Error(`Expected '(' around ${i}/${src.length} in ROM`);
            const buf = [];
            for (;;) {
              const ch = rdch();
              if (ch === 0x29) break;
              if (!ch) throw new Error(`Unclosed resource body`);
                   if ((ch >= 0x41) && (ch <= 0x5a)) buf.push(ch - 0x41);
              else if ((ch >= 0x61) && (ch <= 0x7a)) buf.push(ch - 0x61 + 26);
              else if ((ch >= 0x30) && (ch <= 0x39)) buf.push(ch - 0x30 + 52);
              else if (ch === 0x2b) buf.push(62);
              else if (ch === 0x2f) buf.push(63);
              else throw new Error(`Expected ')' or base64 digit, found ${ch} (${i}/${src.length})`);
              if (buf.length >= 4) {
                body[bodyp++] = (buf[0] << 2) | (buf[1] >> 4);
                body[bodyp++] = (buf[1] << 4) | (buf[2] >> 2);
                body[bodyp++] = (buf[2] << 6) | buf[3];
                buf.splice(0, 4);
              }
            }
            body[bodyp++] = (buf[0] << 2) | (buf[1] >> 4);
            body[bodyp++] = (buf[1] << 4) | (buf[2] >> 2);
            body[bodyp++] = (buf[2] << 6) | buf[3];
            this.resv.push({ tid, qual, rid, v: body });
            rid++;
          } break;
        default: throw new Error(`Unexpected command '${cmd}' around ${i-1}/${src.length} in ROM`);
      }
    }
  }
}

Rom.RESTYPE_metadata = 1;
Rom.RESTYPE_wasm = 2;
Rom.RESTYPE_string = 3;
Rom.RESTYPE_image = 4;
Rom.RESTYPE_song = 5;
Rom.RESTYPE_sound = 6;
/* SfgPrinter.js
 * Produce PCM dumps from our tiny binary sound format.
 *
 * Unlike our C counterpart, we run completely synchronously.
 * That's because in WebAudio you don't get intimate access to the signal generator,
 * what we use to time and pay out printing in C.
 * Printing is not trivial. There's a real possibility of missing video frames due to sound effects being printed.
 *
 * It's written as a class to keep things flexible.
 * But typical usage is a one-shot kind of deal:
 *   const myPcm = new SfgPrinter(serial).print();
 * Uint8Array in, Float32Array out.
 */
 
class SfgPrinter {
  constructor(src, rate) {
    if (!(src instanceof Uint8Array)) throw new Error(`Expected Uint8Array`);
    if (!rate || (rate < 200) || (rate > 200000)) throw new Error(`Invalid rate for SfgPrinter`);
    this.src = src;
    this.rate = rate;
    this.dst = null; // Float32Array
  }
  
  print() {
    if (!this.dst) this._print();
    return this.dst;
  }
  
  /* Private below this point.
   */
  
  _print() {
    if (this.src.length < 6) throw new Error(`Invalid SFG`);
    if ((this.src[0] !== 0xeb) || (this.src[1] !== 0xeb)) throw new Error("Invalid SFG");
    const durms = (this.src[2] << 8) | this.src[3];
    const durframes = Math.max(1, Math.round(durms * this.rate / 1000));
    const master = this.src[4] + this.src[5] / 256.0;
    this.dst = new Float32Array(durframes);
    const tmp = new Float32Array(durframes);
    // Add one voice at a time to (this.dst).
    // Unlike the C implementation, we're synchronous, so we kind of process everything as we read it.
    for (let srcp=6; srcp<this.src.length; ) {
      const np = this._printVoice(tmp, srcp);
      if (!np || (np <= srcp)) throw new Error(`PCM print stalled at ${srcp}/${this.src.length}`);
      srcp = np;
      for (let i=durframes; i-->0; ) this.dst[i] += tmp[i];
    }
    // Apply master level.
    for (let i=durframes; i-->0; ) this.dst[i] *= master;
  }
  
  // Overwrite (dst), and return new (srcp).
  _printVoice(dst, srcp) {
    const waveSizeBits = 10;
    const waveSizeSamples = 1 << waveSizeBits;

    const features = this.src[srcp++];
    
    let wave = null; // Float32Array(waveSizeSamples) | "noise" | "silence"
    if (features & 0x01) { // shape
      switch (this.src[srcp++]) {
        case 0: wave = this._printSine(waveSizeSamples); break;
        case 1: wave = this._printSquare(waveSizeSamples); break;
        case 2: wave = this._printSawup(waveSizeSamples); break;
        case 3: wave = this._printSawdown(waveSizeSamples); break;
        case 4: wave = this._printTriangle(waveSizeSamples); break;
        case 5: wave = "noise"; break;
        case 6: wave = "silence"; break;
        default: throw new Error(`Unknown wave shape ${this.src[srcp-1]}`);
      }
    } else {
      wave = this._printSine(waveSizeSamples);
    }
    
    if (features & 0x02) { // harmonics
      const coefc = this.src[srcp++];
      if (wave instanceof Float32Array) {
        const nwave = new Float32Array(waveSizeSamples);
        for (let step=1; step<=coefc; step++) {
          this._printHarmonic(nwave, wave, step, this.src[srcp++] / 255.0);
        }
        wave = nwave;
      } else {
        // harmonics is meaningless for noise or silence, but it is technically legal. skip it.
        srcp += coefc;
      }
    }
    
    let fmrate = 0;
    let fmscale = 0;
    if (features & 0x04) { // fm
      fmrate = this.src[srcp] + this.src[srcp+1] / 256.0; srcp += 2;
      fmscale = this.src[srcp] + this.src[srcp+1] / 256.0; srcp += 2;
      fmrate *= Math.PI * 2;
    }
    
    const fmrange = {};
    if (features & 0x08) { // fmenv
      srcp = this._decodeEnv(fmrange, srcp, fmscale / 65535.0);
    } else {
      this._constantEnv(fmrange, fmscale);
    }
    
    const rate = {};
    if (features & 0x10) { // rate
      srcp = this._decodeEnv(rate, srcp, 1 / this.rate);
    } else {
      this._constantEnv(rate, 440 / this.rate);
    }
    
    let ratelforate = 0;
    let ratelfodepth = 0;
    if (features & 0x20) { // ratelfo
      const rate = this.src[srcp] + this.src[srcp+1] / 256.0; srcp += 2; // hz
      const depth = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2; // cents
      ratelforate = (rate * Math.PI * 2) / this.rate; // radians/frame
      ratelfodepth = depth / 1200; // power of 2
    }
    
    if (features & 0xc0) throw new Error(`Unknown features (0x${(features & 0xc0).toString(16)}) in voice`);
    
    /* We now have everything we need for the oscillator.
     * Run it to completion, overwriting (dst).
     */
    if (wave === "silence") {
      for (let i=dst.length; i-->0; ) dst[i] = 0;
    } else if (wave === "noise") {
      for (let i=dst.length; i-->0; ) dst[i] = Math.random() * 2 - 1;
    } else { //TODO Opportunities here to run simpler oscillators, eg if rate LFO or FM not in play. See sfg_update.c
      this._oscillateFull(
        dst, wave, rate, ratelforate, ratelfodepth, fmrate, fmrange
      );
    }
    
    /* Process all positional operations individually.
     */
    while (srcp < this.src.length) {
      const opcode = this.src[srcp++];
      if (!opcode) break; // End Of Voice
      switch (opcode) {
        case 0x01: srcp = this._printOpLevel(dst, srcp); break;
        case 0x02: srcp = this._printOpGain(dst, srcp); break;
        case 0x03: srcp = this._printOpClip(dst, srcp); break;
        case 0x04: srcp = this._printOpDelay(dst, srcp); break;
        case 0x05: srcp = this._printOpBandpass(dst, srcp); break;
        case 0x06: srcp = this._printOpNotch(dst, srcp); break;
        case 0x07: srcp = this._printOpLopass(dst, srcp); break;
        case 0x08: srcp = this._printOpHipass(dst, srcp); break;
        default: throw new Error(`Unknown voice op ${opcode}`);
      }
    }
  
    return srcp;
  }
  
  /* Oscillator.
   */
   
  _oscillateFull(dst, wave, rate, ratelforate, ratelfodepth, fmrate, fmrange) {
    for (let i=0, ratelfop=0, modp=0, carp=0; i<dst.length; i++) {
  
      // Acquire carrier rate.
      let crate = this._updateEnv(rate);
      crate *= Math.pow(2, Math.sin(ratelfop) * ratelfodepth);
      ratelfop += ratelforate;
      if (ratelfop >= Math.PI) ratelfop -= Math.PI * 2;
    
      // Acquire modulation.
      let mod = Math.sin(modp);
      mod *= this._updateEnv(fmrange);
      modp += crate * fmrate;
      if (modp >= Math.PI) modp -= Math.PI * 2;
    
      // Acquire sample and advance carrier.
      const sp = Math.floor(carp * wave.length);
      dst[i] = wave[sp] || 0;
      crate += crate * mod;
      carp += crate;
      while (carp >= 1) carp -= 1;
      while (carp < 0) carp += 1;
    }
  }
  
  /* Positional ops.
   * These all read from (this.src) and return the new position.
   */
  
  _printOpLevel(dst, srcp) {
    const env = {};
    srcp = this._decodeEnv(env, srcp, 1 / 65535.0);
    let lo=dst[0], hi=dst[0];
    for (let i=dst.length; i-->0; ) {
      if (dst[i]<lo) lo=dst[i];
      else if (dst[i]>hi) hi=dst[i];
    }
    for (let i=0; i<dst.length; i++) {
      dst[i] *= this._updateEnv(env);
    }
    return srcp;
  }
  
  _printOpGain(dst, srcp) {
    const gain = this.src[srcp] + this.src[srcp+1] / 256.0; srcp += 2;
    for (let i=dst.length; i-->0; ) {
      dst[i] *= gain;
    }
    return srcp;
  }
  
  _printOpClip(dst, srcp) {
    const hi = this.src[srcp++] / 255.0;
    const lo = -hi;
    for (let i=dst.length; i-->0; ) {
      const v = dst[i];
      if (v > hi) dst[i] = hi;
      else if (v < lo) dst[i] = lo;
    }
    return srcp;
  }
  
  _printOpDelay(dst, srcp) {
    const ms = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2;
    const period = Math.ceil((ms * this.rate) / 1000);
    if (isNaN(period) || (period < 1)) return srcp + 4;
    const buf = new Float32Array(period);
    let bufp = 0;
    const dry = this.src[srcp++] / 255.0;
    const wet = this.src[srcp++] / 255.0;
    const sto = this.src[srcp++] / 255.0;
    const fbk = this.src[srcp++] / 255.0;
    for (let i=0; i<dst.length; i++) {
      const next = dst[i];
      const prev = buf[bufp];
      dst[i] = next * dry + prev * wet;
      buf[bufp] = next * sto + prev * fbk;
      if (++bufp >= period) bufp = 0;
    }
    return srcp;
  }
  
  _printOpBandpass(dst, srcp) {
    const mid = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const wid = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const r = 1 - 3 * wid;
    const cosfreq = Math.cos(Math.PI * 2 * mid);
    const k = (1 - 2 * r * cosfreq + r * r) / (2 - 2 * cosfreq);
    const coefv = [
      1 - k,
      2 * (k - r) * cosfreq,
      r * r - k,
      2 * r * cosfreq,
      -r * r,
    ];
    this._applyIir(dst, coefv);
    return srcp;
  }
  
  _printOpNotch(dst, srcp) {
    const mid = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const wid = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const r = 1 - 3 * wid;
    const cosfreq = Math.cos(Math.PI * 2 * mid);
    const k = (1 - 2 * r * cosfreq + r * r) / (2 - 2 * cosfreq);
    const coefv = [
      k,
      -2 * k * cosfreq,
      k,
      2 * r * cosfreq,
      -r * r,
    ];
    this._applyIir(dst, coefv);
    return srcp;
  }
  
  _printOpLopass(dst, srcp) {
    const freq = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const rp = -Math.cos(Math.PI / 2);
    const ip = Math.sin(Math.PI / 2);
    const t = 2 * Math.tan(0.5);
    const w = 2 * Math.PI * freq;
    const m = rp * rp + ip * ip;
    const d = 4 - 4 * rp * t + m * t * t;
    const x0 = (t * t) / d;
    const x1 = (2 * t * t) / d;
    const x2 = (t * t) / d;
    const y1 = (8 - 2 * m * t * t) / d;
    const y2 = (-4 - 4 * rp * t - m * t * t) / d;
    const k = Math.sin(0.5 - w / 2) / Math.sin(0.5 + w / 2);
    const coefv = [
      (x0 - x1 * k + x2 * k * k) / d,
      (-2 * x0 * k + x1 + x1 * k * k - 2 * x2 * k) / d,
      (x0 * k * k - x1 * k + x2) / d,
      (2 * k + y1 + y1 * k * k - 2 * y2 * k) / d,
      (-k * k - y1 * k + y2) / d,
    ];
    this._applyIir(dst, coefv);
    return srcp;
  }
  
  _printOpHipass(dst, srcp) {
    const freq = ((this.src[srcp] << 8) | this.src[srcp+1]) / this.rate; srcp += 2;
    const rp = -Math.cos(Math.PI / 2);
    const ip = Math.sin(Math.PI / 2);
    const t = 2 * Math.tan(0.5);
    const w = 2 * Math.PI * freq;
    const m = rp * rp + ip * ip;
    const d = 4 - 4 * rp * t + m * t * t;
    const x0 = (t * t) / d;
    const x1 = (2 * t * t) / d;
    const x2 = (t * t) / d;
    const y1 = (8 - 2 * m * t * t) / d;
    const y2 = (-4 - 4 * rp * t - m * t * t) / d;
    const k = -Math.cos(w / 2 + 0.5) / Math.cos(w / 2 - 0.5);
    const coefv = [
      -(x0 - x1 * k + x2 * k * k) / d,
      (-2 * x0 * k + x1 + x1 * k * k - 2 * x2 * k) / d,
      (x0 * k * k - x1 * k + x2) / d,
      -(2 * k + y1 + y1 * k * k - 2 * y2 * k) / d,
      (-k * k - y1 * k + y2) / d,
    ];
    this._applyIir(dst, coefv);
    return srcp;
  }
  
  _applyIir(dst, coefv) {
    const statev = [0, 0, 0, 0, 0];
    for (let i=0; i<dst.length; i++) {
      statev[2]=statev[1];
      statev[1]=statev[0];
      statev[0]=dst[i];
      dst[i]=(
        statev[0]*coefv[0]+
        statev[1]*coefv[1]+
        statev[2]*coefv[2]+
        statev[3]*coefv[3]+
        statev[4]*coefv[4]
      );
      statev[4]=statev[3];
      statev[3]=dst[i];
    }
  }
  
  /* Envelopes.
   * Decode into a blank object.
   * Values are in 0..65535 if you don't scale. (eg 1/65535 to normalize)
   */
   
  _decodeEnv(env, srcp, scale) {
    env.v0 = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2;
    env.v0 *= scale;
    const pointc = this.src[srcp++];
    if (isNaN(pointc) || (srcp > this.src.length - pointc * 4)) throw new Error(`Envelope overruns EOF`);
    env.pointv = [];
    for (let i=pointc; i-->0; ) {
      const ms = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2;
      const t = Math.max(1, Math.round(ms * this.rate / 1000));
      let v = (this.src[srcp] << 8) | this.src[srcp+1]; srcp += 2;
      v *= scale;
      env.pointv.push({ t, v });
    }
    env.pointp = 0;
    env.v = env.v0;
    if (pointc > 0) {
      env.ttl = env.pointv[0].t;
      env.dv = (env.pointv[0].v - env.v) / env.ttl;
    } else {
      env.ttl = 0x7fffffff;
      env.dv = 0;
    }
    return srcp;
  }
  
  _constantEnv(env, k) {
    env.v0 = k;
    env.v = k;
    env.ttl = 0x7fffffff;
    env.dv = 0;
    env.pointv = [];
    env.pointp = 0;
  }
  
  _updateEnv(env) {
    if (env.ttl-- > 0) {
      env.v += env.dv;
    } else {
      env.pointp++;
      if (env.pointp >= env.pointv.length) {
        env.pointp = env.pointv.length;
        env.dv = 0;
        env.ttl = 0x7fffffff;
        if (env.pointv.length) env.v = env.pointv[env.pointv.length-1].v;
        else env.v = env.v0;
      } else {
        env.v = env.pointv[env.pointp-1].v;
        env.ttl = env.pointv[env.pointp].t;
        env.dv = (env.pointv[env.pointp].v - env.v) / env.ttl;
      }
    }
    return env.v;
  }
  
  /* Wave generators.
   */
          
  _printSine(len) {
    const dst = new Float32Array(len);
    for (let i=0, p=0, dp=Math.PI*2/len; i<dst.length; i++, p+=dp) {
      dst[i] = Math.sin(p);
    }
    return dst;
  }
  
  _printSquare(len) {
    const dst = new Float32Array(len);
    const halflen = len >> 1;
    for (let i=halflen; i-->0; ) dst[i] = 1;
    for (let i=halflen; i<dst.length; i++) dst[i] = -1;
    return dst;
  }
  
  _printSawup(len) {
    const dst = new Float32Array(len);
    for (let i=0, p=-1, dp=2/len; i<dst.length; i++, p+=dp) {
      dst[i] = p;
    }
    return dst;
  }
  
  _printSawdown(len) {
    const dst = new Float32Array(len);
    for (let i=0, p=1, dp=-2/len; i<dst.length; i++, p+=dp) {
      dst[i] = p;
    }
    return dst;
  }
  
  _printTriangle(len) {
    const dst = new Float32Array(len);
    const halflen = len >> 1;
    for (let i=0, p=-1, dp=2/halflen; i<halflen; i++, p+=dp) {
      dst[i] = p;
    }
    for (let i=halflen, p=1, dp=-2/halflen; i<dst.length; i++, p+=dp) {
      dst[i] = p;
    }
    return dst;
  }
  
  _printHarmonic(dst, src, step, level) {
    if (level <= 0) return;
    for (let dstp=0, srcp=0; dstp<dst.length; dstp++, srcp+=step) {
      if (srcp >= src.length) srcp -= src.length;
      dst[dstp] += src[srcp] * level;
    }
  }
}
/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
// https://github.com/imaya/zlib.js
(function() {'use strict';var l=void 0,aa=window;function r(c,d){var a=c.split("."),b=aa;!(a[0]in b)&&b.execScript&&b.execScript("var "+a[0]);for(var e;a.length&&(e=a.shift());)!a.length&&d!==l?b[e]=d:b=b[e]?b[e]:b[e]={}};var t="undefined"!==typeof Uint8Array&&"undefined"!==typeof Uint16Array&&"undefined"!==typeof Uint32Array&&"undefined"!==typeof DataView;function v(c){var d=c.length,a=0,b=Number.POSITIVE_INFINITY,e,f,g,h,k,m,n,p,s,x;for(p=0;p<d;++p)c[p]>a&&(a=c[p]),c[p]<b&&(b=c[p]);e=1<<a;
f=new (t?Uint32Array:Array)(e);g=1;h=0;for(k=2;g<=a;){for(p=0;p<d;++p)if(c[p]===g){m=0;n=h;for(s=0;s<g;++s)m=m<<1|n&1,n>>=1;x=g<<16|p;for(s=m;s<e;s+=k)f[s]=x;++h}++g;h<<=1;k<<=1}return[f,a,b]};function w(c,d){this.g=[];this.h=32768;this.d=this.f=this.a=this.l=0;this.input=t?new Uint8Array(c):c;this.m=!1;this.i=y;this.r=!1;if(d||!(d={}))d.index&&(this.a=d.index),d.bufferSize&&(this.h=d.bufferSize),d.bufferType&&(this.i=d.bufferType),d.resize&&(this.r=d.resize);switch(this.i){case A:this.b=32768;
this.c=new (t?Uint8Array:Array)(32768+this.h+258);break;case y:this.b=0;this.c=new (t?Uint8Array:Array)(this.h);this.e=this.z;this.n=this.v;this.j=this.w;break;default:throw Error("invalid inflate mode");
}}var A=0,y=1,B={t:A,s:y};
w.prototype.k=function(){for(;!this.m;){var c=C(this,3);c&1&&(this.m=!0);c>>>=1;switch(c){case 0:var d=this.input,a=this.a,b=this.c,e=this.b,f=d.length,g=l,h=l,k=b.length,m=l;this.d=this.f=0;if(a+1>=f)throw Error("invalid uncompressed block header: LEN");g=d[a++]|d[a++]<<8;if(a+1>=f)throw Error("invalid uncompressed block header: NLEN");h=d[a++]|d[a++]<<8;if(g===~h)throw Error("invalid uncompressed block header: length verify");if(a+g>d.length)throw Error("input buffer is broken");switch(this.i){case A:for(;e+
g>b.length;){m=k-e;g-=m;if(t)b.set(d.subarray(a,a+m),e),e+=m,a+=m;else for(;m--;)b[e++]=d[a++];this.b=e;b=this.e();e=this.b}break;case y:for(;e+g>b.length;)b=this.e({p:2});break;default:throw Error("invalid inflate mode");}if(t)b.set(d.subarray(a,a+g),e),e+=g,a+=g;else for(;g--;)b[e++]=d[a++];this.a=a;this.b=e;this.c=b;break;case 1:this.j(ba,ca);break;case 2:for(var n=C(this,5)+257,p=C(this,5)+1,s=C(this,4)+4,x=new (t?Uint8Array:Array)(D.length),S=l,T=l,U=l,u=l,M=l,F=l,z=l,q=l,V=l,q=0;q<s;++q)x[D[q]]=
C(this,3);if(!t){q=s;for(s=x.length;q<s;++q)x[D[q]]=0}S=v(x);u=new (t?Uint8Array:Array)(n+p);q=0;for(V=n+p;q<V;)switch(M=E(this,S),M){case 16:for(z=3+C(this,2);z--;)u[q++]=F;break;case 17:for(z=3+C(this,3);z--;)u[q++]=0;F=0;break;case 18:for(z=11+C(this,7);z--;)u[q++]=0;F=0;break;default:F=u[q++]=M}T=t?v(u.subarray(0,n)):v(u.slice(0,n));U=t?v(u.subarray(n)):v(u.slice(n));this.j(T,U);break;default:throw Error("unknown BTYPE: "+c);}}return this.n()};
var G=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],D=t?new Uint16Array(G):G,H=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],I=t?new Uint16Array(H):H,J=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],K=t?new Uint8Array(J):J,L=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],da=t?new Uint16Array(L):L,ea=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,
13,13],N=t?new Uint8Array(ea):ea,O=new (t?Uint8Array:Array)(288),P,fa;P=0;for(fa=O.length;P<fa;++P)O[P]=143>=P?8:255>=P?9:279>=P?7:8;var ba=v(O),Q=new (t?Uint8Array:Array)(30),R,ga;R=0;for(ga=Q.length;R<ga;++R)Q[R]=5;var ca=v(Q);function C(c,d){for(var a=c.f,b=c.d,e=c.input,f=c.a,g=e.length,h;b<d;){if(f>=g)throw Error("input buffer is broken");a|=e[f++]<<b;b+=8}h=a&(1<<d)-1;c.f=a>>>d;c.d=b-d;c.a=f;return h}
function E(c,d){for(var a=c.f,b=c.d,e=c.input,f=c.a,g=e.length,h=d[0],k=d[1],m,n;b<k&&!(f>=g);)a|=e[f++]<<b,b+=8;m=h[a&(1<<k)-1];n=m>>>16;if(n>b)throw Error("invalid code length: "+n);c.f=a>>n;c.d=b-n;c.a=f;return m&65535}
w.prototype.j=function(c,d){var a=this.c,b=this.b;this.o=c;for(var e=a.length-258,f,g,h,k;256!==(f=E(this,c));)if(256>f)b>=e&&(this.b=b,a=this.e(),b=this.b),a[b++]=f;else{g=f-257;k=I[g];0<K[g]&&(k+=C(this,K[g]));f=E(this,d);h=da[f];0<N[f]&&(h+=C(this,N[f]));b>=e&&(this.b=b,a=this.e(),b=this.b);for(;k--;)a[b]=a[b++-h]}for(;8<=this.d;)this.d-=8,this.a--;this.b=b};
w.prototype.w=function(c,d){var a=this.c,b=this.b;this.o=c;for(var e=a.length,f,g,h,k;256!==(f=E(this,c));)if(256>f)b>=e&&(a=this.e(),e=a.length),a[b++]=f;else{g=f-257;k=I[g];0<K[g]&&(k+=C(this,K[g]));f=E(this,d);h=da[f];0<N[f]&&(h+=C(this,N[f]));b+k>e&&(a=this.e(),e=a.length);for(;k--;)a[b]=a[b++-h]}for(;8<=this.d;)this.d-=8,this.a--;this.b=b};
w.prototype.e=function(){var c=new (t?Uint8Array:Array)(this.b-32768),d=this.b-32768,a,b,e=this.c;if(t)c.set(e.subarray(32768,c.length));else{a=0;for(b=c.length;a<b;++a)c[a]=e[a+32768]}this.g.push(c);this.l+=c.length;if(t)e.set(e.subarray(d,d+32768));else for(a=0;32768>a;++a)e[a]=e[d+a];this.b=32768;return e};
w.prototype.z=function(c){var d,a=this.input.length/this.a+1|0,b,e,f,g=this.input,h=this.c;c&&("number"===typeof c.p&&(a=c.p),"number"===typeof c.u&&(a+=c.u));2>a?(b=(g.length-this.a)/this.o[2],f=258*(b/2)|0,e=f<h.length?h.length+f:h.length<<1):e=h.length*a;t?(d=new Uint8Array(e),d.set(h)):d=h;return this.c=d};
w.prototype.n=function(){var c=0,d=this.c,a=this.g,b,e=new (t?Uint8Array:Array)(this.l+(this.b-32768)),f,g,h,k;if(0===a.length)return t?this.c.subarray(32768,this.b):this.c.slice(32768,this.b);f=0;for(g=a.length;f<g;++f){b=a[f];h=0;for(k=b.length;h<k;++h)e[c++]=b[h]}f=32768;for(g=this.b;f<g;++f)e[c++]=d[f];this.g=[];return this.buffer=e};
w.prototype.v=function(){var c,d=this.b;t?this.r?(c=new Uint8Array(d),c.set(this.c.subarray(0,d))):c=this.c.subarray(0,d):(this.c.length>d&&(this.c.length=d),c=this.c);return this.buffer=c};function W(c,d){var a,b;this.input=c;this.a=0;if(d||!(d={}))d.index&&(this.a=d.index),d.verify&&(this.A=d.verify);a=c[this.a++];b=c[this.a++];switch(a&15){case ha:this.method=ha;break;default:throw Error("unsupported compression method");}if(0!==((a<<8)+b)%31)throw Error("invalid fcheck flag:"+((a<<8)+b)%31);if(b&32)throw Error("fdict flag is not supported");this.q=new w(c,{index:this.a,bufferSize:d.bufferSize,bufferType:d.bufferType,resize:d.resize})}
W.prototype.k=function(){var c=this.input,d,a;d=this.q.k();this.a=this.q.a;if(this.A){a=(c[this.a++]<<24|c[this.a++]<<16|c[this.a++]<<8|c[this.a++])>>>0;var b=d;if("string"===typeof b){var e=b.split(""),f,g;f=0;for(g=e.length;f<g;f++)e[f]=(e[f].charCodeAt(0)&255)>>>0;b=e}for(var h=1,k=0,m=b.length,n,p=0;0<m;){n=1024<m?1024:m;m-=n;do h+=b[p++],k+=h;while(--n);h%=65521;k%=65521}if(a!==(k<<16|h)>>>0)throw Error("invalid adler-32 checksum");}return d};var ha=8;r("Zlib.Inflate",W);r("Zlib.Inflate.prototype.decompress",W.prototype.k);var X={ADAPTIVE:B.s,BLOCK:B.t},Y,Z,$,ia;if(Object.keys)Y=Object.keys(X);else for(Z in Y=[],$=0,X)Y[$++]=Z;$=0;for(ia=Y.length;$<ia;++$)Z=Y[$],r("Zlib.Inflate.BufferType."+Z,X[Z]);}
).call(window);
/* Render.js
 */
 


 
class Render {
  constructor(egg) {
    this.canvas = egg.canvas;
    this.egg = egg;
    this.gl = this.canvas.getContext("webgl");
    this.webgl = new Webgl(this.egg, this.gl);
    
    // (texid) exposed to client is the index in this array, plus one.
    this.textures = []; // {texid,fbid,w,h,fmt}
  
    this.tint = 0;
    this.alpha = 1;
    this.tr = 0;
    this.tg = 0;
    this.tb = 0;
    this.ta = 0;
  
    this.pgm_raw = null;
    this.pgm_decal = null;
    this.pgm_tile = null;
  
    this.u_raw_screensize = 0;
    this.u_raw_alpha = 0;
    this.u_decal_screensize = 0;
    this.u_decal_sampler = 0;
    this.u_decal_alpha = 0;
    this.u_decal_tint = 0;
    this.u_tile_screensize = 0;
    this.u_tile_sampler = 0;
    this.u_tile_alpha = 0;
    this.u_tile_tint = 0;
    this.u_tile_pointsize = 0;
    
    // Storage for draw_rect, draw_decal, and draw_to_main.
    // Decal is larger, 4 vertices * 12 bytes each.
    this.vbuf = new ArrayBuffer(12 * 4);
    this.vbufu8 = new Uint8Array(this.vbuf);
    this.vbufs16 = new Int16Array(this.vbuf);
    this.vbuff32 = new Float32Array(this.vbuf);
    
    this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA);
    this.gl.enable(this.gl.BLEND);
    if (!(this.buffer = this.gl.createBuffer())) throw new Error(`Failed to create WebGL vertex buffer.`);
    
    if (
      (this.egg_texture_new() !== 1) ||
      (this.egg_texture_upload(1, this.canvas.width, this.canvas.height, this.canvas.width << 2, 1, 0, 0) < 0)
    ) throw new Error(`Failed to create main framebuffer.`);
    
    this.compileShaders();
    
    this.sizeDirty = false;
    this.resizeObserver = new ResizeObserver(e => this.sizeDirty = true);
    this.resizeObserver.observe(this.canvas);
  }
  
  /*---------------------------- Entry points for Egg platform ------------------------------*/
  
  // Notify that the runtime is shutting down.
  stop() {
    this.resizeObserver.disconnect();
    this.egg_draw_rect(1, 0, 0, this.canvas.width, this.canvas.height, 0x808080ff);
    this.end(true);
  }
  
  begin() {
    this.egg_render_tint(0x00000000);
    this.alpha = 1;
    if (this.sizeDirty) {
      this.sizeDirty = false;
      if (this.egg.directgl) {
        const bounds = this.canvas.getBoundingClientRect();
        this.canvas.width = bounds.width;
        this.canvas.height = bounds.height;
      }
    }
  }
  
  end(override) {
    if (this.egg.directgl && !override) return;
    const srctex = this.textures[0];
    if (!srctex) return;

    const dstx = 0, dsty = 0, dstw = this.canvas.width, dsth = this.canvas.height;
    const aposv = this.vbufs16;
    const tcv = this.vbuff32;
    aposv[ 0] = dstx;      aposv[ 1] = dsty;      tcv[ 1] = 0.0; tcv[ 2] = 1.0;
    aposv[ 6] = dstx;      aposv[ 7] = dsty+dsth; tcv[ 4] = 0.0; tcv[ 5] = 0.0;
    aposv[12] = dstx+dstw; aposv[13] = dsty;      tcv[ 7] = 1.0; tcv[ 8] = 1.0;
    aposv[18] = dstx+dstw; aposv[19] = dsty+dsth; tcv[10] = 1.0; tcv[11] = 0.0;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vbuf, this.gl.STREAM_DRAW);
    
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
    this.gl.useProgram(this.pgm_decal);
    this.gl.uniform2f(this.u_decal_screensize, this.canvas.width, this.canvas.height);
    this.gl.bindTexture(this.gl.TEXTURE_2D, srctex.texid);
    this.gl.uniform4f(this.u_decal_tint, 0.0, 0.0, 0.0, 0.0);
    this.gl.uniform1f(this.u_decal_alpha, 1.0);
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 12, 0);
    this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 12, 4);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  /*------------------------ Public API entry points ---------------------------------*/
  
  egg_video_set_string_buffer(vp, a) {
    this.webgl.glstrp = vp;
    this.webgl.glstra = a;
  }
  
  egg_video_get_size(wp, hp) {
    if (wp) this.egg.exec.mem32[wp >> 2] = this.canvas.width;
    if (hp) this.egg.exec.mem32[hp >> 2] = this.canvas.height;
  }
  
  egg_texture_del(texid) {
    if ((texid < 2) || (texid > this.textures.length)) return; // sic "<2". You can't delete the main framebuffer.
    const texture = this.textures[texid - 1];
    if (!texture) return;
    if (texture.texid) this.gl.deleteTexture(texture.texid);
    if (texture.fbid) this.gl.deleteFramebuffer(texture.fbid);
    this.textures[texid - 1] = null;
  }
  
  egg_texture_new() {
    const texture = {
      texid: this.gl.createTexture(),
      fbid: null,
      w: 0,
      h: 0,
      fmt: 0,
    };
    if (!texture.texid) return 0;
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture.texid);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
    const p = this.textures.indexOf(null);
    if (p >= 0) {
      this.textures[p] = texture;
      return p + 1;
    } else {
      this.textures.push(texture);
      return this.textures.length;
    }
  }
  
  egg_texture_get_header(wp, hp, fmtp, texid) {
    const texture = this.textures[texid - 1];
    if (!texture) return;
    if (wp) this.egg.exec.mem32[wp >> 2] = texture.w;
    if (hp) this.egg.exec.mem32[hp >> 2] = texture.h;
    if (fmtp) this.egg.exec.mem32[fmtp >> 2] = texture.fmt;
  }
  
  egg_texture_load_image(texid, qual, rid) {
    if ((texid < 2) || (texid > this.textures.length)) return -1;
    const texture = this.textures[texid - 1];
    if (!texture) return -1;
    const serial = this.egg.rom.getRes(Rom.RESTYPE_image, qual, rid);
    if (!serial || !serial.length) return -1;
    const image = this.egg.imageDecoder.decode(serial);
    if (!image) return -1;
    return this.loadTexture(texture, image);
  }
  
  egg_texture_upload(texid, w, h, stride, fmt, v, c) {
    if ((texid < 1) || (texid > this.textures.length)) return -1;
    const texture = this.textures[texid - 1];
    if (!texture) return -1;
    if (texid === 1) { // Allowed to upload to texid 1, but not allowed to resize it.
      if (texture.w && texture.h) {
        if ((w !== texture.w) || (h !== texture.h)) return -1;
      }
    }
    let mem = null;
    if (c) {
      if (!(mem = this.egg.exec.getView(v, c))) return -1;
    }
    return this.loadTexture(texture, {
      v: mem,
      w, h, stride, fmt,
    });
  }
  
  egg_texture_clear(texid) {
    const texture = this.textures[texid - 1];
    if (!texture) return;
    this.requireFramebuffer(texture);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.fbid);
    this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
  }
  
  egg_render_tint(tint) {
    this.tint = tint;
    this.tr = ((tint >> 24) & 0xff) / 255.0;
    this.tg = ((tint >> 16) & 0xff) / 255.0;
    this.tb = ((tint >> 8) & 0xff) / 255.0;
    this.ta = (tint & 0xff) / 255.0;
  }
  
  egg_render_alpha(a) {
    this.alpha = a / 255.0;
  }
  
  egg_draw_rect(dsttexid, x, y, w, h, rgba) {
    const texture = this.textures[dsttexid - 1];
    if (!texture) return;
    const r = (rgba >> 24) & 0xff;
    const g = (rgba >> 16) & 0xff;
    const b = (rgba >> 8) & 0xff;
    const a = rgba & 0xff;
    this.requireFramebuffer(texture);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.fbid);
    this.gl.useProgram(this.pgm_raw);
    this.gl.viewport(0, 0, texture.w, texture.h);
    this.gl.uniform2f(this.u_raw_screensize, texture.w, texture.h);
    this.gl.uniform1f(this.u_raw_alpha, this.alpha);
    
    const aposv = this.vbufs16;
    const colorv = this.vbufu8;
    aposv[ 0] = x;   aposv[ 1] = y;   colorv[ 4] = r; colorv[ 5] = g; colorv[ 6] = b; colorv[ 7] = a;
    aposv[ 4] = x;   aposv[ 5] = y+h; colorv[12] = r; colorv[13] = g; colorv[14] = b; colorv[15] = a;
    aposv[ 8] = x+w; aposv[ 9] = y;   colorv[20] = r; colorv[21] = g; colorv[22] = b; colorv[23] = a;
    aposv[12] = x+w; aposv[13] = y+h; colorv[28] = r; colorv[29] = g; colorv[30] = b; colorv[31] = a;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vbuf, this.gl.STREAM_DRAW);
    
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 8, 0);
    this.gl.vertexAttribPointer(1, 4, this.gl.UNSIGNED_BYTE, true, 8, 4);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  drawRaw(dsttexid, mode, v, c) {
    const texture = this.textures[dsttexid - 1];
    if (!texture) return;
    this.requireFramebuffer(texture);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.fbid);
    this.gl.useProgram(this.pgm_raw);
    this.gl.viewport(0, 0, texture.w, texture.h);
    this.gl.uniform2f(this.u_raw_screensize, texture.w, texture.h);
    this.gl.uniform1f(this.u_raw_alpha, this.alpha);
    
    const len = c * 8;
    const srcview = this.egg.exec.getView(v, len);
    if (!srcview) return;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, srcview, this.gl.STREAM_DRAW);
    
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 8, 0);
    this.gl.vertexAttribPointer(1, 4, this.gl.UNSIGNED_BYTE, true, 8, 4);
    this.gl.drawArrays(mode, 0, c);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  egg_draw_line(dsttexid, v, c) {
    this.drawRaw(dsttexid, this.gl.LINE_STRIP, v, c);
  }
  
  egg_draw_trig(dsttexid, v, c) {
    this.drawRaw(dsttexid, this.gl.TRIANGLE_STRIP, v, c);
  }
  
  egg_draw_decal(dsttexid, srctexid, dstx, dsty, srcx, srcy, w, h, xform) {
    if (dsttexid === srctexid) return;
    const dsttex = this.textures[dsttexid - 1];
    const srctex = this.textures[srctexid - 1];
    if (!dsttex || !srctex) return;
    this.requireFramebuffer(dsttex);
    
    let dstw = w, dsth = h;
    if (xform & 4) { // SWAP
      dstw = h;
      dsth = w;
    }
    const aposv = this.vbufs16;
    const tcv = this.vbuff32;
    aposv[ 0] = dstx;      aposv[ 1] = dsty;      tcv[ 1] = 0.0; tcv[ 2] = 0.0;
    aposv[ 6] = dstx;      aposv[ 7] = dsty+dsth; tcv[ 4] = 0.0; tcv[ 5] = 1.0;
    aposv[12] = dstx+dstw; aposv[13] = dsty;      tcv[ 7] = 1.0; tcv[ 8] = 0.0;
    aposv[18] = dstx+dstw; aposv[19] = dsty+dsth; tcv[10] = 1.0; tcv[11] = 1.0;
    if (xform & 4) { // SWAP
      for (let i=1; i<12; i+=3) {
        const tmp = tcv[i];
        tcv[i] = tcv[i + 1];
        tcv[i + 1] = tmp;
      }
    }
    if (xform & 1) { // XREV
      for (let i=1; i<12; i+=3) {
        tcv[i] = 1.0 - tcv[i];
      }
    }
    if (xform & 2) { // YREV
      for (let i=2; i<12; i+=3) {
        tcv[i] = 1.0 - tcv[i];
      }
    }
    const tx0 = srcx / srctex.w;
    const tx1 = w / srctex.w;
    const ty0 = srcy / srctex.h;
    const ty1 = h / srctex.h;
    for (let i=1; i<12; i+=3) {
      tcv[i] = tx0 + tx1 * tcv[i];
      tcv[i+1] = ty0 + ty1 * tcv[i+1];
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vbuf, this.gl.STREAM_DRAW);
    
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, dsttex.fbid);
    this.gl.viewport(0, 0, dsttex.w, dsttex.h);
    this.gl.useProgram(this.pgm_decal);
    this.gl.uniform2f(this.u_decal_screensize, dsttex.w, dsttex.h);
    this.gl.bindTexture(this.gl.TEXTURE_2D, srctex.texid);
    this.gl.uniform4f(this.u_decal_tint, this.tr, this.tg, this.tb, this.ta);
    this.gl.uniform1f(this.u_decal_alpha, this.alpha);
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 12, 0);
    this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 12, 4);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  egg_draw_decal_mode7(dsttexid, srctexid, dstx, dsty, srcx, srcy, w, h, rotation, xscale, yscale) {
    if (dsttexid === srctexid) return;
    const dsttex = this.textures[dsttexid - 1];
    const srctex = this.textures[srctexid - 1];
    if (!dsttex || !srctex) return;
    this.requireFramebuffer(dsttex);
    rotation /= 65536;
    xscale /= 65536;
    yscale /= 65536;
    
    const aposv = this.vbufs16;
    const tcv = this.vbuff32;
    const cost = Math.cos(-rotation);
    const sint = Math.sin(-rotation);
    const halfw = w * xscale * 0.5;
    const halfh = h * yscale * 0.5;
    const nwx = Math.round( cost * halfw + sint * halfh);
    const nwy = Math.round(-sint * halfw + cost * halfh);
    const swx = Math.round( cost * halfw - sint * halfh);
    const swy = Math.round(-sint * halfw - cost * halfh);
    aposv[ 0] = dstx - nwx; aposv[ 1] = dsty - nwy; tcv[ 1] = 0.0; tcv[ 2] = 0.0;
    aposv[ 6] = dstx - swx; aposv[ 7] = dsty - swy; tcv[ 4] = 0.0; tcv[ 5] = 1.0;
    aposv[12] = dstx + swx; aposv[13] = dsty + swy; tcv[ 7] = 1.0; tcv[ 8] = 0.0;
    aposv[18] = dstx + nwx; aposv[19] = dsty + nwy; tcv[10] = 1.0; tcv[11] = 1.0;
    const tx0 = (srcx + 0.5) / srctex.w;
    const tx1 = (w - 1) / srctex.w;
    const ty0 = (srcy + 0.5) / srctex.h;
    const ty1 = (h - 1) / srctex.h;
    for (let i=1; i<12; i+=3) {
      tcv[i] = tx0 + tx1 * tcv[i];
      tcv[i+1] = ty0 + ty1 * tcv[i+1];
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vbuf, this.gl.STREAM_DRAW);
    
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, dsttex.fbid);
    this.gl.viewport(0, 0, dsttex.w, dsttex.h);
    this.gl.useProgram(this.pgm_decal);
    this.gl.uniform2f(this.u_decal_screensize, dsttex.w, dsttex.h);
    this.gl.bindTexture(this.gl.TEXTURE_2D, srctex.texid);
    this.gl.uniform4f(this.u_decal_tint, this.tr, this.tg, this.tb, this.ta);
    this.gl.uniform1f(this.u_decal_alpha, this.alpha);
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 12, 0);
    this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 12, 4);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
  }
  
  egg_draw_tile(dsttexid, srctexid, v, c) {
    if (!v || (c < 1)) return;
    if (dsttexid === srctexid) return;
    const dsttex = this.textures[dsttexid - 1];
    const srctex = this.textures[srctexid - 1];
    if (!dsttex || !srctex) return;
    this.requireFramebuffer(dsttex);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, dsttex.fbid);
    this.gl.useProgram(this.pgm_tile);
    this.gl.viewport(0, 0, dsttex.w, dsttex.h);
    this.gl.uniform2f(this.u_tile_screensize, dsttex.w, dsttex.h);
    this.gl.bindTexture(this.gl.TEXTURE_2D, srctex.texid);
    
    const len = c * 6;
    const srcview = this.egg.exec.getView(v, len);
    if (!srcview) return;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, srcview, this.gl.STREAM_DRAW);
    
    this.gl.uniform4f(this.u_tile_tint, this.tr, this.tg, this.tb, this.ta);
    this.gl.uniform1f(this.u_tile_alpha, this.alpha);
    this.gl.uniform1f(this.u_tile_pointsize, srctex.w >> 4);
    this.gl.enableVertexAttribArray(0);
    this.gl.enableVertexAttribArray(1);
    this.gl.enableVertexAttribArray(2);
    this.gl.vertexAttribPointer(0, 2, this.gl.SHORT, false, 6, 0);
    this.gl.vertexAttribPointer(1, 1, this.gl.UNSIGNED_BYTE, false, 6, 4);
    this.gl.vertexAttribPointer(2, 1, this.gl.UNSIGNED_BYTE, false, 6, 5);
    this.gl.drawArrays(this.gl.POINTS, 0, c);
    this.gl.disableVertexAttribArray(0);
    this.gl.disableVertexAttribArray(1);
    this.gl.disableVertexAttribArray(2);
  }
  
  /*------------------------------ Private -----------------------------------*/
   
  /* (texture) is from our list.
   * (image) is {v,w,h,fmt,stride} where (v) is null or Uint8Array.
   */
  loadTexture(texture, image) {
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture.texid);
    let ifmt = this.gl.RGBA, fmt = this.gl.RGBA, type = this.gl.UNSIGNED_BYTE;
    switch (image.fmt) {
      case 1: break; // RGBA, already initted like that
      case 2: ifmt = this.gl.ALPHA; fmt = this.gl.ALPHA; break;
      case 3: image = this.expand1(image, 0x00000000, 0x000000ff); break; // a1
      default: return -1;
    }
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, ifmt, image.w, image.h, 0, fmt, type, image.v);
    texture.w = image.w;
    texture.h = image.h;
    texture.fmt = image.fmt;
    return 0;
  }
  
  // Return an RGBA image from something 1-bit.
  expand1(image, zero, one) {
    const dststride = image.w << 2;
    const dst = new Uint8Array(dststride * image.h);
    for (let dstp=0, srcp=0, yi=image.h; yi-->0; srcp+=image.stride) {
      for (let xi=image.w, srcmask=0x80, srcpp=srcp; xi-->0; ) {
        if (image.v[srcpp] & srcmask) {
          dst[dstp++] = one >> 24;
          dst[dstp++] = one >> 16;
          dst[dstp++] = one >> 8;
          dst[dstp++] = one;
        } else {
          dst[dstp++] = zero >> 24;
          dst[dstp++] = zero >> 16;
          dst[dstp++] = zero >> 8;
          dst[dstp++] = zero;
        }
        if (srcmask === 1) { srcmask = 0x80; srcpp++; }
        else srcmask >>= 1;
      }
    }
    return {
      v: dst,
      w: image.w,
      h: image.h,
      fmt: 1, // RGBA
      stride: dststride,
    };
  }
  
  requireFramebuffer(texture) {
    if (texture.fbid) return;
    if (!(texture.fbid = this.gl.createFramebuffer())) throw new Error(`Failed to create WebGL framebuffer object.`);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.fbid);
    this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, texture.texid, 0);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
  }
  
  compileShaders() {
  
    this.pgm_raw = this.compileShader("raw", Render.vsrc_raw, Render.fsrc_raw);
    this.gl.useProgram(this.pgm_raw);
    this.u_raw_screensize = this.gl.getUniformLocation(this.pgm_raw, "screensize");
    this.u_raw_alpha = this.gl.getUniformLocation(this.pgm_raw, "alpha");
    this.gl.bindAttribLocation(this.pgm_raw, 0, "apos");
    this.gl.bindAttribLocation(this.pgm_raw, 1, "acolor");
  
    this.pgm_decal = this.compileShader("decal", Render.vsrc_decal, Render.fsrc_decal);
    this.gl.useProgram(this.pgm_decal);
    this.u_decal_screensize = this.gl.getUniformLocation(this.pgm_decal, "screensize");
    this.u_decal_sampler = this.gl.getUniformLocation(this.pgm_decal, "sampler");
    this.u_decal_alpha = this.gl.getUniformLocation(this.pgm_decal, "alpha");
    this.u_decal_tint = this.gl.getUniformLocation(this.pgm_decal, "tint");
    this.gl.bindAttribLocation(this.pgm_decal, 0, "apos");
    this.gl.bindAttribLocation(this.pgm_decal, 1, "atexcoord");
  
    this.pgm_tile = this.compileShader("tile", Render.vsrc_tile, Render.fsrc_tile);
    this.gl.useProgram(this.pgm_tile);
    this.u_tile_screensize = this.gl.getUniformLocation(this.pgm_tile, "screensize");
    this.u_tile_sampler = this.gl.getUniformLocation(this.pgm_tile, "sampler");
    this.u_tile_alpha = this.gl.getUniformLocation(this.pgm_tile, "alpha");
    this.u_tile_tint = this.gl.getUniformLocation(this.pgm_tile, "tint");
    this.u_tile_pointsize = this.gl.getUniformLocation(this.pgm_tile, "pointsize");
    this.gl.bindAttribLocation(this.pgm_tile, 0, "apos");
    this.gl.bindAttribLocation(this.pgm_tile, 1, "atileid");
    this.gl.bindAttribLocation(this.pgm_tile, 2, "axform");
  }
  
  compileShader(name, vsrc, fsrc) {
    const pid = this.gl.createProgram();
    if (!pid) throw new Error(`Failed to create new WebGL program for ${JSON.stringify(name)}`);
    try {
      this.compileShader1(name, pid, this.gl.VERTEX_SHADER, vsrc);
      this.compileShader1(name, pid, this.gl.FRAGMENT_SHADER, fsrc);
      this.gl.linkProgram(pid);
      if (!this.gl.getProgramParameter(pid, this.gl.LINK_STATUS)) {
        const log = this.gl.getProgramInfoLog(pid);
        throw new Error(`Failed to link program ${JSON.stringify(name)}:\n${log}`);
      }
    } catch (e) {
      this.gl.deleteProgram(pid);
      throw e;
    }
    return pid;
  }
  
  compileShader1(name, pid, type, src) {
    const sid = this.gl.createShader(type);
    if (!sid) throw new Error(`Failed to create new WebGL shader for ${JSON.stringify(name)}`);
    try {
      this.gl.shaderSource(sid, src);
      this.gl.compileShader(sid);
      if (!this.gl.getShaderParameter(sid, this.gl.COMPILE_STATUS)) {
        const log = this.gl.getShaderInfoLog(sid);
        throw new Error(`Failed to link ${(type === this.gl.VERTEX_SHADER) ? "vertex" : "fragment"} shader for ${JSON.stringify(name)}:\n${log}`);
      }
      this.gl.attachShader(pid, sid);
    } finally {
      this.gl.deleteShader(sid);
    }
  }
}

/* GLSL
 * TODO These need a minification strategy separate from the general Javascript one.
 ***********************************************************/
 
Render.vsrc_raw = `
  #version 100
  precision mediump float;
  uniform vec2 screensize;
  attribute vec2 apos;
  attribute vec4 acolor;
  varying vec4 vcolor;
  void main() {
    vec2 npos=(apos*2.0)/screensize-1.0;
    gl_Position=vec4(npos,0.0,1.0);
    vcolor=acolor;
  }
`;

Render.fsrc_raw = `
  #version 100
  precision mediump float;
  uniform float alpha;
  varying vec4 vcolor;
  void main() {
    gl_FragColor=vec4(vcolor.rgb,vcolor.a*alpha);
  }
`;
 
Render.vsrc_decal = `
  #version 100
  precision mediump float;
  uniform vec2 screensize;
  attribute vec2 apos;
  attribute vec2 atexcoord;
  varying vec2 vtexcoord;
  void main() {
    vec2 npos=(apos*2.0)/screensize-1.0;
    gl_Position=vec4(npos,0.0,1.0);
    vtexcoord=atexcoord;
  }
`;

Render.fsrc_decal = `
  #version 100
  precision mediump float;
  uniform sampler2D sampler;
  uniform float alpha;
  uniform vec4 tint;
  varying vec2 vtexcoord;
  void main() {
    gl_FragColor=texture2D(sampler,vtexcoord);
    gl_FragColor=vec4(mix(gl_FragColor.rgb,tint.rgb,tint.a),gl_FragColor.a*alpha);
  }
`;
 
Render.vsrc_tile = `
  #version 100
  precision mediump float;
  uniform vec2 screensize;
  uniform float pointsize;
  attribute vec2 apos;
  attribute float atileid;
  attribute float axform;
  varying vec2 vsrcp;
  varying mat2 vmat;
  void main() {
    vec2 npos=(apos*2.0)/screensize-1.0;
    gl_Position=vec4(npos,0.0,1.0);
    vsrcp=vec2(
      mod(atileid,16.0),
      floor(atileid/16.0)
    )/16.0;
         if (axform<0.5) vmat=mat2( 1.0, 0.0, 0.0, 1.0); // no xform
    else if (axform<1.5) vmat=mat2(-1.0, 0.0, 0.0, 1.0); // XREV
    else if (axform<2.5) vmat=mat2( 1.0, 0.0, 0.0,-1.0); // YREV
    else if (axform<3.5) vmat=mat2(-1.0, 0.0, 0.0,-1.0); // XREV|YREV
    else if (axform<4.5) vmat=mat2( 0.0, 1.0, 1.0, 0.0); // SWAP
    else if (axform<5.5) vmat=mat2( 0.0, 1.0,-1.0, 0.0); // SWAP|XREV
    else if (axform<6.5) vmat=mat2( 0.0,-1.0, 1.0, 0.0); // SWAP|YREV
    else if (axform<7.5) vmat=mat2( 0.0,-1.0,-1.0, 0.0); // SWAP|XREV|YREV
                    else vmat=mat2( 1.0, 0.0, 0.0, 1.0); // invalid; use identity
    gl_PointSize=pointsize;
  }
`;

Render.fsrc_tile = `
  #version 100
  precision mediump float;
  uniform sampler2D sampler;
  uniform float alpha;
  uniform vec4 tint;
  varying vec2 vsrcp;
  varying mat2 vmat;
  void main() {
    vec2 texcoord=gl_PointCoord;
    texcoord.y=1.0-texcoord.y;
    texcoord=vmat*(texcoord-0.5)+0.5;
    texcoord=vsrcp+texcoord/16.0;
    gl_FragColor=texture2D(sampler,texcoord);
    gl_FragColor=vec4(mix(gl_FragColor.rgb,tint.rgb,tint.a),gl_FragColor.a*alpha);
  }
`;
/* Exec.js
 * Owns the WebAssembly context.
 */
 

 
class Exec {
  constructor(egg) {
    this.egg = egg;
    if (!window.WebAssembly) throw new Error("WebAssembly not supported");
    this.textDecoder = new TextDecoder("utf8");
    this.textEncoder = new TextEncoder("utf8");
    this.memory = null;
    this.egg_client_quit = () => {};
    this.egg_client_init = () => -1;
    this.egg_client_update = () => {};
    this.egg_client_render = () => {};
    this.mem8 = null;
    this.mem32 = null;
    this.memf64 = null;
    this.fntab = null;
  }
  
  load() {
    const serial = this.egg.rom.getRes(Rom.RESTYPE_wasm, 0, 1);
    const options = { env: {
      egg_log: (f, v) => this.egg.egg_log(f, v),
      egg_time_real: () => Date.now() / 1000,
      egg_time_local: (v, a) => this.egg.egg_time_local(v, a),
      egg_request_termination: () => this.egg.stop(),
      egg_get_user_languages: (v, a) => this.egg.egg_get_user_languages(v, a),
      egg_video_set_string_buffer: (v, a) => this.egg.render.egg_video_set_string_buffer(v, a),
      egg_video_get_size: (wp, hp) => this.egg.render.egg_video_get_size(wp, hp),
      egg_texture_del: (texid) => this.egg.render.egg_texture_del(texid),
      egg_texture_new: () => this.egg.render.egg_texture_new(),
      egg_texture_get_header: (w, h, fmt, texid) => this.egg.render.egg_texture_get_header(w, h, fmt, texid),
      egg_texture_load_image: (texid, qual, rid) => this.egg.render.egg_texture_load_image(texid, qual, rid),
      egg_texture_upload: (texid, w, h, stride, fmt, v, c) => this.egg.render.egg_texture_upload(texid, w, h, stride, fmt, v, c),
      egg_texture_clear: (texid) => this.egg.render.egg_texture_clear(texid),
      egg_render_tint: (rgba) => this.egg.render.egg_render_tint(rgba),
      egg_render_alpha: (a) => this.egg.render.egg_render_alpha(a),
      egg_draw_rect: (dt, x, y, w, h, c) => this.egg.render.egg_draw_rect(dt, x, y, w, h, c),
      egg_draw_line: (dt, v, c) => this.egg.render.egg_draw_line(dt, v, c),
      egg_draw_trig: (dt, v, c) => this.egg.render.egg_draw_trig(dt, v, c),
      egg_draw_decal: (dt, st, dx, dy, sx, sy, w, h, xf) => this.egg.render.egg_draw_decal(dt, st, dx, dy, sx, sy, w, h, xf),
      egg_draw_decal_mode7: (dt, st, dx, dy, sx, sy, w, h, r, xs, ys) => this.egg.render.egg_draw_decal_mode7(dt, st, dx, dy, sx, sy, w, h, r, xs, ys),
      egg_draw_tile: (dt, st, v, c) => this.egg.render.egg_draw_tile(dt, st, v, c),
      egg_image_get_header: (wp, hp, sp, fp, qual, rid) => this.egg.data.egg_image_get_header(wp, hp, sp, fp, qual, rid),
      egg_image_decode: (v, a, qual, rid) => this.egg.data.egg_image_decode(v, a, qual, rid),
      egg_res_get: (v, a, tid, qual, rid) => this.egg.egg_res_get(v, a, tid, qual, rid),
      egg_res_for_each: (cb, ctx) => this.egg.egg_res_for_each(cb, ctx),
      egg_store_get: (v, a, k, kc) => this.egg.data.egg_store_get(v, a, k, kc),
      egg_store_set: (k, kc, v, vc) => this.egg.data.egg_store_set(k, kc, v, vc),
      egg_store_key_by_index: (v, a, p) => this.egg.data.egg_store_key_by_index(v, a, p),
      egg_event_get: (v, a) => this.egg.input.egg_event_get(v, a),
      egg_event_enable: (t, e) => this.egg.input.egg_event_enable(t, e),
      egg_show_cursor: (s) => this.egg.input.egg_show_cursor(s),
      egg_lock_cursor: (l) => this.egg.input.egg_lock_cursor(l),
      egg_joystick_devid_by_index: (p) => this.egg.input.egg_joystick_devid_by_index(p),
      egg_joystick_get_ids: (vid, pid, ver, devid) => this.egg.input.egg_joystick_get_ids(vid, pid, ver, devid),
      egg_joystick_get_name: (v, a, devid) => this.egg.input.egg_joystick_get_name(v, a, devid),
      egg_joystick_for_each_button: (devid, cb, ctx) => this.egg.input.egg_joystick_for_each_button(devid, cb, ctx),
      egg_audio_play_song: (qual, rid, f, r) => this.egg.audio.egg_audio_play_song(qual, rid, f, r),
      egg_audio_play_sound: (qual, rid, t, p) => this.egg.audio.egg_audio_play_sound(qual, rid, t, p),
      egg_audio_event: (c, o, a, b) => this.egg.audio.egg_audio_event(c, o, a, b),
      egg_audio_get_playhead: () => this.egg.audio.egg_audio_get_playhead(),
      egg_audio_set_playhead: (b) => this.egg.audio.egg_audio_set_playhead(b),
      ...this.egg.render.webgl.generatePublicApi(),
    }};
    return WebAssembly.instantiate(serial, options).then(result => {
      const yoink = name => {
        if (!result.instance.exports[name]) {
          throw new Error(`ROM does not export required symbol '${name}'`);
        }
        this[name] = result.instance.exports[name];
      };
      yoink("memory");
      yoink("egg_client_quit");
      yoink("egg_client_init");
      yoink("egg_client_update");
      yoink("egg_client_render");
      this.mem8 = new Uint8Array(this.memory.buffer);
      this.mem32 = new Uint32Array(this.memory.buffer);
      this.memf64 = new Float64Array(this.memory.buffer);
      this.fntab = result.instance.exports.__indirect_function_table;
    });
  }
  
  readCString(p) {
    let z = p;
    while (this.mem8[z]) z++;
    return this.textDecoder.decode(this.mem8.slice(p, z));
  }
  
  readLimitedString(p, limit) {
    let z = p;
    while (this.mem8[z] && (limit-- > 0)) z++;
    return this.textDecoder.decode(this.mem8.slice(p, z));
  }
  
  // (src) must be string or Uint8Array
  safeWrite(dst, dsta, src) {
    if (typeof(src) === "string") {
      src = this.textEncoder.encode(src);
    }
    const cpc = Math.min(dsta, src.length);
    if (cpc === src.length) {
      const dstview = new Uint8Array(this.memory.buffer, dst, cpc);
      dstview.set(src);
    } else if (cpc > 0) {
      const dstview = new Uint8Array(this.memory.buffer, dst, cpc);
      const srcview = new Uint8Array(src.buffer, src.byteOffset, cpc);
      dstview.set(srcview);
    }
    return src.length;
  }
  
  // Offset Uint8Array, or null if OOB
  getView(p, c) {
    if ((p < 0) || (c < 0) || (p > this.memory.buffer.byteLength - c)) return null;
    return new Uint8Array(this.memory.buffer, p, c);
  }
}
/* DataService.js
 * Coordinates higher-level services around resources,
 * and the persistent storage.
 */
 

 
class DataService {
  constructor(egg) {
    this.egg = egg;
    this.rom = egg.rom;
    this.metadata = null; // {k:v} strings
    this.masterKey = "store-" + this.getMetadata("title").substring(0, 32);
    try {
      this.store = JSON.parse(window.localStorage.getItem(this.masterKey));
      if (!this.store || (typeof(this.store) !== "object") || (this.store instanceof Array)) this.store = {};
    } catch (e) {
      this.store = {};
    }
    this.storeSaveTimeout = null;
  }
  
  getMetadata(k) {
    if (!this.metadata) this.metadata = this.decodeMetadata(this.rom.getRes(Rom.RESTYPE_metadata, 0, 1));
    // TODO Look for "*String", if we know the language.
    return this.metadata[k] || "";
  }
  
  decodeMetadata(src) {
    if ((src.length < 2) || (src[0] !== 0xee) || (src[1] !== 0x4d)) return {};
    const decoder = new TextDecoder("utf8");
    const dst = {};
    for (let srcp=2; srcp<src.length; ) {
      const kc = src[srcp++] || 0;
      const vc = src[srcp++] || 0;
      if (srcp > src.length - vc - kc) break;
      const k = decoder.decode(src.slice(srcp, srcp + kc));
      srcp += kc;
      const v = decoder.decode(src.slice(srcp, srcp + vc));
      srcp += vc;
      dst[k] = v;
    }
    return dst;
  }
  
  storeDirty() {
    /* This debounce shouldn't be long, in fact zero would probably be OK.
     * The idea is that if the game sets a whole bunch of fields in one update cycle, don't write them out more than once.
     * No matter what we do here, fields written by the game available to it for immediate readback.
     */
    const saveDebounceTimeMs = 500;
    if (!this.storeSaveTimeout) this.storeSaveTimeout = window.setTimeout(() => {
      this.storeSaveTimeout = null;
      window.localStorage.setItem(this.masterKey, JSON.stringify(this.store));
    }, saveDebounceTimeMs);
  }
  
  /*--------------------------- Public API entry points ---------------------------------*/
  
  egg_image_get_header(wp, hp, stridep, fmtp, qual, rid) {
    const serial = this.rom.getRes(Rom.RESTYPE_image, qual, rid);
    if (serial.length < 1) return;
    try {
      const header = this.egg.imageDecoder.decodeHeader(serial);
      this.egg.exec.mem32[wp >> 2] = header.w;
      this.egg.exec.mem32[hp >> 2] = header.h;
      this.egg.exec.mem32[stridep >> 2] = header.stride;
      this.egg.exec.mem32[fmtp >> 2] = header.fmt;
    } catch (e) {}
  }
  
  egg_image_decode(dst, dsta, qual, rid) {
    const serial = this.rom.getRes(Rom.RESTYPE_image, qual, rid);
    if (serial.length < 1) return -1;
    try {
      const image = this.egg.imageDecoder.decode(serial);
      return this.egg.exec.safeWrite(dst, dsta, image.v);
    } catch (e) {
      console.error(e);
      return -1;
    }
  }
  
  egg_store_get(dst, dsta, k, kc) {
    k = this.egg.exec.readLimitedString(k, kc);
    const v = this.store[k] || "";
    return this.egg.exec.safeWrite(dst, dsta, v);
  }
  
  egg_store_set(k, kc, v, vc) {
    k = this.egg.exec.readLimitedString(k, kc);
    v = this.egg.exec.readLimitedString(v, vc);
    if (!k) return -1;
    //TODO Access control.
    if (v) {
      if (this.store[k] === v) return 0;
      if (!this.store[k]) {
        //TODO Confirm length<256 when encoded UTF-8.
      }
      this.store[k] = v;
    } else {
      if (!this.store[k]) return 0;
      delete this.store[k];
    }
    this.storeDirty();
    return 0;
  }
  
  egg_store_key_by_index(dst, dsta, p) {
    const keys = Object.keys(this.store);
    return this.egg.exec.safeWrite(dst, dsta, keys[p] || "");
  }
}



function startEgg(rom) {
  const egg = new Egg(rom);
  egg.attachToDom();
  egg.start().then(() => {
  }).catch(displayError);
}

function displayError(error) {
  document.body.innerHTML = "";
  const element = document.createElement("DIV");
  document.body.appendChild(element);
  element.classList.add("error");
  console.error(error);
  if (typeof(error) === "string") {
    element.innerText = error;
  } else if (!error) {
    element.innerText = "Unspecified error.";
  } else if (error.stack) {
    element.innerText = error.stack;
  } else if (error.message) {
    element.innerText = error.message;
  } else {
    element.innerText = JSON.stringify(error, null, 2);
  }
}

window.addEventListener("load", () => {
  let rom;
  const emb = document.querySelector("egg-rom");
  if (emb) startEgg(new Rom(emb.innerText));
  else {
    window.fetch("/api/roms").then(rsp => {
      if (!rsp.ok) throw rsp;
      return rsp.json();
    }).then(roms => {
      //TODO Should stop here and present these options to the user.
      // But maybe just load it, if there's exactly one.
      return window.fetch(roms[0]);
    }).then(rsp => {
      if (rsp.status === 599) {
        return rsp.text().then(msg => { throw msg; });
      }
      if (!rsp.ok) throw rsp;
      return rsp.arrayBuffer();
    }).then(serial => {
      startEgg(new Rom(serial));
    }).catch(error => {
      displayError(error);
    });
  }
});
/* Input.js
 */
 
class Input {
  constructor(egg) {
    this.egg = egg;
    
    this.evtq = []; // Each member is an array of 2..5 ints.
    this.evtmask = 
      (1 << Input.EGG_EVENT_JOY) |
      (1 << Input.EGG_EVENT_KEY) |
      (1 << Input.EGG_EVENT_TOUCH)|
      // MMOTION, MBUTTON, MWHEEL, TEXT, ACCEL: off by default
    0;
    // TODO Turn off JOY, KEY, and TOUCH if we can tell they aren't supported.
    
    this.cursorVisible = false;
    this.cursorDesired = true; // Should be visible when enabled. (egg_show_cursor())
    this.mouseEventListener = null;
    this.mouseButtonsDown = new Set();
    this.mouseX = 0;
    this.mouseY = 0;
    this.mouseLocked = false;
    
    this.keyListener = e => this.onKey(e);
    window.addEventListener("keydown", this.keyListener);
    window.addEventListener("keyup", this.keyListener);
    
    this.gamepads = []; // sparse
    this.gamepadListener = e => this.onGamepadConnection(e);
    window.addEventListener("gamepadconnected", this.gamepadListener);
    window.addEventListener("gamepaddisconnected", this.gamepadListener);
    
    this.touchListener = null;
    
    this.accel = null;
    this.accelListener = null;
    
    this.canvasChanged();
  }
  
  canvasChanged() {
    const canvas = this.egg.canvas;
    if (this.touchListener && (this.canvas !== canvas)) {
      this.canvas.removeEventListener("touchstart", this.touchListener);
      this.canvas.removeEventListener("touchend", this.touchListener);
      this.canvas.removeEventListener("touchcancel", this.touchListener);
      this.canvas.removeEventListener("touchmove", this.touchListener);
      this.touchListener = null;
    }
    if (canvas) {
      this.canvas = canvas;
      if (!this.touchListener) {
        this.touchListener = e => this.onTouch(e);
        canvas.addEventListener("touchstart", this.touchListener);
        canvas.addEventListener("touchend", this.touchListener);
        canvas.addEventListener("touchcancel", this.touchListener);
        canvas.addEventListener("touchmove", this.touchListener);
      }
    }
  }
  
  detach() {
    this._unlistenMouse();
    if (this.keyListener) {
      window.removeEventListener("keydown", this.keyListener);
      window.removeEventListener("keyup", this.keyListener);
      this.keyListener = null;
    }
    if (this.gamepadListener) {
      window.removeEventListener("gamepadconnected", this.gamepadListener);
      window.removeEventListener("gamepaddisconnected", this.gamepadListener);
      this.gamepadListener = null;
    }
    if (this.touchListener) {
      this.canvas.removeEventListener("touchstart", this.touchListener);
      this.canvas.removeEventListener("touchend", this.touchListener);
      this.canvas.removeEventListener("touchcancel", this.touchListener);
      this.canvas.removeEventListener("touchmove", this.touchListener);
      this.touchListener = null;
    }
    if (this.accel) {
      if (this.accelListener) {
        this.accel.removeEventListener("reading", this.accelListener);
        this.accelListener = null;
      }
      this.accel.stop();
    }
  }
  
  update() {
    this._updateGamepads();
  }
  
  // (v) is an array of 2..5 integers; see egg_input.h
  pushEvent(v) {
    if (!(this.evtmask & (1 << v[0]))) return;
    this.evtq.push(v);
  }
  
  reset() {
    this.evtq = [];
    const initialMask =
      (1 << Input.EGG_EVENT_JOY) |
      (1 << Input.EGG_EVENT_KEY) |
      (1 << Input.EGG_EVENT_TOUCH)|
    0;
    if (initialMask !== this.evtmask) {
      for (let i=0; i<30; i++) {
        if ((initialMask & (1 << i)) !== (this.evtmask & (1 << i))) {
          this.event_enable(i, initialMask & (1 << i));
        }
      }
    }
  }
  
  /* Touch.
   ********************************************************************/
   
  onTouch(e) {
    if (!e.changedTouches) return;
    if (!this.canvas) return;
    const bounds = this.canvas.getBoundingClientRect();
    let state;
    switch (e.type) {
      case "touchstart": state = 1; break;
      case "touchend":
      case "touchcancel": state = 0; break;
      case "touchmove": state = 2; break;
    }
    for (const touch of e.changedTouches) {
      const x = ((touch.clientX - bounds.x) * this.canvas.width) / bounds.width;
      const y = ((touch.clientY - bounds.y) * this.canvas.height) / bounds.height;
      this.pushEvent([Input.EGG_EVENT_TOUCH, this.eggSafeTouchId(touch.identifier), state, x, y]);
    }
  }
  
  // The spec doesn't constain Touch.identifier beyond saying it must be an integer.
  // For Egg, it must be a *positive* integer. I've seen zero.
  eggSafeTouchId(id) {
    return (id < 1) ? ((id & 0x7fffffff) | 0x00001000) : id;
  }
  
  /* Gamepad.
   * We will use (gamepad.index+1) as (devid) for reporting to the client.
   ******************************************************************************/
   
  _updateGamepads() {
    if (!window.navigator.getGamepads) return;
    for (const gamepad of window.navigator.getGamepads()) {
      if (!gamepad) continue;
      const local = this.gamepads[gamepad.index];
      if (!local) continue;
      
      for (let i=local.axes.length; i-->0; ) {
        const pv = local.axes[i];
        const nx = gamepad.axes[i] ? Math.floor(gamepad.axes[i] * 127) : 0;
        if (pv === nx) continue;
        local.axes[i] = nx;
        this.pushEvent([Input.EGG_EVENT_JOY, local.devid, local.axisBase + i, nx]);
      }
      
      for (let i=local.buttons.length; i-->0; ) {
        const pv = local.buttons[i];
        const nx = gamepad.buttons[i].value;
        if (pv === nx) continue;
        local.buttons[i] = nx;
        this.pushEvent([Input.EGG_EVENT_JOY, local.devid, local.buttonBase + i, nx]);
      }
    }
  }
  
  onGamepadConnection(e) {
    switch (e.type) {
    
      case "gamepadconnected": {
          let axisBase, buttonBase;
          if (e.gamepad.mapping === "standard") {
            axisBase = 0x40;
            buttonBase = 0x80;
          } else {
            axisBase = 0x100;
            buttonBase = 0x200;
          }
          this.gamepads[e.gamepad.index] = {
            devid: e.gamepad.index + 1,
            index: e.gamepad.index,
            id: e.gamepad.id,
            axes: (e.gamepad.axes || []).map(v => v),
            buttons: (e.gamepad.buttons || []).map(v => 0),
            mapping: e.gamepad.mapping,
            axisBase,
            buttonBase,
          };
          this.pushEvent([Input.EGG_EVENT_JOY, e.gamepad.index + 1, 0, 1]);
        } break;
        
      case "gamepaddisconnected": {
          const local = this.gamepads[e.gamepad.index];
          if (local) {
            delete this.gamepads[e.gamepad.index];
            this.pushEvent([Input.EGG_EVENT_JOY, local.devid, 0, 0]);
          }
        } break;
    }
  }
  
  /* Mouse.
   ********************************************************************************/
  
  _checkCursorVisibility(show) {
    const enableEvents = show;
    if (this.cursorDesired) show = !!show;
    else show = false;
    if (show !== this.cursorVisible) {
      this.cursorVisible = show;
      if (this.canvas) {
        if (show) {
          this.canvas.style.cursor = "pointer";
        } else {
          this.canvas.style.cursor = "none";
        }
      }
    }
    if (enableEvents) {
      if (!this.mouseListener) {
        this._listenMouse();
      }
    } else {
      if (this.mouseListener) {
        this._unlistenMouse();
      }
    }
  }
  
  _listenMouse() {
    if (this.mouseEventListener) return;
    this.mouseEventListener = e => this.onMouseEvent(e);
    window.addEventListener("mousewheel", this.mouseEventListener);
    window.addEventListener("mousemove", this.mouseEventListener);
    window.addEventListener("mouseup", this.mouseEventListener);
    if (this.canvas) {
      this.canvas.addEventListener("mousedown", this.mouseEventListener);
      this.canvas.addEventListener("contextmenu", this.mouseEventListener);
    }
  }
  
  _unlistenMouse() {
    if (this.mouseEventListener) {
      window.removeEventListener("mousewheel", this.mouseEventListener);
      window.removeEventListener("mousemove", this.mouseEventListener);
      window.removeEventListener("mouseup", this.mouseEventListener);
      if (this.canvas) {
        this.canvas.removeEventListener("mousedown", this.mouseEventListener);
        this.canvas.removeEventListener("contextmenu", this.mouseEventListener);
      }
      this.mouseEventListener = null;
    }
  }
  
  onMouseEvent(e) {
    if (!this.canvas) return;
    const bounds = this.canvas.getBoundingClientRect();
    const x = Math.floor(((e.x - bounds.x) * this.canvas.width) / bounds.width);
    const y = Math.floor(((e.y - bounds.y) * this.canvas.height) / bounds.height);
    switch (e.type) {
      case "mousemove": {
          if (this.mouseLocked) {
            if (e.movementX || e.movementY) {
              this.pushEvent([Input.EGG_EVENT_MMOTION, e.movementX, e.movementY]);
            }
          } else {
            if ((x === this.mouseX) && (y === this.mouseY)) return;
            this.mouseX = x;
            this.mouseY = y;
            this.pushEvent([Input.EGG_EVENT_MMOTION, x, y]);
          }
        } break;
      case "mousedown": {
          if (e.target !== this.canvas) return;
          let button;
          switch (e.button) {
            case 0: button = Input.EGG_MBUTTON_LEFT; break;
            case 1: button = Input.EGG_MBUTTON_MIDDLE; break;
            case 2: button = Input.EGG_MBUTTON_RIGHT; break;
            default: button = e.button;
          }
          if (this.mouseButtonsDown.has(button)) return;
          this.mouseButtonsDown.add(button);
          e.preventDefault();
          this.pushEvent([Input.EGG_EVENT_MBUTTON, x, y, button, 1]);
        } break;
      case "mouseup": {
          let button;
          switch (e.button) {
            case 0: button = Input.EGG_MBUTTON_LEFT; break;
            case 1: button = Input.EGG_MBUTTON_MIDDLE; break;
            case 2: button = Input.EGG_MBUTTON_RIGHT; break;
            default: button = e.button;
          }
          if (!this.mouseButtonsDown.has(button)) return;
          this.mouseButtonsDown.delete(button);
          this.pushEvent([Input.EGG_EVENT_MBUTTON, x, y, button, 0]);
        } break;
      case "contextmenu": e.preventDefault(); break;
      case "mousewheel": {
          if ((x < 0) || (y < 0) || (x >= bounds.width) || (y >= bounds.height)) return;
          let dx = e.deltaX, dy = e.deltaY;
          if (e.wheelDeltaX) dx /= Math.abs(e.wheelDeltaX);
          if (e.wheelDeltaY) dy /= Math.abs(e.wheelDeltaY);
          if (e.wheelDelta && !e.wheelDeltaX && !e.wheelDeltaY) {
            dx /= Math.abs(e.wheelDelta);
            dy /= Math.abs(e.wheelDelta);
          }
          if (e.shiftKey) { // I like Shift+Wheel to mean X instead of Y.
            let tmp = dx;
            dx = dy;
            dy = tmp;
          }
          if (dx || dy) {
            this.pushEvent([Input.EGG_EVENT_MWHEEL, x, y, dx, dy]);
          }
          //event.preventDefault(); // It's installed as passive... why is that? (Chrome Linux)
        } break;
    }
  }
  
  /* Keyboard.
   **************************************************************************/
  
  onKey(e) {
    
    // Ignore all keyboard events when Alt or Ctrl is held.
    if (e.ctrlKey || e.altKey) {
      return;
    }
    
    // TODO We might be too heavy-handed with event suppression. Bear in mind that we are listening on Window.
    
    // If we recognize the key and user wants key events, pass it on and suppress it in browser.
    if (this.evtmask & (1 << Input.EGG_EVENT_KEY)) {
      const usage = this.hidUsageByKeyCode(e.code);
      if (usage) {
        const v = (e.type === "keyup") ? 0 : e.repeat ? 2 : 1;
        this.pushEvent([Input.EGG_EVENT_KEY, usage, v]);
        e.preventDefault();
        e.stopPropagation();
      }
    }
    
    // Likewise, if user wants text and it looks like text. (but not for "keyup" of course).
    if (e.type !== "keyup") {
      if (this.evtmask & (1 << Input.EGG_EVENT_TEXT)) {
        switch (e.key) {
          case "Backspace": this.pushEvent([Input.EGG_EVENT_TEXT, 0x08]); e.preventDefault(); e.stopPropagation(); break;
          case "Tab":       this.pushEvent([Input.EGG_EVENT_TEXT, 0x09]); e.preventDefault(); e.stopPropagation(); break;
          case "Enter":     this.pushEvent([Input.EGG_EVENT_TEXT, 0x0a]); e.preventDefault(); e.stopPropagation(); break;
          case "Escape":    this.pushEvent([Input.EGG_EVENT_TEXT, 0x1b]); e.preventDefault(); e.stopPropagation(); break;
          default: if (e.key?.length === 1) {
              this.pushEvent([Input.EGG_EVENT_TEXT, e.key.charCodeAt(0)]);
              e.preventDefault();
              e.stopPropagation();
            } break;
        }
      }
    }
  }
  
  hidUsageByKeyCode(code) {
    if (!code) return 0;
  
    // "KeyA".."KeyZ" => 0x04..0x1d
    if ((code.length === 4) && code.startsWith("Key")) {
      const ch = code.charCodeAt(3);
      if ((ch >= 0x41) && (ch <= 0x5a)) return 0x00070004 + ch - 0x41;
    }
    
    // "Digit1".."Digit9" => 0x1e..0x25, some jackass put "0" on the right side... why...
    if ((code.length === 6) && code.startsWith("Digit")) {
      const ch = code.charCodeAt(5);
      if ((ch >= 0x31) && (ch <= 0x39)) return 0x0007001e + ch - 0x31;
      if (ch === 0x30) return 0x00070027; // zero
    }
    
    // "F1".."F12" => 0x3a..0x45
    // "F13".."F24" => 0x68..0x73
    if (((code.length === 2) || (code.length === 3)) && (code[0] === 'F')) {
      const v = +code.substring(1);
      if ((v >= 1) && (v <= 12)) return 0x0007003a + v - 1;
      if ((v >= 13) && (v <= 24)) return 0x00070068 + v - 13;
    }
    
    // "Numpad1".."Numpad9" => 0x59..0x61, again with zero on top because Jesus hates me.
    if ((code.length === 7) && code.startsWith("Numpad")) {
      const v = +code[7];
      if ((v >= 1) && (v <= 9)) return 0x00070059 + v - 1;
      if (v === 0) return 0x00070062;
    }
    
    // And finally a not-too-crazy set of one-off names.
    switch (code) {
      case "Enter":          return 0x00070028;
      case "Escape":         return 0x00070029;
      case "Backspace":      return 0x0007002a;
      case "Tab":            return 0x0007002b;
      case "Space":          return 0x0007002c;
      case "Minus":          return 0x0007002d;
      case "Equal":          return 0x0007002e;
      case "BracketLeft":    return 0x0007002f;
      case "BracketRight":   return 0x00070039;
      case "Backslash":      return 0x00070031;
      case "Semicolon":      return 0x00070033;
      case "Quote":          return 0x00070034;
      case "Backquote":      return 0x00070035;
      case "Comma":          return 0x00070036;
      case "Period":         return 0x00070037;
      case "Slash":          return 0x00070038;
      case "CapsLock":       return 0x00070039;
      case "Pause":          return 0x00070048;
      case "Insert":         return 0x00070049;
      case "Home":           return 0x0007004a;
      case "PageUp":         return 0x0007004b;
      case "Delete":         return 0x0007004c;
      case "PageDown":       return 0x0007004e;
      case "ArrowRight":     return 0x0007004f;
      case "ArrowLeft":      return 0x00070050;
      case "ArrowDown":      return 0x00070051;
      case "ArrowUp":        return 0x00070052;
      case "NumLock":        return 0x00070053;
      case "NumpadDivide":   return 0x00070054;
      case "NumpadMultiply": return 0x00070055;
      case "NumpadSubtract": return 0x00070056;
      case "NumpadAdd":      return 0x00070057;
      case "NumpadEnter":    return 0x00070058;
      case "NumpadDecimal":  return 0x00070063;
      case "ContextMenu":    return 0x00070076;
      case "ShiftLeft":      return 0x000700e1;
      case "ShiftRight":     return 0x000700e5;
      case "ControlLeft":    return 0x000700e0;
      case "ControlRight":   return 0x000700e4;
      case "AltLeft":        return 0x000700e2;
      case "AltRight":       return 0x000700e6;
    }
    return 0;
  }
  
  /* Accelerometer.
   **************************************************************************/
   
  accelerometerEnable() {
    this._accelerometerEnableInternal().then(() => {
      if (!this.accelListener) {
        this.accelListener = () => this.onAccelerometer();
        this.accel.addEventListener("reading", this.accelListener);
      }
      this.accel.start();
    }).catch(() => {});
  }
  
  _accelerometerEnableInternal() {
    if (this.accel) return Promise.resolve();
    if (!window.navigator.permissions) return Promise.reject();
    return window.navigator.permissions.query({ name: "accelerometer" }).then(result => {
      if (result.state === "denied") throw null;
      if (!this.accel) {
        this.accel = new Accelerometer({ referenceFrame: "device", frequency: 60 });
      }
    });
  }
  
  accelerometerDisable() {
    if (!this.accel) return;
    if (this.accelListener) {
      this.accel.removeEventListener("reading", this.accelListener);
      this.accelListener = null;
    }
    this.accel.stop();
  }
  
  onAccelerometer() {
    if (!this.accel) return;
    const x = ~~(this.accel.x * 65536.0);
    const y = ~~(this.accel.y * 65536.0);
    const z = ~~(this.accel.z * 65536.0);
    this.pushEvent([Input.EGG_EVENT_ACCEL, x, y, z]);
  }
  
  /*--------------------------- Public API entry points -----------------------------------*/
  
  egg_event_get(v, a) {
    const eventSizeWords = 5;//TODO Can we assert that this is sizeof(union egg_event)/sizeof(int)?
    const cpc = Math.min(a, this.evtq.length);
    if (cpc < 1) return 0;
    let dst = this.egg.exec.mem32;
    let dstp = v >> 2;
    for (let i=0; i<cpc; i++) {
      const e = this.evtq[i];
      for (let j=0; j<eventSizeWords; j++) {
        dst[dstp++] = e[j];
      }
    }
    this.evtq.splice(0, cpc);
    return cpc;
  }
  
  egg_event_enable(type, enable) {
    if (!type) return 0;
    const bit = 1 << type;
    if (enable) {
      if (this.evtmask & bit) return 1;
      this.evtmask |= bit;
    } else {
      if (!(this.evtmask & bit)) return 0;
      this.evtmask &= ~bit;
    }
    //TODO Reject changes if we can tell they aren't supported.
    switch (type) {
      case Input.EGG_EVENT_RAW: break;
      case Input.EGG_EVENT_JOY: break;
      case Input.EGG_EVENT_KEY: break;
      case Input.EGG_EVENT_TEXT: break;
      case Input.EGG_EVENT_MMOTION:
      case Input.EGG_EVENT_MBUTTON:
      case Input.EGG_EVENT_MWHEEL: {
          const mouseEvents = (1 << Input.EGG_EVENT_MMOTION) | (1 << Input.EGG_EVENT_MBUTTON) | (1 << Input.EGG_EVENT_MWHEEL);
          this._checkCursorVisibility(this.evtmask & mouseEvents);
        } break;
      case Input.EGG_EVENT_TOUCH: break;
      case Input.EGG_EVENT_ACCEL: {
          if (enable) {
            this.accelerometerEnable();
          } else {
            this.accelerometerDisable();
          }
        } break;
    }
    return enable ? 1 : 0;
  }
  
  egg_show_cursor(show) {
    this.cursorDesired = !!show;
    const mouseEvents = (1 << Input.EGG_EVENT_MMOTION) | (1 << Input.EGG_EVENT_MBUTTON) | (1 << Input.EGG_EVENT_MWHEEL);
    this._checkCursorVisibility(this.evtmask & mouseEvents);
  }
  
  egg_lock_cursor(lock) {
    if (!this.canvas || !this.canvas.requestPointerLock) return 0;
    if (lock) {
      if (this.mouseLocked) return 1;
      this.mouseLocked = true;
      this.canvas.requestPointerLock(/*{
        unadjustedMovement: true, // Not supported in Chrome/Linux, and the whole request gets rejected for it.
      }*/).then(rsp => {
      }).catch(e => {
        this.mouseLocked = false;
      });
    } else if (this.mouseLocked) {
      this.mouseLocked = false;
      document.exitPointerLock();
    }
    return 1;
  }
  
  egg_joystick_devid_by_index(p) {
    if (p < 0) return 0;
    for (let i=0; i<this.gamepads.length; i++) {
      if (!this.gamepads[i]) continue;
      if (!p--) return i + 1;
    }
    return 0;
  }
  
  egg_joystick_get_ids(vidp, pidp, verp, devid) {
    const local = this.gamepads[devid - 1];
    if (!local || (local.devid !== devid)) return;
    // Linux Chrome: Microsoft X-Box 360 pad (STANDARD GAMEPAD Vendor: 045e Product: 028e)
    // Not at all sure how standard that formatting is, but we don't have much else to go on...
    let vid=0, pid=0, version=0;
    let match;
    if (match = local.id.match(/Vendor: ([0-9a-fA-F]{4})/)) {
      vid = parseInt(match[1], 16);
    }
    if (match = local.id.match(/Product: ([0-9a-fA-F]{4})/)) {
      pid = parseInt(match[1], 16);
    }
    if (match = local.id.match(/Version: ([0-9a-fA-F]{4})/)) {
      // This one doesn't exist for me. And not sure whether they'd break it out as MAJOR.MINOR.REVISION.
      // 0xf000=MAJOR, 0x0f00=MINOR, 0x00ff=REVISION
      version = parseInt(match[1], 16);
    }
    if (vidp) this.egg.exec.mem32[vidp >> 2] = vid;
    if (pidp) this.egg.exec.mem32[pidp >> 2] = pid;
    if (verp) this.egg.exec.mem32[verp >> 2] = version;
  }
  
  egg_joystick_get_name(dst, dsta, devid) {
    const local = this.gamepads[devid - 1];
    if (!local || (local.devid !== devid)) return 0;
    const name = local.id.split('(')[0].trim();
    return name || local.id;
    return this.egg.exec.safeWrite(dst, dsta, name);
  }
  
  egg_joystick_for_each_button(devid, cb, ctx) {
    // int (*cb)(int btnid,int usage,int lo,int hi,int value,void *userdata)
    if (!(cb = this.egg.exec.fntab.get(cb))) return 0;

    const local = this.gamepads[devid - 1];
    if (!local || (local.devid !== devid)) return null;
    
    for (let i=0; i<local.axes.length; i++) {
      let hidusage = 0;
      if (local.mapping === "standard") {
        hidusage = Input.STANDARD_AXIS_USAGE[i] || 0;
      }
      const err = cb(local.axisBase + i, hidusage, -128, 127, 0, ctx);
      if (err) return err;
    }
    
    for (let i=0; i<local.buttons.length; i++) {
      let hidusage = 0x00090000 + i;
      if (local.mapping === "standard") {
        const alt = Input.STANDARD_BUTTON_USAGE[i];
        if (alt) hidusage = alt;
      }
      const err = cb(local.buttonBase + i, hidusage, 0, 1, 0, ctx);
    }
    
    return 0;
  }
}

Input.EGG_EVENT_JOY = 1;
Input.EGG_EVENT_KEY = 2;
Input.EGG_EVENT_TEXT = 3;
Input.EGG_EVENT_MMOTION = 4;
Input.EGG_EVENT_MBUTTON = 5;
Input.EGG_EVENT_MWHEEL = 6;
Input.EGG_EVENT_TOUCH = 7;
Input.EGG_EVENT_ACCEL = 8;
Input.EGG_EVENT_RAW = 9;

Input.EGG_JOYBTN_LX    = 0x40;
Input.EGG_JOYBTN_LY    = 0x41;
Input.EGG_JOYBTN_RX    = 0x42;
Input.EGG_JOYBTN_RY    = 0x43;
Input.EGG_JOYBTN_SOUTH = 0x80;
Input.EGG_JOYBTN_EAST  = 0x81;
Input.EGG_JOYBTN_WEST  = 0x82;
Input.EGG_JOYBTN_NORTH = 0x83;
Input.EGG_JOYBTN_L1    = 0x84;
Input.EGG_JOYBTN_R1    = 0x85;
Input.EGG_JOYBTN_L2    = 0x86;
Input.EGG_JOYBTN_R2    = 0x87;
Input.EGG_JOYBTN_AUX2  = 0x88;
Input.EGG_JOYBTN_AUX1  = 0x89;
Input.EGG_JOYBTN_LP    = 0x8a;
Input.EGG_JOYBTN_RP    = 0x8b;
Input.EGG_JOYBTN_UP    = 0x8c;
Input.EGG_JOYBTN_DOWN  = 0x8d;
Input.EGG_JOYBTN_LEFT  = 0x8e;
Input.EGG_JOYBTN_RIGHT = 0x8f;
Input.EGG_JOYBTN_AUX3  = 0x90;

Input.EGG_MBUTTON_LEFT = 1;
Input.EGG_MBUTTON_RIGHT = 2;
Input.EGG_MBUTTON_MIDDLE = 3;

Input.EGG_TOUCH_END = 0;
Input.EGG_TOUCH_BEGIN = 1;
Input.EGG_TOUCH_MOVE = 2;

Input.STANDARD_AXIS_USAGE = [
  0x00010030, // lx
  0x00010031, // ly
  0x00010033, // rx
  0x00010034, // ry
];

Input.STANDARD_BUTTON_USAGE = [
  0x00050037, // south
  0x00050037, // east
  0x00050037, // west
  0x00050037, // north
  0x00050039, // l1
  0x00050039, // r1
  0x00050039, // l2
  0x00050039, // r2
  0x0001003e, // select
  0x0001003d, // start
  0x00090000, // lp
  0x00090001, // rp
  0x00010090, // dup
  0x00010091, // ddown
  0x00010093, // dleft
  0x00010092, // dright
  0x00010085, // heart -- "System Main Menu", debatable.
];
// Do not edit! Generated from src/opt/synth/synth_builtin.c.
const Instruments = [
{"mode":"sub","subQ1":0,"subQ2":0,"subGain":1,"levelTiny":12},
0,
{"mode":"fmrel","fmRate":2,"fmRangeScale":4,"fmRangeEnv":36808,"levelTiny":132},
{"mode":"fmrel","fmRate":1.5,"fmRangeScale":4,"fmRangeEnv":65410,"levelTiny":139},
{"mode":"rock","wave":[0,0.5019607843137255,0.7529411764705882,0.25098039215686274,0.12549019607843137,0.03137254901960784],"mix":3968,"levelTiny":139},
{"mode":"fmabs","fmRate":128,"fmRangeScale":0.0625,"fmRangeEnv":3888,"levelTiny":84},
{"mode":"fmrel","fmRate":5,"fmRangeScale":5,"fmRangeEnv":65520,"levelTiny":5},
{"mode":"fmrel","fmRate":4,"fmRangeScale":5,"fmRangeEnv":36608,"levelTiny":69},
{"mode":"fmrel","fmRate":7.625,"fmRangeScale":8.4375,"fmRangeEnv":63610,"levelTiny":6},
{"mode":"fmrel","fmRate":3,"fmRangeScale":4,"fmRangeEnv":65524,"levelTiny":3},
{"mode":"fmrel","fmRate":6.125,"fmRangeScale":8,"fmRangeEnv":65412,"levelTiny":5},
{"mode":"fmrel","fmRate":4,"fmRangeScale":4,"fmRangeEnv":4084,"levelTiny":13},
{"mode":"fmrel","fmRate":8,"fmRangeScale":3,"fmRangeEnv":65524,"levelTiny":5},
null,
{"mode":"fmrel","fmRate":3.5,"fmRangeScale":6.4375,"fmRangeEnv":63743,"levelTiny":14},
{"mode":"fmrel","fmRate":6,"fmRangeScale":7,"fmRangeEnv":36740,"levelTiny":6},
{"mode":"rock","wave":[0,1,0.00784313725490196,0.3333333333333333,0.00392156862745098,0.2,0,0.06666666666666667],"mix":12172,"levelTiny":213},
{"mode":"rock","wave":[0,0,0.7529411764705882,0.01568627450980392,0.25098039215686274,0.00392156862745098],"mix":49908,"levelTiny":69},
{"mode":"rock","wave":[0,0.7529411764705882,0,0.3764705882352941,0,0.18823529411764706,0,0.09411764705882353],"mix":3972,"levelTiny":148},
{"mode":"rock","wave":[0,0.7529411764705882,0.6274509803921569,0.3764705882352941,0,0.18823529411764706,0,0.09411764705882353],"mix":65520,"levelTiny":158},
{"mode":"rock","wave":[0,0,0.48627450980392156,0.6470588235294118,0.5019607843137255,0.2,0.3764705882352941,0.06666666666666667,0],"mix":4080,"levelTiny":147},
16,
16,
16,
{"mode":"fmrel","fmRate":2,"fmRangeScale":1,"fmRangeEnv":20416,"levelTiny":5},
{"mode":"fx","fmRangeEnv":3968,"fmRangeLfo":0,"fmRangeLfoDepth":0,"fmRate":6,"fmRangeScale":7.5,"detuneRate":4,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.06274509803921569,"levelTiny":68},
{"mode":"fx","fmRangeEnv":4095,"fmRangeLfo":1,"fmRangeLfoDepth":0.5,"fmRate":2,"fmRangeScale":4,"detuneRate":4,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":0,"delayDepth":0,"levelTiny":68},
{"mode":"fx","fmRangeEnv":32644,"fmRangeLfo":2,"fmRangeLfoDepth":1,"fmRate":2,"fmRangeScale":4,"detuneRate":1,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":0.5,"delayDepth":0.25098039215686274,"levelTiny":76},
{"mode":"fx","fmRangeEnv":4080,"fmRangeLfo":2,"fmRangeLfoDepth":2,"fmRate":2,"fmRangeScale":4,"detuneRate":1,"detuneDepth":0.06274509803921569,"overdrive":0.06274509803921569,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":68},
{"mode":"fx","fmRangeEnv":65408,"fmRangeLfo":4,"fmRate":2,"fmRangeScale":3,"levelTiny":76,"detuneRate":4,"detuneDepth":0.00784313725490196,"overdrive":0.3764705882352941,"delayRate":1,"delayDepth":0.12549019607843137},
{"mode":"fx","fmRangeEnv":65348,"fmRangeLfo":2,"fmRangeLfoDepth":0.5,"fmRate":0.5,"fmRangeScale":3,"detuneRate":1,"detuneDepth":0.06274509803921569,"overdrive":0.8784313725490196,"delayRate":1,"delayDepth":0.06274509803921569,"levelTiny":93},
{"mode":"fx","fmRangeEnv":4080,"fmRangeLfo":0,"fmRangeLfoDepth":0,"fmRate":7.4375,"fmRangeScale":8,"detuneRate":1,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.06274509803921569,"levelTiny":93},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":4,"fmRangeEnv":63624,"levelTiny":221},
{"mode":"fx","fmRangeEnv":36804,"fmRangeLfo":2,"fmRangeLfoDepth":0.25,"fmRate":0.5,"fmRangeScale":2,"detuneRate":0,"detuneDepth":0,"overdrive":0,"delayRate":0,"delayDepth":0,"levelTiny":67},
{"mode":"wave","wave":[0,0.7529411764705882,0.7529411764705882,0.18823529411764706,0,0.06274509803921569,0.5019607843137255,0.25098039215686274,0.12549019607843137],"levelTiny":75},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":2,"fmRangeEnv":20352,"levelTiny":156},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":2.5,"fmRangeEnv":28513,"levelTiny":75},
{"mode":"rock","wave":[0,0.25098039215686274,1,0.7529411764705882,0.5019607843137255,0.25098039215686274,0.06274509803921569,0.03137254901960784,0.00784313725490196],"mix":3904,"levelTiny":84},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":3,"fmRangeEnv":20418,"levelTiny":82},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":5,"fmRangeEnv":36848,"levelTiny":76},
{"mode":"rock","wave":[0,0.12549019607843137,0.7529411764705882,0.4392156862745098,0.34509803921568627,0.25098039215686274,0.12549019607843137,0.03137254901960784],"mix":36800,"levelTiny":221},
{"mode":"rock","wave":[0,1,0.5019607843137255,0.3333333333333333,0.25098039215686274,0.2,0.12549019607843137,0.03137254901960784],"mix":36800,"levelTiny":221},
{"mode":"rock","wave":[0,0.25098039215686274,1,0.5019607843137255,0.3333333333333333,0.25098039215686274,0.2,0.12549019607843137,0.03137254901960784],"mix":36800,"levelTiny":220},
{"mode":"fmrel","fmRate":0.5,"fmRangeScale":4,"fmRangeEnv":63624,"levelTiny":221},
{"mode":"fx","fmRangeEnv":4036,"fmRangeLfo":0.5,"fmRangeLfoDepth":0.125,"fmRate":1,"fmRangeScale":2,"detuneRate":0,"detuneDepth":0,"overdrive":0,"delayRate":0,"delayDepth":0,"levelTiny":198},
{"mode":"fx","fmRangeEnv":4036,"fmRangeLfo":0.5,"fmRangeLfoDepth":0.5,"fmRate":1,"fmRangeScale":3,"detuneRate":0.25,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.06274509803921569,"levelTiny":5},
{"mode":"fx","fmRangeEnv":36804,"fmRangeLfo":0,"fmRangeLfoDepth":0,"fmRate":3,"fmRangeScale":3,"detuneRate":0.25,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":6},
{"mode":"sub","subQ1":83.33333333333333,"subQ2":96.66666666666667,"subGain":150,"levelTiny":11},
{"mode":"fx","fmRangeEnv":36804,"fmRangeLfo":4,"fmRangeLfoDepth":0.5,"fmRate":1.5,"fmRangeScale":2,"detuneRate":1,"detuneDepth":0.03137254901960784,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":213},
48,
{"mode":"fx","fmRangeEnv":53220,"fmRangeLfo":4,"fmRangeLfoDepth":0.5,"fmRate":0.5,"fmRangeScale":5,"detuneRate":1,"detuneDepth":0.03137254901960784,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":213},
48,
48,
48,
48,
48,
{"mode":"rock","wave":[0,0.12549019607843137,0.7529411764705882,0.3764705882352941,0.3137254901960784,0.25098039215686274,0.06274509803921569,0.03137254901960784,0.00784313725490196],"mix":61684,"levelTiny":219},
56,
56,
56,
56,
56,
56,
56,
{"mode":"fmrel","fmRate":4,"fmRangeScale":3,"fmRangeEnv":20418,"levelTiny":148},
64,
64,
64,
64,
64,
64,
{"mode":"rock","wave":[0,0.12549019607843137,0.5490196078431373,0.8784313725490196,0,0.45098039215686275,0,0.19215686274509805,0],"mix":255,"levelTiny":76},
"blip",
72,
{"mode":"wave","wave":[0,0.5019607843137255,0.06274509803921569,0.9607843137254902,0,0.2,0,0.06666666666666667,0.01568627450980392],"levelTiny":163},
72,
{"mode":"sub","subQ1":91.66666666666667,"subQ2":95,"subGain":45,"levelTiny":140},
{"mode":"fmrel","fmRate":4.1875,"fmRangeScale":1.5,"fmRangeEnv":3888,"levelTiny":84},
72,
{"mode":"fmrel","fmRate":2,"fmRangeScale":2.5,"fmRangeEnv":36608,"levelTiny":213},
{"mode":"wave","wave":[0,1,0,0.3333333333333333,0,0.2,0,0.06274509803921569],"levelTiny":139},
{"mode":"wave","wave":[0,1,0.5019607843137255,0.3333333333333333,0.25098039215686274,0.2,0.12549019607843137,0.06274509803921569,0.03137254901960784],"levelTiny":147},
{"mode":"rock","wave":[0,0,1,0.12549019607843137],"mix":3968,"levelTiny":141},
"blip",
{"mode":"rock","wave":[0,0,1,0.25098039215686274,0.12549019607843137,0.06274509803921569,0.03137254901960784],"mix":255,"levelTiny":140},
{"mode":"fmrel","fmRate":2.5,"fmRangeScale":2,"fmRangeEnv":63684,"levelTiny":220},
{"mode":"fmrel","fmRate":1.5,"fmRangeScale":4,"fmRangeEnv":36804,"levelTiny":156},
{"mode":"rock","wave":[0,0,0,0,1],"mix":52992,"levelTiny":148},
{"mode":"fx","fmRangeEnv":65535,"fmRangeLfo":8,"fmRangeLfoDepth":2,"fmRate":1,"fmRangeScale":1,"detuneRate":1,"detuneDepth":0.09411764705882353,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":199},
{"mode":"wave","wave":[0,1,0.06274509803921569,0.03137254901960784,0.00784313725490196],"levelTiny":195},
{"mode":"fx","fmRangeEnv":53056,"fmRangeLfo":4,"fmRangeLfoDepth":1,"fmRate":1,"fmRangeScale":4,"detuneRate":4,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":213},
{"mode":"sub","subQ1":86.66666666666667,"subQ2":91.66666666666667,"subGain":40,"levelTiny":220},
{"mode":"sub","subQ1":93.33333333333333,"subQ2":86.66666666666667,"subGain":30,"levelTiny":213},
{"mode":"fx","fmRangeEnv":65520,"fmRangeLfo":4,"fmRangeLfoDepth":0.25,"fmRate":7.375,"fmRangeScale":3,"detuneRate":8,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.03137254901960784,"levelTiny":214},
{"mode":"rock","wave":[0,0,1,0.12549019607843137,0.06274509803921569,0.03137254901960784,0.01568627450980392,0.00784313725490196,0.00392156862745098],"mix":1264,"levelTiny":222},
{"mode":"fx","fmRangeEnv":65535,"fmRangeLfo":4,"fmRangeLfoDepth":2,"fmRate":4,"fmRangeScale":3,"detuneRate":4,"detuneDepth":0.06274509803921569,"overdrive":0,"delayRate":1,"delayDepth":0.03137254901960784,"levelTiny":214},
{"mode":"fx","fmRangeEnv":36848,"fmRangeLfo":8,"fmRangeLfoDepth":8,"fmRate":3.5,"fmRangeScale":6,"detuneRate":0,"detuneDepth":0,"overdrive":0,"delayRate":0.5,"delayDepth":0.6274509803921569,"levelTiny":19},
96,
96,
96,
96,
{"mode":"fx","fmRangeEnv":36848,"fmRangeLfo":4,"fmRangeLfoDepth":4,"fmRate":0.5,"fmRangeScale":4,"detuneRate":0,"detuneDepth":0,"overdrive":0.25098039215686274,"delayRate":1,"delayDepth":0.5019607843137255,"levelTiny":83},
{"mode":"fx","fmRangeEnv":61695,"fmRangeLfo":4,"fmRangeLfoDepth":8,"fmRate":2,"fmRangeScale":1,"detuneRate":1,"detuneDepth":0.12549019607843137,"overdrive":0,"delayRate":0.5,"delayDepth":0.6274509803921569,"levelTiny":83},
{"mode":"fx","fmRangeEnv":4095,"fmRangeLfo":8,"fmRangeLfoDepth":1.5,"fmRate":2,"fmRangeScale":6,"detuneRate":1,"detuneDepth":0.03137254901960784,"overdrive":0.03137254901960784,"delayRate":1,"delayDepth":0.12549019607843137,"levelTiny":205},
"blip",
104,
104,
104,
104,
104,
104,
104,
{"mode":"fmrel","fmRate":9,"fmRangeScale":10,"fmRangeEnv":65423,"levelTiny":6},
{"mode":"fmrel","fmRate":5.4375,"fmRangeScale":4,"fmRangeEnv":65535,"levelTiny":5},
{"mode":"fmrel","fmRate":5.5,"fmRangeScale":4,"fmRangeEnv":61695,"levelTiny":13},
{"mode":"fmrel","fmRate":1.5,"fmRangeScale":2,"fmRangeEnv":4095,"levelTiny":2},
{"mode":"fmrel","fmRate":0.25,"fmRangeScale":3,"fmRangeEnv":61695,"levelTiny":13},
{"mode":"fmrel","fmRate":1.5,"fmRangeScale":3.5,"fmRangeEnv":63728,"levelTiny":11},
{"mode":"fx","fmRangeLfo":0.625,"fmRangeLfoDepth":2,"fmRate":0.5,"fmRangeScale":2,"fmRangeEnv":65408,"detuneRate":0.5,"detuneDepth":0.01568627450980392,"levelTiny":3},
112,
{"mode":"fmrel","fmRate":5.5,"fmRangeScale":10,"fmRangeEnv":63631,"levelTiny":28},
{"mode":"sub","subQ1":86.66666666666667,"subQ2":86.66666666666667,"subGain":30,"levelTiny":91},
{"mode":"sub","subQ1":33.33333333333333,"subQ2":66.66666666666666,"subGain":5,"levelTiny":223},
{"mode":"fmabs","fmRate":128,"fmRangeScale":1.125,"fmRangeEnv":62464,"levelTiny":77},
{"mode":"fmabs","fmRate":256,"fmRangeScale":0.5,"fmRangeEnv":53184,"levelTiny":27},
{"mode":"fmabs","fmRate":128,"fmRangeScale":1,"fmRangeEnv":4080,"levelTiny":141},
"blip",
null,
];
/* ImageDecoder.js
 * Would be awesome if we could use browser facilities for this but alas
 * that is not possible because we have to be synchronous.
 * We could add image formats. But I think we'll advise devs to use PNG exclusively.
 */
 

 
class ImageDecoder {
  constructor() {
  }
  
  /* Returns {w,h,stride,fmt} or throws.
   * We reject images larger than 32767 on either axis, even if otherwise valid.
   */
  decodeHeader(src) {
    if (this.isPng(src)) return this.decodeHeaderPng(src);
    throw new Error(`Image format unknown`);
  }
  
  /* Returns {w,h,stride,fmt,v:Uint8Array} or throws.
   * We reject images larger than 32767 on either axis, even if otherwise valid.
   */
  decode(src) {
    if (this.isPng(src)) return this.decodePng(src);
    throw new Error(`Image format unknown`);
  }
  
  /* PNG.
   ***************************************************************************/
   
  isPng(src) {
    return (
      (src.length >= 8) &&
      (src[0] === 0x89) &&
      (src[1] === 0x50) &&
      (src[2] === 0x4e) &&
      (src[3] === 0x47) &&
      (src[4] === 0x0d) &&
      (src[5] === 0x0a) &&
      (src[6] === 0x1a) &&
      (src[7] === 0x0a)
    );
  }
   
  decodeHeaderPng(src) {
    // We require IHDR to be the first chunk.
    // The spec does say that, but I've seen violations before.
    if (src.length < 26) throw new Error("Invalid PNG");
    const w = (src[16] << 24) | (src[17] << 16) | (src[18] << 8) | src[19];
    const h = (src[20] << 24) | (src[21] << 16) | (src[22] << 8) | src[23];
    if ((w < 1) || (h < 1) || (w > 0x7fff) || (h > 0x7fff)) throw new Error("Invalid PNG");
    let depth = src[24];
    const colortype = src[25];
    switch (colortype) {
      case 0: break;
      case 2: depth *= 3; break;
      case 3: break;
      case 4: depth *= 2; break;
      case 6: depth *= 4; break;
      default: throw new Error("Invalid PNG");
    }
    let fmt;
    switch (depth) {
      case 1: fmt = 3; break;
      case 8: fmt = 2; break;
      case 32: fmt = 1; break;
      // Anything that isn't 1, 8, or 32 bits/pixel, we coerce to 32 at decode.
      case 2: case 4: case 16: case 24: case 48: case 64: fmt = 1; depth = 32; break;
      default: throw new Error("Invalid PNG");
    }
    const stride = (w * depth + 7) >> 3;
    return {w, h, stride, fmt};
  }
  
  decodePng(src) {
    const chunks = this.dechunkPng(src);
    const ihdr = this.decodePngIhdr(chunks.ihdr);
    let fmt;
    switch (ihdr.pixelsize) {
      case 32: fmt = 1; break;
      case 8: fmt = 2; break;
      case 1: fmt = 3; break;
      default: fmt = 0; // force RGBA after preliminary decode
    }
    const filtered = new Zlib.Inflate(chunks.idat).decompress();
    let dst = new Uint8Array(ihdr.stride * ihdr.h);
    this.unfilterPng(dst, filtered, ihdr.stride, ihdr.xstride);
    if (!fmt) {
      const rgbastride = ihdr.w << 2;
      const rgba = new Uint8Array(rgbastride * ihdr.h);
      this.forceRgba(rgba, rgbastride, dst, ihdr, chunks.plte);
      dst = rgba;
      ihdr.stride = rgbastride;
      fmt = 1;
    }
    return {
      w: ihdr.w,
      h: ihdr.h,
      stride: ihdr.stride,
      fmt,
      v: dst,
    };
  }
  
  dechunkPng(src) {
    const chunks = {};
    for (let srcp=8; srcp<src.length; ) {
      const len = (src[srcp] << 24) | (src[srcp+1] << 16) | (src[srcp+2] << 8) | src[srcp+3];
      srcp += 4;
      const cid = (src[srcp] << 24) | (src[srcp+1] << 16) | (src[srcp+2] << 8) | src[srcp+3];
      srcp += 4;
      switch (cid) {
        case 0x49484452: chunks.ihdr = src.slice(srcp, srcp + len); break;
        case 0x504c5445: chunks.plte = src.slice(srcp, srcp + len); break;
        case 0x49444154: { // IDAT
            if (chunks.idat) {
              const nv = new Uint8Array(chunks.idat.length + len);
              nv.set(chunks.idat);
              const dstview = new Uint8Array(nv.buffer, chunks.idat.length, len);
              dstview.set(src.slice(srcp, srcp + len));
              chunks.idat = nv;
            } else {
              chunks.idat = src.slice(srcp, srcp + len);
            }
          } break;
      }
      srcp += len;
      srcp += 4;
    }
    return chunks;
  }
  
  decodePngIhdr(src) {
    if (!src || (src.length < 13)) throw new Error("Invalid PNG");
    const w = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
    const h = (src[4] << 24) | (src[5] << 16) | (src[6] << 8) | src[7];
    if ((w < 1) || (h < 1) || (w > 0x7fff) || (h > 0x7fff)) throw new Error("Invalid PNG");
    const depth = src[8];
    const colortype = src[9];
    if (src[10] || src[11] || src[12]) {
      // We're not supporting interlaced PNG. Compression and filter, there's only one defined for each.
      throw new Error(`Unsupported PNG compression, filter, or interlace (${src[10]}, ${src[11]}, ${src[12]}`);
    }
    let pixelsize = depth;
    switch (colortype) {
      case 0: break;
      case 2: pixelsize *= 3; break;
      case 3: break;
      case 4: pixelsize *= 2; break;
      case 6: pixelsize *= 4; break;
      default: throw new Error("Invalid PNG");
    }
    const xstride = Math.max(1, pixelsize >> 3);
    const stride = (pixelsize * w + 7) >> 3;
    return { w, h, stride, depth, colortype, pixelsize, xstride };
  }
  
  unfilterPng(dst, src, dststride, xstride) {
    const srcstride = 1 + dststride;
    let dstp=0, srcp=0, dstppv=0;
    const paeth = (a, b, c) => {
      const p = a + b - c;
      const pa = Math.abs(p - a);
      const pb = Math.abs(p - b);
      const pc = Math.abs(p - c);
      if ((pa <= pb) && (pa <= pc)) return a;
      if (pb <= pc) return b;
      return c;
    };
    while (dstp < dst.length) {
      const filter = src[srcp++];
      if (dstp) dstppv = dstp - dststride;
      switch (filter) {
        case 0: {
            for (let i=dststride; i-->0; dstp++, srcp++) dst[dstp] = src[srcp];
          } break;
        case 1: {
            let i=0;
            for (; i<xstride; i++, dstp++, srcp++) dst[dstp] = src[srcp];
            for (; i<dststride; i++, dstp++, srcp++) dst[dstp] = src[srcp] + dst[dstp-xstride];
          } break;
        case 2: {
            if (dstp) {
              for (let i=dststride; i-->0; dstp++, dstppv++, srcp++) dst[dstp] = src[srcp] + dst[dstppv];
            } else {
              for (let i=dststride; i-->0; dstp++, srcp++) dst[dstp] = src[srcp];
            }
          } break;
        case 3: {
            let i=0;
            if (dstp) {
              for (; i<xstride; i++, dstp++, srcp++, dstppv++) dst[dstp] = src[srcp] + (dst[dstppv] >> 1);
              for (; i<dststride; i++, dstp++, srcp++, dstppv++) dst[dstp] = src[srcp] + ((dst[dstp-xstride] + dst[dstppv]) >> 1);
            } else {
              for (; i<xstride; i++, dstp++, srcp++) dst[dstp] = src[srcp];
              for (; i<dststride; i++, dstp++, srcp++) dst[dstp] = src[srcp] + (dst[dstp-xstride] >> 1);
            }
          } break;
        case 4: {
            let i=0;
            if (dstp) {
              for (; i<xstride; i++, dstp++, srcp++, dstppv++) dst[dstp] = src[srcp] + dst[dstppv];
              for (; i<dststride; i++, dstp++, srcp++, dstppv++) dst[dstp] = src[srcp] + paeth(dst[dstp-xstride], dst[dstppv], dst[dstppv-xstride]);
            } else { // PAETH is exactly SUB on the first row, but it is legal.
              for (; i<xstride; i++, dstp++, srcp++) dst[dstp] = src[srcp];
              for (; i<dststride; i++, dstp++, srcp++) dst[dstp] = src[srcp] + dst[dstp-xstride];
            }
          } break;
      }
    }
  }
  
  forceRgba(dst, dststride, src, ihdr, plte) {
    for (
      let dstrowp=0, yi=ihdr.h, srciter=this.iteratePng(src, ihdr, plte);
      yi-->0;
      dstrowp+=dststride
    ) {
      for (let dstp=dstrowp, xi=ihdr.w; xi-->0; ) {
        const rgba = srciter();
        dst[dstp++] = rgba >> 24;
        dst[dstp++] = rgba >> 16;
        dst[dstp++] = rgba >> 8;
        dst[dstp++] = rgba;
      }
    }
  }
  
  // Returns a function that returns every pixel LRTB as 32-bit big-endian RGBA.
  // TODO We're not accepting tRNS chunks. Should we?
  iteratePng(src, ihdr, plte) {
    let rowp=0, p=0, xi=ihdr.w, yi=ihdr.h, mask=0x80, shift;
    
    if (plte && (ihdr.colortype === 3)) { // INDEX
      switch (ihdr.depth) {
        case 1: return () => {
            if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; mask = 0x80; } xi--;
            let ix = (src[p] & mask) ? 1 : 0;
            ix *= 3;
            if (mask === 1) { mask = 0x80; p++; }
            else mask >>= 1;
            return (plte[ix] << 24) | (plte[ix+1] << 16) | (plte[ix+2] << 8) | 0xff;
          };
        case 2: shift = 6; return () => {
            if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; shift = 6; } xi--;
            let ix = (src[p] >> shift) & 3;
            ix *= 3;
            if (shift) shift -= 2;
            else { shift = 6; p++; }
            return (plte[ix] << 24) | (plte[ix+1] << 16) | (plte[ix+2] << 8) | 0xff;
          };
        case 4: shift = 4; return () => {
            if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; shift = 4; } xi--;
            let ix = (src[p] >> shift) & 15;
            ix *= 3;
            if (shift) shift = 0;
            else { shift = 6; p++; }
            return (plte[ix] << 24) | (plte[ix+1] << 16) | (plte[ix+2] << 8) | 0xff;
          };
        case 8: return () => {
            if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
            let ix = src[p++];
            ix *= 3;
            return (plte[ix] << 24) | (plte[ix+1] << 16) | (plte[ix+2] << 8) | 0xff;
          };
      }
      
    } else switch (ihdr.colortype) {
      case 0: case 3: switch (ihdr.depth) { // GRAY (or INDEX with missing PLTE)
          case 1: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; mask = 0x80; } xi--;
              const luma = (src[p] & mask) ? 0xff : 0;
              if (mask === 1) { mask = 0x80; p++; }
              else mask >>= 1;
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
          case 2: shift = 6; return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; shift = 6; } xi--;
              let luma = (src[p] >> shift) & 3;
              luma |= luma << 2;
              luma |= luma << 4;
              if (shift) shift -= 2;
              else { shift = 6; p++; }
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
          case 4: shift = 4; return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; shift = 4; } xi--;
              let luma = (src[p] >> shift) & 15;
              luma |= luma << 4;
              if (shift) shift = 0;
              else { shift = 6; p++; }
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
          case 8: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const luma = src[p++];
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
          case 16: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const luma = src[p];
              p += 2;
              return (luma << 24) | (luma << 16) | (luma << 8) | 0xff;
            };
        } break;
      case 2: switch (ihdr.depth) { // RGB
          case 8: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const r = src[p++];
              const g = src[p++];
              const b = src[p++];
              return (r << 24) | (g << 16) | (b << 8) | 0xff;
            };
          case 16: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const r = src[p++]; p++;
              const g = src[p++]; p++;
              const b = src[p++]; p++;
              return (r << 24) | (g << 16) | (b << 8) | 0xff;
            };
        } break;
      case 4: switch (ihdr.depth) { // YA
          case 8: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const luma = src[p++];
              const alpha = src[p++];
              return (luma << 24) | (luma << 16) | (luma << 8) | alpha;
            };
          case 16: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const luma = src[p++]; p++;
              const alpha = src[p++]; p++;
              return (luma << 24) | (luma << 16) | (luma << 8) | alpha;
            };
        } break;
      case 6: switch (ihdr.depth) { // RGBA
          case 8: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const r = src[p++];
              const g = src[p++];
              const b = src[p++];
              const a = src[p++];
              return (r << 24) | (g << 16) | (b << 8) | a;
            };
          case 16: return () => {
              if (xi <= 0) { if (yi <= 0) return 0; yi--; rowp += ihdr.stride; p = rowp; xi = ihdr.w; } xi--;
              const r = src[p++]; p++;
              const g = src[p++]; p++;
              const b = src[p++]; p++;
              const a = src[p++]; p++;
              return (r << 24) | (g << 16) | (b << 8) | a;
            };
        } break;
    }
    return () => 0;
  }
}
 /* Audio.js
 * Implements our synthesizer and exposes the public API.
 */




 
class Audio {
  constructor(egg) {
    this.egg = egg;
    
    this.rate = 44100; // TODO configurable?
    this.context = null;
    this.song = null;
    this.channels = [
      null, null, null, null,
      null, null, null, null,
      null, null, null, null,
      null, null, null, null,
    ];
    this.voices = [];
    this.sounds = {}; // key:"QUAL.RID", value:AudioBuffer
    this.soundEffects = [];
    this.noise = null; // AudioBuffer, null until we need it.
    
    this.hzByNoteid = [];
    for (let noteid=0; noteid<0x80; noteid++) {
      this.hzByNoteid.push(440 * Math.pow(2, (noteid - 69) / 12));
    }
  }
  
  start() {
    if (!window.AudioContext) return;
    this.context = new window.AudioContext({
      sampleRate: this.rate,
      latencyHint: "interactive",
    });
    if (this.context.state === "suspended") {
      this.context.resume();
    }
  }
  
  stop() {
    this.endSong();
    //TODO
  }
  
  update() {
    for (let i=this.voices.length; i-->0; ) {
      const voice = this.voices[i];
      if (!voice.isFinished()) continue;
      voice.terminate();
      this.voices.splice(i, 1);
    }
    if (this.song) {
      this.song.update();
    }
  }
  
  /* Public API.
   *****************************************************************/
  
  egg_audio_play_song(qual, songid, force, repeat) {
    if (!force && this.song && this.song.isResource(qual, songid)) return;
    this.endSong();
    const serial = this.egg.rom.getRes(Rom.RESTYPE_song, qual, songid);
    if (!serial || !serial.length) return;
    try {
      this.song = new Song(serial, this, repeat, qual, songid);
    } catch (e) {
      console.error(`Failed to play song:${qual}:${songid}.`, e);
      return;
    }
    this.beginSong();
  }
  
  egg_audio_play_sound(qual, soundid, trim, pan, when) {
    if (!this.context) return;
    trim /= 65536;
    pan /= 65536;
    if (!when) when = this.context.currentTime;
    const pcm = this.acquireSound(qual, soundid);
    if (!pcm) return;
    const node = new AudioBufferSourceNode(this.context, {
      buffer: pcm,
      channelCount: 1,
    });
    const gain = new GainNode(this.context, { gain: trim });
    node.connect(gain);
    gain.connect(this.context.destination);
    node.start(when);
    this.soundEffects.push(node);
    node.onended = () => {
      const p = this.soundEffects.indexOf(node);
      if (p >= 0) this.soundEffects.splice(p, 1);
    };
  }
  
  egg_audio_event(chid, opcode, a, b) {
    console.log(`TODO egg_audio_event`, { chid, opcode, a, b });
  }
  
  egg_audio_get_playhead() {//TODO
    return -1;
  }
  
  egg_audio_set_playhead(beat) {//TODO
  }
  
  /* Internals.
   ******************************************************************/
   
  endSong() {
    if (!this.song) return;
    this.song = null;
    for (const voice of this.voices) voice.release();
    for (let chid=0; chid<8; chid++) {
      if (this.channels[chid]) {
        this.channels[chid].stop();
        this.channels[chid] = null;
      }
    }
    //TODO Cancel scheduled notes.
  }
  
  beginSong() {
    if (!this.song) return;
    for (let i=0; i<8; i++) {
      this.channels[i] = null;
      const src = this.song.channels[i];
      if (!src.volume) continue;
      this.channels[i] = new Channel(this, src.pid, src.volume, src.pan);
    }
  }
  
  acquireSound(qual, rid) {
    if (!this.context) return null;
    const key = `${qual}.${rid}`;
    if (key in this.sounds) return this.sounds[key];
    let v = null;
    const serial = this.egg.rom.getRes(Rom.RESTYPE_sound, qual, rid);
    if (serial && serial.length) {
      const fv = new SfgPrinter(serial, this.rate).print();
      if (fv && fv.length) {
        v = new AudioBuffer({
          length: fv.length,
          numberOfChannels: 1,
          sampleRate: this.rate,
          channelCount: 1,
        });
        v.copyToChannel(fv, 0);
      }
    }
    this.sounds[key] = v;
    return v;
  }
  
  // (velocity) in 0..127 like MIDI. (when) in AudioContext time.
  playNote(chid, noteid, velocity, durs, when) {
    const channel = this.channels[chid];
    //console.log(`Audio.playNote`, { chid, noteid, velocity, durs, when, channel });
    if (!channel) return;
    channel.playNote(this, noteid, velocity / 127.0, durs, when);
  }
  
  // (v) in 0..0x3fff like MIDI. (when) in AudioContext time.
  changeWheel(chid, v, when) {
    const channel = this.channels[chid];
    if (!channel) return;
    if (!channel.wheelRange) return;
    if (v === channel.wheel) return;
    channel.wheel = v;
    channel.wheelCents = ((v - 0x2000) * channel.wheelRange) / 0x2000;
    //TODO Apply to in-flight voices. Must respect (when) too!
  }
  
  requireNoise() {
    if (this.noise) return;
    const fv = new Float32Array(this.rate);
    for (let i=fv.length; i-->0; ) fv[i] = Math.random() * 2 - 1;
    this.noise = new AudioBuffer({
      length: fv.length,
      numberOfChannels: 1,
      sampleRate: this.rate,
      channelCount: 1,
    });
    this.noise.copyToChannel(fv, 0);
  }
}

/* Song.
 **********************************************************************/
 
const SONG_READAHEAD_WINDOW_S = 0.500;
 
class Song {
  constructor(src, audio, repeat, qual, songid) {
    this.audio = audio;
    this.repeat = repeat;
    this.qual = qual;
    this.songid = songid;
    if (!(src instanceof Uint8Array)) throw new Error(`Expected Uint8Array`);
    if (src.length < 42) throw new Error(`Invalid song`);
    if ((src[0] !== 0xbe) || (src[1] !== 0xee) || (src[2] !== 0xee) || (src[3] !== 0x50)) throw new Error(`Invalid song`);
    this.msperqnote = (src[4] << 8) | src[5];
    this.startp = (src[6] << 8) | src[7];
    this.loopp = (src[8] << 8) | src[9];
    if ((this.startp < 42) || (this.loopp < this.startp) || (this.loopp >= src.length)) throw new Error(`Invalid song`);
    this.src = src;
    this.channels = [];
    for (let srcp=10; srcp<42; srcp+=4) {
      this.channels.push({
        pid: src[srcp],
        volume: src[srcp+1],
        pan: src[srcp+2],
        rsv: src[srcp+3],
      });
    }
    this.startTime = audio.context.currentTime;
    this.readp = this.startp;
    this.readTime = this.startTime;
  }
  
  isResource(qual, songid) {
    return ((qual === this.qual) && (songid === this.songid));
  }
  
  update() {
    const now = this.audio.context.currentTime;
    const later = now + SONG_READAHEAD_WINDOW_S;
    while (this.readTime < later) {
      const event = this.readEvent();
      
      // End of song?
      if (!event) {
        this.audio.endSong();
        return;
      }
      
      // Delay?
      if (typeof(event) === "number") {
        this.readTime += event;
        continue;
      }
      
      // Anything else, readEvent() dispatched it. Carry on.
    }
  }
  
  /* Advance readp and return one event:
   *  - null: EOF and not repeating.
   *  - number: Delay, seconds. Never zero.
   *  - "ok": Processed one event (we dispatch it from here).
   */
  readEvent() {
    const lead = this.src[this.readp++];
    
    // Zero or end of input is End of Song.
    if (!lead) {
      if (!this.repeat) return null;
      this.readp = this.loopp;
      // Must delay a little, in case the song has no explicit delays, so we don't loop forever.
      // Note that if this happens, it's a disaster no matter what.
      return 0.010;
    }
    
    // High bit unset is a delay in ms.
    if (!(lead & 0x80)) {
      return lead / 1000;
    }

    // 1000vvvv cccnnnnn nntttttt : NOTE. duration=(t<<5)ms (~2s max)
    if ((lead & 0xf0) === 0x80) {
      const a = this.src[this.readp++] || 0;
      const b = this.src[this.readp++] || 0;
      let velocity = (lead & 0x0f) << 3;
      velocity |= velocity >> 4;
      const chid = a >> 5;
      const noteid = ((a & 0x1f) << 2) | (b >> 6);
      const durms = ((b & 0x3f) << 5);
      this.audio.playNote(chid, noteid, velocity, durms / 1000, this.readTime);
      return "ok";
    }
    
    // 1001vvcc cnnnnnnn : FIREFORGET. Same as NOTE but duration zero (and coarser velocity).
    if ((lead & 0xf0) === 0x90) {
      const a = this.src[this.readp++] || 0;
      let velocity = ((lead & 0x0c) << 2);
      velocity |= velocity >> 2;
      velocity |= velocity >> 4;
      const chid = ((lead & 0x03) << 1) | (a >> 7);
      const noteid = (a & 0x7f);
      this.audio.playNote(chid, noteid, velocity, 0, this.readTime);
      return "ok";
    }
    
    // 10100ccc wwwwwwww : WHEEL. 8 bits unsigned. 0x40 by default.
    if ((lead & 0xf8) === 0xa0) {
      const a = this.src[this.readp++] || 0;
      const chid = lead & 0x07;
      const v = (a << 6) | (a >> 2);
      this.audio.changeWheel(chid, v, this.readTime);
      return "ok";
    }
    
    // Anything else is reserved and illegal. End the song.
    console.log(`Illegal song command ${lead}.`);
    return null;
  }
}

/* Channel.
 *********************************************************************/
 
class Channel {
  constructor(audio, pid, volume, pan) {
    this.audio = audio;
    this.pid = pid;
    this.volume = volume / 255.0;
    this.master = 0.250;
    this.pan = (pan - 0x80) / 128.0;
    this.mode = "noop";
    this.wheelRange = 200; // cents
    this.wheel = 0; // Last value, 0..0x3fff
    this.wheelCents = 0;
    
    if (this.pid < 0x00) this._initNoop();
    else if (this.pid < 0x80) this._initBuiltin(audio);
    else if (this.pid < 0x100) this._initDrum();
    else this._initNoop();
  }
  
  _initNoop() {
    this.mode = "noop";
    this.wheelRange = 0;
  }
  
  _initDrum() {
    this.mode = "drum";
    this.wheelRange = 0;
    this.drumBase = (this.pid - 0x80) * 0x80;
  }
  
  _initBuiltin(audio) {
    let cfg = Instruments[this.pid];
    if (typeof(cfg) === "number") {
      cfg = Instruments[cfg];
    }
    if (!cfg) return this._initNoop();
    if (typeof(cfg) === "string") {
      this.mode = cfg;
      return;
    }
    for (const k of Object.keys(cfg)) {
      this[k] = cfg[k];
    }
    if (this.wave) {
      this.wave = new PeriodicWave(audio.context, { real: this.wave });
    }
    if (this.mode === "fx") {
      this.fxBegin(audio);
    }
  }
  
  // (velocity) normalized
  playNote(audio, noteid, velocity, durs, when) {
    switch (this.mode) {
      case "noop": break;
      
      case "drum": {
          const soundid = this.drumBase + noteid;
          const trim = 0.200 + (this.volume * this.master * velocity) * 0.900;
          audio.egg_audio_play_sound(0, soundid, trim * 65536.0, this.pan, when);
        } break;
        
      case "blip": {
          const attackTime = 0.010;
          const releaseTime = 0.050;
          const level = this.volume * this.master * (velocity + 0.079) * 0.400;
          const voice = new Voice(audio);
          voice.oscillateShape("square", audio.hzByNoteid[noteid], this.wheelCents);
          voice.plateauLevel(when, attackTime, level, durs, releaseTime);
          voice.begin();
        } break;
        
      case "wave": {
          const voice = new Voice(audio);
          voice.oscillateWave(this.wave, audio.hzByNoteid[noteid], this.wheelCents);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
        } break;
        
      case "rock": {
          const voice = new Voice(audio);
          voice.oscillateMix(this.wave, this.mix, audio.hzByNoteid[noteid], this.wheelCents);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
        } break;
        
      case "fmrel": {
          const voice = new Voice(audio);
          voice.oscillateFmRelative(audio.hzByNoteid[noteid], this.wheelCents, this.fmRate, this.fmRangeScale, this.fmRangeEnv);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
        } break;
        
      case "fmabs": {
          const voice = new Voice(audio);
          voice.oscillateFmAbsolute(audio.hzByNoteid[noteid], this.wheelCents, this.fmRate, this.fmRangeScale, this.fmRangeEnv);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
        } break;
        
      case "sub": {
          const voice = new Voice(audio);
          voice.oscillateSubtractive(audio.hzByNoteid[noteid], this.wheelCents, this.subQ1, this.subQ2, this.subGain);
          voice.tinyEnv(when, this.levelTiny, durs, velocity, this.volume * this.master);
          voice.begin();
        } break;
        
      case "fx": {
          this.fxNote(audio, when, noteid, velocity, durs);
        } break;
    }
  }
  
  stop() {
    switch (this.mode) {
      case "fx": this.fxStop(); break;
    }
  }
  
  fxBegin(audio) {
    this.audio = audio;
    this.fxMaster = new GainNode(audio.context);
    this.fxMaster.gain.setValueAtTime(this.volume * this.master, 0);
    this.fxMaster.connect(audio.context.destination);
    this.fxVoices = [];
    this.fxAttach = this.fxMaster;
    
    //TODO detune. Can't do it in post like the C implementation, but I think we can vary the voice's frequencies.
    
    if ((this.fmRangeLfo > 0) && (this.fmRangeLfoDepth > 0)) {
      let beatRate = 2;
      if (this.audio.song && (this.audio.song.msperqnote > 0)) {
        beatRate = 1000 / this.audio.song.msperqnote;
      }
      const osc = new OscillatorNode(this.audio.context, {
        type: "sine",
        frequency: beatRate / this.fmRangeLfo,
      });
      const gain = new GainNode(this.audio.context, {
        gain: this.fmRangeLfoDepth * 100, // TODO No idea why this *100 is needed.
      });
      osc.connect(gain);
      osc.start();
      this.fmLfo = osc;
      this.fmLfoOut = gain;
    }
    
    if ((this.delayRate > 0) && (this.delayDepth > 0) && this.audio.song && (this.audio.song.msperqnote > 0)) {
      const wetLevel = this.delayDepth * 0.500;
      const dryLevel = 1 - wetLevel;
      const period = (this.delayRate * this.audio.song.msperqnote) / 1000;
      const delay = new DelayNode(this.audio.context, { delayTime: period });
      
      const intake = new GainNode(this.audio.context, { gain: 1 });
      const output = new GainNode(this.audio.context, { gain: 1 });
      const dryGain = new GainNode(this.audio.context, { gain: dryLevel });
      const wetGain = new GainNode(this.audio.context, { gain: wetLevel });
      intake.connect(dryGain);
      dryGain.connect(output);
      intake.connect(delay);
      delay.connect(wetGain);
      wetGain.connect(delay);
      wetGain.connect(output);
      output.connect(this.fxAttach);
      this.fxAttach = intake;
    }
    
    if (this.overdrive > 0) {
      const len = 99;
      const odrange = 8;
      const midp = len >> 1;
      const odscaled = 0.5 + this.overdrive * (odrange - 0.5);
      const odcurved = 1 / odscaled; // Now in (1/odrange)..2
      const odnormed = (odcurved - 1 / odrange) / (2 - 1 / odrange);
      const ramplen = midp * odnormed;
      const vv = new Float32Array(len);
      for (let i=0; i<ramplen; i++) {
        vv[midp + i + 1] = Math.sin((i * Math.PI / 2) / ramplen);
      }
      for (let i=midp+ramplen+1; i<len; i++) {
        vv[i] = 1;
      }
      for (let dst=midp, src=midp+1; dst-->0; src++) {
        vv[dst] = -vv[src];
      }
      const shaper = new WaveShaperNode(this.audio.context, {
        curve: vv,
      });
      // Also some attenuation, after the wave-shape, since we're raising its average level.
      if (this.overdrive >= 0.25) {
        const drop = new GainNode(this.audio.context, {
          gain: 1 - (this.overdrive - 0.25) * 0.8,
        });
        shaper.connect(drop);
        drop.connect(this.fxAttach);
      } else {
        shaper.connect(this.fxAttach);
      }
      this.fxAttach = shaper;
    }
  }
  
  fxStop() {
    if (this.fxMaster) {
      this.fxMaster.disconnect();
      this.fxMaster = null;
    }
    if (this.fmLfo) {
      this.fmLfo.stop();
      this.fmLfo.disconnect();
      this.fmLfo = null;
    }
    if (this.fmLfoOut) {
      this.fmLfoOut.disconnect();
      this.fmLfoOut = null;
    }
  }
  
  fxNote(audio, when, noteid, velocity, durs) {
    const voice = new Voice(this.audio);
    voice.oscillateFmRelative(this.audio.hzByNoteid[noteid], this.wheelCents, this.fmRate, this.fmRangeScale, this.fmRangeEnv, this.fmLfoOut);
    voice.tinyEnv(when, this.levelTiny, durs, velocity, 1);
    voice.begin(this.fxAttach);
  }
}

/* Voice.
 *******************************************************************/
 
class Voice {
  constructor(audio) {
    this.audio = audio;
    this.osc = null;
    this.env = null;
    this.endTime = 0;
  }
  
  isFinished() {
    if (!this.audio || !this.audio.context || !this.env) return true;
    return (this.audio.context.currentTime > this.endTime);
  }
  
  terminate() {
    if (this.env) {
      this.env.disconnect();
      this.env = null;
    }
    if (this.osc) {
      if (this.osc.stop) this.osc.stop();
      this.osc.disconnect();
      this.osc = null;
    }
    if (this.oscDry) {
      this.oscDry.stop();
      this.oscDry.disconnect();
      this.oscDry = null;
    }
    if (this.oscWet) {
      this.oscWet.stop();
      this.oscWet.disconnect();
      this.oscWet = null;
    }
    if (this.modosc) {
      this.modosc.stop();
      this.modosc.disconnect();
      this.modosc = null;
    }
    if (this.noiseNode) {
      this.noiseNode.stop();
      this.noiseNode.disconnect();
      this.noiseNode = null;
    }
    if (this.post) {
      this.post.disconnect();
      this.post = null;
    }
  }
  
  release() {
  }
  
  begin(dst) {
    if (!this.audio || !this.env) return;
    if (!dst) dst = this.audio.context.destination;
    if (this.osc) {
      this.osc.connect(this.env);
      if (this.osc.start) this.osc.start();
    } else if (this.gainDry) {
      this.gainDry.connect(this.env);
      this.gainWet.connect(this.env);
      this.oscDry.start();
      this.oscWet.start();
    } else {
      return;
    }
    if (this.post) this.post.connect(dst);
    else this.env.connect(dst);
    this.audio.voices.push(this);
  }
  
  oscillateShape(type, frequency, detune) {
    this.osc = new OscillatorNode(this.audio.context, {
      type,
      frequency,
      detune,
    });
  }
  
  oscillateWave(periodicWave, frequency, detune) {
    this.osc = new OscillatorNode(this.audio.context, {
      periodicWave,
      frequency,
      detune,
    });
  }
  
  // (mix) is 4 levels, 4 bits each, big-endian. eg 0xf842 = [1.0, 0.5, 0.25, 0.125]
  oscillateMix(periodicWave, mix, frequency, detune) {
    this.oscDry = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency,
      detune,
    });
    this.oscWet = new OscillatorNode(this.audio.context, {
      periodicWave,
      frequency,
      detune,
    });
    this.gainDry = new GainNode(this.audio.context);
    this.gainWet = new GainNode(this.audio.context);
    this.oscDry.connect(this.gainDry);
    this.oscWet.connect(this.gainWet);
    this.mix = mix;
  }
  
  oscillateFmRelative(frequency, detune, rate, scale, env, lfo) {
    this.osc = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency,
      detune,
    });
    this.modosc = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency: frequency * rate * Math.pow(2, detune / 1200),
    });
    this.modgain = new GainNode(this.audio.context);
    if (lfo) {
      this.fmGainLfo = lfo;
      this.fmGainLfo.connect(this.modgain.gain);
      this.modgain.gain.setValueAtTime(1, 0);
      this.modgain.connect(this.osc.frequency);
    } else {
      this.modgain.connect(this.osc.frequency);
    }
    this.modgainPeak = scale * frequency;
    this.fmRangeEnv = env;
    this.modosc.connect(this.modgain);
    this.modosc.start();
  }
  
  oscillateFmAbsolute(frequency, detune, rate, scale, env) {
    this.osc = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency,
      detune,
    });
    this.modosc = new OscillatorNode(this.audio.context, {
      type: "sine",
      frequency: rate,
    });
    this.modgain = new GainNode(this.audio.context);
    this.modgainPeak = scale * frequency;
    this.fmRangeEnv = env;
    this.modgain.connect(this.osc.frequency);
    this.modosc.connect(this.modgain);
    this.modosc.start();
  }
  
  oscillateSubtractive(frequency, detune, q1, q2, gain) {
    this.audio.requireNoise();
    this.noiseNode = new AudioBufferSourceNode(this.audio.context, {
      buffer: this.audio.noise,
      channelCount: 1,
      loop: true,
      loopStart: 0,
      loopEnd: this.audio.noise.duration,
    });
    const filter1 = new BiquadFilterNode(this.audio.context, {
      type: "bandpass",
      Q: q1,
      frequency,
    });
    const filter2 = new BiquadFilterNode(this.audio.context, {
      type: "bandpass",
      Q: q2,
      frequency,
    });
    const gainNode = new GainNode(this.audio.context);
    gainNode.gain.setValueAtTime(gain, 0);
    this.noiseNode.connect(filter1);
    filter1.connect(filter2);
    filter2.connect(gainNode);
    this.osc = gainNode;
    this.noiseNode.start();
  }
  
  plateauLevel(when, attackTimeRel, peakLevel, sustainTimeRel, releaseTimeRel) {
    this.endTime = when + attackTimeRel + sustainTimeRel + releaseTimeRel;
    this.env = new GainNode(this.audio.context);
    this.env.gain.setValueAtTime(0, 0);
    this.env.gain.setValueAtTime(0, when);
    this.env.gain.linearRampToValueAtTime(peakLevel, when + attackTimeRel);
    this.env.gain.setValueAtTime(peakLevel, when + attackTimeRel + sustainTimeRel);
    this.env.gain.linearRampToValueAtTime(0, this.endTime);
  }
  
  /* A format I use in the C implementation for single-byte level envelopes:
   *   0xc0 Decay relative to attack:
   *         0x00 IMPULSE: Do not sustain.
   *         0x40 PLUCK: Heavy loss after attack.
   *         0x80 TONE: Attack noticeably louder than sustain.
   *         0xc0 BOW: No appreciable attack.
   *   0x38 Attack time: 0x00=Fast .. 0x38=Slow
   *   0x07 Release time: 0x00=Short .. 0x07=Long
   */
  tinyEnv(when, v, durs, velocity, trim) {
    let attackTimeHi;
    switch (v & 0x38) {
      case 0x00: attackTimeHi = 0.005; break;
      case 0x08: attackTimeHi = 0.008; break;
      case 0x10: attackTimeHi = 0.012; break;
      case 0x18: attackTimeHi = 0.018; break;
      case 0x20: attackTimeHi = 0.030; break;
      case 0x28: attackTimeHi = 0.045; break;
      case 0x30: attackTimeHi = 0.060; break;
      case 0x38: attackTimeHi = 0.080; break;
    }
    let releaseTimeHi;
    switch (v & 0x07) {
      case 0x00: releaseTimeHi = 0.040; break;
      case 0x01: releaseTimeHi = 0.060; break;
      case 0x02: releaseTimeHi = 0.100; break;
      case 0x03: releaseTimeHi = 0.200; break;
      case 0x04: releaseTimeHi = 0.400; break;
      case 0x05: releaseTimeHi = 0.600; break;
      case 0x06: releaseTimeHi = 0.800; break;
      case 0x07: releaseTimeHi = 1.200; break;
    }
    let sustain = true;
    let attackValueHi = 1;
    let sustainValueHi;
    switch (v & 0xc0) {
      case 0x00: { // IMPULSE
          sustain = false;
          sustainValueHi = 0.250;
        } break;
      case 0x40: { // PLUCK
          sustainValueHi = 0.200;
        } break;
      case 0x80: { // TONE
          attackValueHi = 0.750;
          sustainValueHi = 0.400;
        } break;
      case 0xc0: { // BOW
          attackValueHi = 0.400;
          sustainValueHi = 0.400;
        } break;
    }
    let decayTimeHi = (attackTimeHi * 3) / 2;
    const attackTimeLo = attackTimeHi * 2;
    const decayTimeLo = decayTimeHi * 2;
    const releaseTimeLo = releaseTimeHi * 0.5;
    const attackValueLo = attackValueHi * 0.333;
    const sustainValueLo = sustainValueHi * 0.500;
    let a, b;
    if (velocity <= 0) { a=1; b=0; }
    else if (velocity >= 1) { a=0; b=1; }
    else { a = 1 - velocity; b = velocity; }
    const attackTime = attackTimeLo * a + attackTimeHi * b;
    const attackValue = (attackValueLo * a + attackValueHi * b) * trim;
    const decayTime = decayTimeLo * a + decayTimeHi * b;
    const sustainValue = (sustainValueLo * a + sustainValueHi * b) * trim;
    if (!sustain) durs = 0;
    const releaseTime = releaseTimeLo * a + releaseTimeHi * b;
    this.endTime = when + attackTime + decayTime + durs + releaseTime;
    
    this.env = new GainNode(this.audio.context);
    this.env.gain.setValueAtTime(0, 0);
    this.env.gain.setValueAtTime(0, when);
    this.env.gain.linearRampToValueAtTime(attackValue, when + attackTime);
    this.env.gain.linearRampToValueAtTime(sustainValue, when + attackTime + decayTime);
    this.env.gain.setValueAtTime(sustainValue, when + attackTime + decayTime + durs);
    this.env.gain.linearRampToValueAtTime(0, this.endTime);
    
    if (this.gainDry && this.gainWet) {
      const v0 = (this.mix >> 12) / 15.0;
      const v1 = ((this.mix >> 8) & 15) / 15.0;
      const v2 = ((this.mix >> 4) & 15) / 15.0;
      const v3 = (this.mix & 15) / 15.0;
      this.gainDry.gain.setValueAtTime(0, 0);
      this.gainDry.gain.setValueAtTime(1 - v0, when);
      this.gainDry.gain.linearRampToValueAtTime(1 - v1, when + attackTime);
      this.gainDry.gain.linearRampToValueAtTime(1 - v2, when + attackTime + decayTime);
      this.gainDry.gain.linearRampToValueAtTime(1 - v2, when + attackTime + decayTime + durs);
      this.gainDry.gain.linearRampToValueAtTime(1 - v3, this.endTime);
      this.gainWet.gain.setValueAtTime(0, 0);
      this.gainWet.gain.setValueAtTime(v0, when);
      this.gainWet.gain.linearRampToValueAtTime(v1, when + attackTime);
      this.gainWet.gain.linearRampToValueAtTime(v2, when + attackTime + decayTime);
      this.gainWet.gain.linearRampToValueAtTime(v2, when + attackTime + decayTime + durs);
      this.gainWet.gain.linearRampToValueAtTime(v3, this.endTime);
    }
    
    if (this.fmRangeEnv && !this.fmRangeLfo) {
      if (this.fmRangeEnv === 0xffff) {
        this.modgain.gain.setValueAtTime(this.modgainPeak, 0);
      } else {
        const v0hi = (this.modgainPeak * (this.fmRangeEnv >> 12)) / 15.0;
        const v1hi = (this.modgainPeak * ((this.fmRangeEnv >> 8) & 15)) / 15.0;
        const v2hi = (this.modgainPeak * ((this.fmRangeEnv >> 4) & 15)) / 15.0;
        const v3hi = (this.modgainPeak * (this.fmRangeEnv & 15)) / 15.0;
        const avg = (v0hi + v1hi + v2hi + v3hi) / 4;
        const v0lo = (v0hi + avg) / 2;
        const v1lo = (v1hi + avg) / 2;
        const v2lo = (v2hi + avg) / 2;
        const v3lo = (v3hi + avg) / 2;
        const v0 = v0lo * (1 - velocity) + v0hi * velocity;
        const v1 = v1lo * (1 - velocity) + v1hi * velocity;
        const v2 = v2lo * (1 - velocity) + v2hi * velocity;
        const v3 = v3lo * (1 - velocity) + v3hi * velocity;
        this.modgain.gain.setValueAtTime(v0, 0);
        this.modgain.gain.setValueAtTime(v0, when);
        this.modgain.gain.linearRampToValueAtTime(v1, when + attackTime);
        this.modgain.gain.linearRampToValueAtTime(v2, when + attackTime + decayTime);
        this.modgain.gain.setValueAtTime(v2, when + attackTime + decayTime + durs);
        this.modgain.gain.linearRampToValueAtTime(v3, this.endTime);
      }
    }
  }
}
/* SysExtra.js
 * Little helpers for the public API. Log, date, language...
 */
 
class SysExtra {
  constructor(window) {
    this.window = window;
    this.storage = null;
    this.storageKey = "egg"; // Set before the first access.
  }
  
  /* Returns:
   * {
   *   srcc: Length of (src) consumed.
   *   align: -1|0|1.
   *   fill: ' ' or '0'.
   *   len: integer or "*" to read from vargs.
   *   prec: integer or "*" to read from vargs, <0 if unspecified.
   *   value: null, you fill in from vargs.
   *   spec: Single character.
   * }
   * Or null if malformed.
   */
  parseLogFormatUnit(src, srcp) {
    const srcp0 = srcp;
    if (srcp >= src.length) return null;
    if (src[srcp++] !== '%') return null;
    
    let align = 1;
    if (src[srcp] === '-') {
      align = -1;
      srcp++;
    } else if (src[srcp] === '+') {
      align = 1;
      srcp++;
    } else if (src[srcp] === '=') {
      align = 0;
      srcp++;
    }
    
    let fill = ' ';
    if (src[srcp] === '0') {
      fill = '0';
      srcp++;
    }
    
    let len = 0;
    if (src[srcp] === '*') {
      len = '*';
      srcp++;
    } else while ((src[srcp] >= '0') && (src[srcp] <= '9')) {
      len *= 10;
      len += src.charCodeAt(srcp) - 0x30;
      srcp++;
    }
    
    let prec = -1;
    if (src[srcp] === '.') {
      srcp++;
      if (src[srcp] === '*') {
        prec = '*';
        srcp++;
      } else {
        prec = 0;
        while ((src[srcp] >= '0') && (src[srcp] <= '9')) {
          prec *= 10;
          prec += src.charCodeAt(srcp) - 0x30;
          srcp++;
        }
      }
    }
    
    let spec;
    switch (src[srcp]) {
      case 'd':
      case 'x':
      case 'p':
      case 'l':
      case 'f':
      case 's':
      case 'c': {
          spec = src[srcp];
          srcp++;
        } break;
      default: return null;
    }
    return { srcc: srcp - srcp0, fill, align, len, prec, spec, value: null };
  }
  
  applyLogFormatUnit(unit) {
    let pre = "";
    switch (unit.spec) {
      case 'u': pre = (~~unit.value || 0).toString(); break;
      case 'd': pre = (~~unit.value || 0).toString(); break;
      case 'x': pre = (~~unit.value || 0).toString(16); break;
      case 'p': pre = (~~unit.value || 0).toString(16); break;
      case 'l': pre = (~~unit.value || 0).toString(); break;
      case 'f': pre = (+unit.value).toString(); break; // TODO prec
      case 's': pre = (unit.value || "").toString(); if (unit.prec >= 0) pre = pre.substring(0, unit.prec); break;
      case 'c': pre = String.fromCharCode(~~unit.value || 0x3f); break;
    }
    let spaces = "                              ";
    if (unit.fill === '0') {
      spaces = "0000000000000000000000000000000000";
    }
    if (pre.length < unit.len) switch (unit.align) {
      case -1: pre += spaces.substring(0, unit.len - pre.length); break;
      case 0: {
          const addc = unit.len - pre.length;
          const each = addc >> 1;
          const more = addc & 1;
          pre = spaces.substring(0, each) + pre +spaces.substring(0, each + more);
        } break;
      case 1: pre = spaces.substring(0, unit.len - pre.length) + pre; break;
    }
    return pre;
  }
  
  /* (vargs) can be an array of values or an iterator function: (spec:[udxplfsc],prec) => any
   */
  applyLogFormat(fmt, vargs) {
    if (!fmt) return "";
    if (!vargs) return fmt;
    let fmtp=0, vargsp=0, dst="";
    while (fmtp < fmt.length) {
      let nextp = fmt.indexOf('%', fmtp);
      if (nextp < 0) nextp = fmt.length;
      if (nextp > fmtp) {
        dst += fmt.substring(fmtp, nextp);
        fmtp = nextp;
        if (fmtp >= fmt.length) break;
      }
      if (fmt[fmtp + 1] === '%') {
        dst += "%";
        fmtp += 2;
        continue;
      }
      const unit = this.parseLogFormatUnit(fmt, fmtp);
      if (!unit) {
        dst += fmt[fmtp++];
        continue;
      }
      fmtp += unit.srcc;
      if (typeof(vargs) === "function") {
        if (unit.len === "*") unit.len = vargs('u');
        if (unit.prec === "*") unit.prec = vargs('u');
        unit.value = vargs(unit.spec, unit.prec);
      } else {
        if (unit.len === "*") unit.len = vargs[vargsp++] || 0;
        if (unit.prec === "*") unit.prec = vargs[vargsp++] || 0;
        unit.value = vargs[vargsp++];
      }
      dst += this.applyLogFormatUnit(unit);
    }
    return dst;
  }
  
  getUserLanguages() {
    let list = this.window.navigator.languages;
    if (list && (list.length > 0)) {
      list = Array.from(new Set(list.map(l => this.evalLang(l)).filter(v => v)));
    }
    if (!list) list = [];
    if (!list.length) {
      const code = this.evalLang(this.window.navigator.language);
      if (code) list.push(code);
    }
    return list;
  }
  
  evalLang(src) {
    if (!src) return 0;
    if (src.length >= 2) {
      let a = src.charCodeAt(0);
      let b = src.charCodeAt(1);
      if ((a >= 0x61) && (a <= 0x7a)) a = a - 0x61 + 6;
      else if ((a >= 0x30) && (a <= 0x35)) a = a - 0x30;
      else return 0;
      if ((b >= 0x61) && (b <= 0x7a)) b = b - 0x61 + 6;
      else if ((b >= 0x30) && (b <= 0x35)) b = b - 0x30;
      else return 0;
      return (a << 5) | b;
    }
    return 0;
  }
}
/* Egg.js
 * Top level coordinator for the Egg Web Runtime.
 * You must provide a valid Rom at construction.
 */
 








 
class Egg {
  constructor(rom) {
    this.rom = rom;
    this.data = new DataService(this);
    this.sysExtra = new SysExtra(window);
    this.input = new Input(this);
    this.audio = new Audio(this);
    this.imageDecoder = new ImageDecoder();
    this.canvas = null;
    this.render = null;
    this.exec = null;
    this.running = false;
    this.loaded = false;
    this.pvtime = 0;
    this.pendingFrame = null;
    this.restoreTitle = document.title;
    this.directgl = false;
  }
  
  attachToDom() {
    const body = document.body;
    body.innerHTML = "";
    
    // Optional "terminate" button. XXX This shouldn't be in the final product; whoever embeds us should provide this.
    const terminate = document.createElement("INPUT");
    terminate.setAttribute("type", "button");
    terminate.setAttribute("value", "Terminate");
    terminate.addEventListener("click", () => this.stop());
    terminate.style.display = "block";
    body.appendChild(terminate);
    
    this.canvas = document.createElement("CANVAS");
    this.setCanvasSize();
    body.appendChild(this.canvas);
    this.render = new Render(this);
    this.exec = new Exec(this);
    this.retitlePerRom();
  }
  
  setCanvasSize() {
    const match = this.data.getMetadata("framebuffer").match(/^(\d+)x(\d+)\s?(.*)/);
    if (!match) throw new Error("ROM does not declare its framebuffer size.");
    this.canvas.width = +match[1];
    this.canvas.height = +match[2];
    this.directgl = false;
    for (const token of match[3].split(/\s+/)) {
      if (token === "gl") this.directgl = true;
    }
    this.input.canvasChanged();
  }
  
  retitlePerRom() {
    document.title = this.data.getMetadata("title");
    let url = "";
    const iconImageId = +this.data.getMetadata("iconImage");
    if (iconImageId) {
      const serial = this.rom.getRes(Rom.RESTYPE_image, 0, iconImageId);
      if (serial.length > 0) {
        const crop = new Uint8Array(serial.length);
        crop.set(serial);
        const blob = new Blob([crop.buffer], { type: "image/png" });
        url = URL.createObjectURL(blob);
      }
    }
    for (const link of window.document.querySelectorAll("link[rel='icon']")) link.remove();
    if (url) {
      const link = window.document.createElement("LINK");
      link.setAttribute("data-egg-favicon", "");
      link.setAttribute("rel", "icon");
      link.setAttribute("type", "image/png");
      link.setAttribute("href", url);
      window.document.head.appendChild(link);
    }
  }
  
  retitleDefault() {
    document.title = this.restoreTitle;
    for (const link of window.document.querySelectorAll("link[rel='icon']")) link.remove();
  }
  
  start() {
    if (this.running) return;
    this.running = true;
    this.loaded = false;
    this.pvtime = 0;
    this.audio.start();
    return this.exec.load().then(() => {
      this.loaded = true;
      if (this.exec.egg_client_init() < 0) {
        throw new Error("Game aborted during startup.");
      }
      this.exec.egg_client_init = () => -1;
      this.pendingFrame = window.requestAnimationFrame(() => this.update());
    });
  }
  
  stop() {
    if (!this.running) return;
    this.audio.stop();
    this.input.detach();
    this.running = false;
    if (this.loaded) {
      this.exec.egg_client_quit();
      this.exec.egg_client_quit = () => {};
      this.loaded = false;
    }
    if (this.pendingFrame) {
      window.cancelAnimationFrame(this.pendingFrame);
      this.pendingFrame = null;
    }
    if (this.render) this.render.stop();
    this.retitleDefault();
  }
  
  update() {
    this.pendingFrame = null;
    if (!this.running) return;
    this.audio.update();
    this.input.update();
    const elapsed = this.tick();
    if (elapsed >= 0) {
      this.exec.egg_client_update(elapsed);
      if (!this.running) return;
      this.render.begin();
      this.exec.egg_client_render();
      this.render.end();
    }
    this.pendingFrame = window.requestAnimationFrame(() => this.update());
  }
  
  tick() {
    if (!this.pvtime) { // Very first update only, we update with zero time elapsed.
      this.pvtime = Date.now();
      return 0;
    }
    const now = Date.now();
    let elapsed = (now - this.pvtime) / 1000;
    if (elapsed < 0.015) return -1; // skip a frame (eg high-frequency monitors, don't let us run at 200 Hz or whatever)
    this.pvtime = now;
    return Math.min(0.050, elapsed); // Very long elapsed time, clamp at 50 ms.
  }
  
  /*------------------------ Public API entry points ------------------------*/
  
  egg_log(fmt, vargs) {
    const msg = this.sysExtra.applyLogFormat(
      this.exec.readCString(fmt),
      (spec, prec) => { // udxplfsc
        switch (spec) {
          case 'u': case 'd': case 'x': case 'c': case 'p': {
              const v = this.exec.mem32[vargs >> 2] || 0;
              vargs += 4;
              return v;
            }
          case 'l': {
              const v = this.exec.mem32[vargs >> 2] | (this.exec.mem32[(vargs+4) >> 2] * 4294967296);
              vargs += 8;
              return v;
            }
          case 'f': {
              if (vargs & 7) vargs = (vargs + 8) & ~7;
              const v = this.exec.memf64[vargs >> 3];
              vargs += 8;
              return v;
            }
          case 's': {
              let v;
              const p = this.exec.mem32[vargs >> 2];
              if (prec >= 0) v = this.exec.readLimitedString(p, prec);
              else v = this.exec.readCString(p);
              vargs += 4;
              return v;
            }
        }
      }
    );
    console.log(`GAME: ${msg}`);
  }
  
  egg_time_local(v, a) {
    if (a < 1) return;
    v >>= 2;
    const now = new Date();
    this.exec.mem32[v++] = now.getFullYear();
    if (a < 2) return;
    this.exec.mem32[v++] = 1 + now.getMonth();
    if (a < 3) return;
    this.exec.mem32[v++] = now.getDate();
    if (a < 4) return;
    this.exec.mem32[v++] = now.getHours();
    if (a < 5) return;
    this.exec.mem32[v++] = now.getMinutes();
    if (a < 6) return;
    this.exec.mem32[v++] = now.getSeconds();
    if (a < 7) return;
    this.exec.mem32[v++] = now.getMilliseconds();
  }
  
  egg_get_user_languages(v, a) {
    const src = this.sysExtra.getUserLanguages();
    const cpc = Math.min(a, src.length);
    for (let i=0, dstp=v>>2; i<cpc; i++, dstp++) {
      this.exec.mem32[dstp] = src[i];
    }
    return src.length;
  }
  
  egg_res_get(dst, dsta, tid, qual, rid) {
    const serial = this.rom.getRes(tid, qual, rid);
    return this.exec.safeWrite(dst, dsta, serial);
  }
  
  egg_res_for_each(cb, ctx) {
    if (!(cb = this.exec.fntab.get(cb))) return 0;
    for (const { tid, qual, rid, v } of this.rom.resv) {
      const err = cb(tid, qual, rid, v.length, ctx);
      if (err) return err;
    }
    return 0;
  }
}
</script>
</head>
<body>
</body>
</html>
